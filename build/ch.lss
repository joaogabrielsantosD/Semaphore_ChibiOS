
build/ch.elf: formato do arquivo elf32-avr

Seções:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000090  00800100  0000272e  000027c2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000272e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000562  00800190  00800190  00002852  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00002852  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002864  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000790  00000000  00000000  000028a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001bbb8  00000000  00000000  00003034  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004c0f  00000000  00000000  0001ebec  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00008727  00000000  00000000  000237fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001544  00000000  00000000  0002bf24  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002570  00000000  00000000  0002d468  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000071e3  00000000  00000000  0002f9d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000b10  00000000  00000000  00036bbb  2**0
                  CONTENTS, READONLY, DEBUGGING

Desmontagem da seção .text:

00000000 <__vectors>:
       0:	44 c0       	rjmp	.+136    	; 0x8a <__ctors_end>
       2:	00 00       	nop
       4:	5f c0       	rjmp	.+190    	; 0xc4 <__bad_interrupt>
       6:	00 00       	nop
       8:	5d c0       	rjmp	.+186    	; 0xc4 <__bad_interrupt>
       a:	00 00       	nop
       c:	5b c0       	rjmp	.+182    	; 0xc4 <__bad_interrupt>
       e:	00 00       	nop
      10:	59 c0       	rjmp	.+178    	; 0xc4 <__bad_interrupt>
      12:	00 00       	nop
      14:	57 c0       	rjmp	.+174    	; 0xc4 <__bad_interrupt>
      16:	00 00       	nop
      18:	55 c0       	rjmp	.+170    	; 0xc4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	53 c0       	rjmp	.+166    	; 0xc4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	51 c0       	rjmp	.+162    	; 0xc4 <__bad_interrupt>
      22:	00 00       	nop
      24:	4f c0       	rjmp	.+158    	; 0xc4 <__bad_interrupt>
      26:	00 00       	nop
      28:	4d c0       	rjmp	.+154    	; 0xc4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4b c0       	rjmp	.+150    	; 0xc4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	49 c0       	rjmp	.+146    	; 0xc4 <__bad_interrupt>
      32:	00 00       	nop
      34:	47 c0       	rjmp	.+142    	; 0xc4 <__bad_interrupt>
      36:	00 00       	nop
      38:	6d c3       	rjmp	.+1754   	; 0x714 <__vector_14>
      3a:	00 00       	nop
      3c:	43 c0       	rjmp	.+134    	; 0xc4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	41 c0       	rjmp	.+130    	; 0xc4 <__bad_interrupt>
      42:	00 00       	nop
      44:	3f c0       	rjmp	.+126    	; 0xc4 <__bad_interrupt>
      46:	00 00       	nop
      48:	a0 c3       	rjmp	.+1856   	; 0x78a <__vector_18>
      4a:	00 00       	nop
      4c:	dc c3       	rjmp	.+1976   	; 0x806 <__vector_19>
      4e:	00 00       	nop
      50:	39 c0       	rjmp	.+114    	; 0xc4 <__bad_interrupt>
      52:	00 00       	nop
      54:	37 c0       	rjmp	.+110    	; 0xc4 <__bad_interrupt>
      56:	00 00       	nop
      58:	35 c0       	rjmp	.+106    	; 0xc4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	33 c0       	rjmp	.+102    	; 0xc4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	31 c0       	rjmp	.+98     	; 0xc4 <__bad_interrupt>
      62:	00 00       	nop
      64:	2f c0       	rjmp	.+94     	; 0xc4 <__bad_interrupt>
	...

00000068 <__trampolines_end>:
      68:	45 46       	sbci	r20, 0x65	; 101
      6a:	47 65       	ori	r20, 0x57	; 87
      6c:	66 67       	ori	r22, 0x76	; 118
	...

0000006f <__c.2210>:
      6f:	20 2b 2d 2e 30 31 32 33 34 35 36 37 38 39 68 00      +-.0123456789h.

0000007f <__c.2345>:
      7f:	63 64 69 6e 6f 70 73 75 78 58 00                    cdinopsuxX.

0000008a <__ctors_end>:
      8a:	11 24       	eor	r1, r1
      8c:	1f be       	out	0x3f, r1	; 63
      8e:	cf ef       	ldi	r28, 0xFF	; 255
      90:	d8 e0       	ldi	r29, 0x08	; 8
      92:	de bf       	out	0x3e, r29	; 62
      94:	cd bf       	out	0x3d, r28	; 61

00000096 <__do_copy_data>:
      96:	11 e0       	ldi	r17, 0x01	; 1
      98:	a0 e0       	ldi	r26, 0x00	; 0
      9a:	b1 e0       	ldi	r27, 0x01	; 1
      9c:	ee e2       	ldi	r30, 0x2E	; 46
      9e:	f7 e2       	ldi	r31, 0x27	; 39
      a0:	02 c0       	rjmp	.+4      	; 0xa6 <__do_copy_data+0x10>
      a2:	05 90       	lpm	r0, Z+
      a4:	0d 92       	st	X+, r0
      a6:	a0 39       	cpi	r26, 0x90	; 144
      a8:	b1 07       	cpc	r27, r17
      aa:	d9 f7       	brne	.-10     	; 0xa2 <__do_copy_data+0xc>

000000ac <__do_clear_bss>:
      ac:	26 e0       	ldi	r18, 0x06	; 6
      ae:	a0 e9       	ldi	r26, 0x90	; 144
      b0:	b1 e0       	ldi	r27, 0x01	; 1
      b2:	01 c0       	rjmp	.+2      	; 0xb6 <.do_clear_bss_start>

000000b4 <.do_clear_bss_loop>:
      b4:	1d 92       	st	X+, r1

000000b6 <.do_clear_bss_start>:
      b6:	a2 3f       	cpi	r26, 0xF2	; 242
      b8:	b2 07       	cpc	r27, r18
      ba:	e1 f7       	brne	.-8      	; 0xb4 <.do_clear_bss_loop>
      bc:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <main>
      c0:	0c 94 95 13 	jmp	0x272a	; 0x272a <_exit>

000000c4 <__bad_interrupt>:
      c4:	9d cf       	rjmp	.-198    	; 0x0 <__vectors>

000000c6 <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
      c6:	f3 d2       	rcall	.+1510   	; 0x6ae <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
#else
  palInit(&pal_default_config);
      c8:	87 e1       	ldi	r24, 0x17	; 23
      ca:	91 e0       	ldi	r25, 0x01	; 1
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
      cc:	f1 d2       	rcall	.+1506   	; 0x6b0 <_pal_lld_init>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
      ce:	74 d2       	rcall	.+1256   	; 0x5b8 <sdInit>
      d0:	ea d2       	rcall	.+1492   	; 0x6a6 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
      d2:	00 c0       	rjmp	.+0      	; 0xd4 <stInit>

000000d4 <stInit>:

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
      d4:	4a c3       	rjmp	.+1684   	; 0x76a <st_lld_init>

000000d6 <iq_read>:
  if ((wr > (size_t)0) && (nfy != NULL)) {
    nfy(oqp);
  }

  return wr;
}
      d6:	af 92       	push	r10
      d8:	bf 92       	push	r11
      da:	cf 92       	push	r12
      dc:	df 92       	push	r13
      de:	ef 92       	push	r14
      e0:	ff 92       	push	r15
      e2:	0f 93       	push	r16
      e4:	1f 93       	push	r17
      e6:	cf 93       	push	r28
      e8:	df 93       	push	r29
      ea:	ec 01       	movw	r28, r24
      ec:	6b 01       	movw	r12, r22
      ee:	8a 01       	movw	r16, r20
      f0:	8c 81       	ldd	r24, Y+4	; 0x04
      f2:	9d 81       	ldd	r25, Y+5	; 0x05
      f4:	84 17       	cp	r24, r20
      f6:	95 07       	cpc	r25, r21
      f8:	10 f4       	brcc	.+4      	; 0xfe <iq_read+0x28>
      fa:	0c 81       	ldd	r16, Y+4	; 0x04
      fc:	1d 81       	ldd	r17, Y+5	; 0x05
      fe:	6c 85       	ldd	r22, Y+12	; 0x0c
     100:	7d 85       	ldd	r23, Y+13	; 0x0d
     102:	e8 84       	ldd	r14, Y+8	; 0x08
     104:	f9 84       	ldd	r15, Y+9	; 0x09
     106:	e6 1a       	sub	r14, r22
     108:	f7 0a       	sbc	r15, r23
     10a:	0e 15       	cp	r16, r14
     10c:	1f 05       	cpc	r17, r15
     10e:	98 f1       	brcs	.+102    	; 0x176 <iq_read+0xa0>
     110:	e0 16       	cp	r14, r16
     112:	f1 06       	cpc	r15, r17
     114:	d0 f0       	brcs	.+52     	; 0x14a <iq_read+0x74>
     116:	a8 01       	movw	r20, r16
     118:	c6 01       	movw	r24, r12
     11a:	0e 94 a7 12 	call	0x254e	; 0x254e <memcpy>
     11e:	8e 81       	ldd	r24, Y+6	; 0x06
     120:	9f 81       	ldd	r25, Y+7	; 0x07
     122:	9d 87       	std	Y+13, r25	; 0x0d
     124:	8c 87       	std	Y+12, r24	; 0x0c
     126:	8c 81       	ldd	r24, Y+4	; 0x04
     128:	9d 81       	ldd	r25, Y+5	; 0x05
     12a:	80 1b       	sub	r24, r16
     12c:	91 0b       	sbc	r25, r17
     12e:	9d 83       	std	Y+5, r25	; 0x05
     130:	8c 83       	std	Y+4, r24	; 0x04
     132:	c8 01       	movw	r24, r16
     134:	df 91       	pop	r29
     136:	cf 91       	pop	r28
     138:	1f 91       	pop	r17
     13a:	0f 91       	pop	r16
     13c:	ff 90       	pop	r15
     13e:	ef 90       	pop	r14
     140:	df 90       	pop	r13
     142:	cf 90       	pop	r12
     144:	bf 90       	pop	r11
     146:	af 90       	pop	r10
     148:	08 95       	ret
     14a:	a7 01       	movw	r20, r14
     14c:	c6 01       	movw	r24, r12
     14e:	0e 94 a7 12 	call	0x254e	; 0x254e <memcpy>
     152:	58 01       	movw	r10, r16
     154:	ae 18       	sub	r10, r14
     156:	bf 08       	sbc	r11, r15
     158:	6e 81       	ldd	r22, Y+6	; 0x06
     15a:	7f 81       	ldd	r23, Y+7	; 0x07
     15c:	a5 01       	movw	r20, r10
     15e:	c6 01       	movw	r24, r12
     160:	8e 0d       	add	r24, r14
     162:	9f 1d       	adc	r25, r15
     164:	0e 94 a7 12 	call	0x254e	; 0x254e <memcpy>
     168:	4e 81       	ldd	r20, Y+6	; 0x06
     16a:	5f 81       	ldd	r21, Y+7	; 0x07
     16c:	4a 0d       	add	r20, r10
     16e:	5b 1d       	adc	r21, r11
     170:	5d 87       	std	Y+13, r21	; 0x0d
     172:	4c 87       	std	Y+12, r20	; 0x0c
     174:	d8 cf       	rjmp	.-80     	; 0x126 <iq_read+0x50>
     176:	a8 01       	movw	r20, r16
     178:	c6 01       	movw	r24, r12
     17a:	0e 94 a7 12 	call	0x254e	; 0x254e <memcpy>
     17e:	8c 85       	ldd	r24, Y+12	; 0x0c
     180:	9d 85       	ldd	r25, Y+13	; 0x0d
     182:	80 0f       	add	r24, r16
     184:	91 1f       	adc	r25, r17
     186:	9d 87       	std	Y+13, r25	; 0x0d
     188:	8c 87       	std	Y+12, r24	; 0x0c
     18a:	cd cf       	rjmp	.-102    	; 0x126 <iq_read+0x50>

0000018c <oq_write>:
     18c:	af 92       	push	r10
     18e:	bf 92       	push	r11
     190:	cf 92       	push	r12
     192:	df 92       	push	r13
     194:	ef 92       	push	r14
     196:	ff 92       	push	r15
     198:	0f 93       	push	r16
     19a:	1f 93       	push	r17
     19c:	cf 93       	push	r28
     19e:	df 93       	push	r29
     1a0:	ec 01       	movw	r28, r24
     1a2:	6b 01       	movw	r12, r22
     1a4:	8a 01       	movw	r16, r20
     1a6:	8c 81       	ldd	r24, Y+4	; 0x04
     1a8:	9d 81       	ldd	r25, Y+5	; 0x05
     1aa:	84 17       	cp	r24, r20
     1ac:	95 07       	cpc	r25, r21
     1ae:	10 f4       	brcc	.+4      	; 0x1b4 <oq_write+0x28>
     1b0:	0c 81       	ldd	r16, Y+4	; 0x04
     1b2:	1d 81       	ldd	r17, Y+5	; 0x05
     1b4:	8a 85       	ldd	r24, Y+10	; 0x0a
     1b6:	9b 85       	ldd	r25, Y+11	; 0x0b
     1b8:	e8 84       	ldd	r14, Y+8	; 0x08
     1ba:	f9 84       	ldd	r15, Y+9	; 0x09
     1bc:	e8 1a       	sub	r14, r24
     1be:	f9 0a       	sbc	r15, r25
     1c0:	0e 15       	cp	r16, r14
     1c2:	1f 05       	cpc	r17, r15
     1c4:	98 f1       	brcs	.+102    	; 0x22c <oq_write+0xa0>
     1c6:	e0 16       	cp	r14, r16
     1c8:	f1 06       	cpc	r15, r17
     1ca:	d0 f0       	brcs	.+52     	; 0x200 <oq_write+0x74>
     1cc:	a8 01       	movw	r20, r16
     1ce:	b6 01       	movw	r22, r12
     1d0:	0e 94 a7 12 	call	0x254e	; 0x254e <memcpy>
     1d4:	8e 81       	ldd	r24, Y+6	; 0x06
     1d6:	9f 81       	ldd	r25, Y+7	; 0x07
     1d8:	9b 87       	std	Y+11, r25	; 0x0b
     1da:	8a 87       	std	Y+10, r24	; 0x0a
     1dc:	8c 81       	ldd	r24, Y+4	; 0x04
     1de:	9d 81       	ldd	r25, Y+5	; 0x05
     1e0:	80 1b       	sub	r24, r16
     1e2:	91 0b       	sbc	r25, r17
     1e4:	9d 83       	std	Y+5, r25	; 0x05
     1e6:	8c 83       	std	Y+4, r24	; 0x04
     1e8:	c8 01       	movw	r24, r16
     1ea:	df 91       	pop	r29
     1ec:	cf 91       	pop	r28
     1ee:	1f 91       	pop	r17
     1f0:	0f 91       	pop	r16
     1f2:	ff 90       	pop	r15
     1f4:	ef 90       	pop	r14
     1f6:	df 90       	pop	r13
     1f8:	cf 90       	pop	r12
     1fa:	bf 90       	pop	r11
     1fc:	af 90       	pop	r10
     1fe:	08 95       	ret
     200:	a7 01       	movw	r20, r14
     202:	b6 01       	movw	r22, r12
     204:	0e 94 a7 12 	call	0x254e	; 0x254e <memcpy>
     208:	58 01       	movw	r10, r16
     20a:	ae 18       	sub	r10, r14
     20c:	bf 08       	sbc	r11, r15
     20e:	b6 01       	movw	r22, r12
     210:	6e 0d       	add	r22, r14
     212:	7f 1d       	adc	r23, r15
     214:	a5 01       	movw	r20, r10
     216:	8e 81       	ldd	r24, Y+6	; 0x06
     218:	9f 81       	ldd	r25, Y+7	; 0x07
     21a:	0e 94 a7 12 	call	0x254e	; 0x254e <memcpy>
     21e:	4e 81       	ldd	r20, Y+6	; 0x06
     220:	5f 81       	ldd	r21, Y+7	; 0x07
     222:	4a 0d       	add	r20, r10
     224:	5b 1d       	adc	r21, r11
     226:	5b 87       	std	Y+11, r21	; 0x0b
     228:	4a 87       	std	Y+10, r20	; 0x0a
     22a:	d8 cf       	rjmp	.-80     	; 0x1dc <oq_write+0x50>
     22c:	a8 01       	movw	r20, r16
     22e:	b6 01       	movw	r22, r12
     230:	0e 94 a7 12 	call	0x254e	; 0x254e <memcpy>
     234:	8a 85       	ldd	r24, Y+10	; 0x0a
     236:	9b 85       	ldd	r25, Y+11	; 0x0b
     238:	80 0f       	add	r24, r16
     23a:	91 1f       	adc	r25, r17
     23c:	9b 87       	std	Y+11, r25	; 0x0b
     23e:	8a 87       	std	Y+10, r24	; 0x0a
     240:	cd cf       	rjmp	.-102    	; 0x1dc <oq_write+0x50>

00000242 <iqObjectInit>:
     242:	0f 93       	push	r16
     244:	1f 93       	push	r17
     246:	fc 01       	movw	r30, r24
     248:	91 83       	std	Z+1, r25	; 0x01
     24a:	80 83       	st	Z, r24
     24c:	93 83       	std	Z+3, r25	; 0x03
     24e:	82 83       	std	Z+2, r24	; 0x02
     250:	15 82       	std	Z+5, r1	; 0x05
     252:	14 82       	std	Z+4, r1	; 0x04
     254:	77 83       	std	Z+7, r23	; 0x07
     256:	66 83       	std	Z+6, r22	; 0x06
     258:	75 87       	std	Z+13, r23	; 0x0d
     25a:	64 87       	std	Z+12, r22	; 0x0c
     25c:	73 87       	std	Z+11, r23	; 0x0b
     25e:	62 87       	std	Z+10, r22	; 0x0a
     260:	64 0f       	add	r22, r20
     262:	75 1f       	adc	r23, r21
     264:	71 87       	std	Z+9, r23	; 0x09
     266:	60 87       	std	Z+8, r22	; 0x08
     268:	37 87       	std	Z+15, r19	; 0x0f
     26a:	26 87       	std	Z+14, r18	; 0x0e
     26c:	11 8b       	std	Z+17, r17	; 0x11
     26e:	00 8b       	std	Z+16, r16	; 0x10
     270:	1f 91       	pop	r17
     272:	0f 91       	pop	r16
     274:	08 95       	ret

00000276 <iqPutI>:
     276:	fc 01       	movw	r30, r24
     278:	a2 85       	ldd	r26, Z+10	; 0x0a
     27a:	b3 85       	ldd	r27, Z+11	; 0x0b
     27c:	84 85       	ldd	r24, Z+12	; 0x0c
     27e:	95 85       	ldd	r25, Z+13	; 0x0d
     280:	a8 17       	cp	r26, r24
     282:	b9 07       	cpc	r27, r25
     284:	e1 f0       	breq	.+56     	; 0x2be <iqPutI+0x48>
     286:	84 81       	ldd	r24, Z+4	; 0x04
     288:	95 81       	ldd	r25, Z+5	; 0x05
     28a:	01 96       	adiw	r24, 0x01	; 1
     28c:	95 83       	std	Z+5, r25	; 0x05
     28e:	84 83       	std	Z+4, r24	; 0x04
     290:	cd 01       	movw	r24, r26
     292:	01 96       	adiw	r24, 0x01	; 1
     294:	93 87       	std	Z+11, r25	; 0x0b
     296:	82 87       	std	Z+10, r24	; 0x0a
     298:	6c 93       	st	X, r22
     29a:	22 85       	ldd	r18, Z+10	; 0x0a
     29c:	33 85       	ldd	r19, Z+11	; 0x0b
     29e:	80 85       	ldd	r24, Z+8	; 0x08
     2a0:	91 85       	ldd	r25, Z+9	; 0x09
     2a2:	28 17       	cp	r18, r24
     2a4:	39 07       	cpc	r19, r25
     2a6:	20 f0       	brcs	.+8      	; 0x2b0 <iqPutI+0x3a>
     2a8:	86 81       	ldd	r24, Z+6	; 0x06
     2aa:	97 81       	ldd	r25, Z+7	; 0x07
     2ac:	93 87       	std	Z+11, r25	; 0x0b
     2ae:	82 87       	std	Z+10, r24	; 0x0a
     2b0:	cf 01       	movw	r24, r30
     2b2:	70 e0       	ldi	r23, 0x00	; 0
     2b4:	60 e0       	ldi	r22, 0x00	; 0
     2b6:	2e d7       	rcall	.+3676   	; 0x1114 <chThdDequeueNextI>
     2b8:	90 e0       	ldi	r25, 0x00	; 0
     2ba:	80 e0       	ldi	r24, 0x00	; 0
     2bc:	08 95       	ret
     2be:	84 81       	ldd	r24, Z+4	; 0x04
     2c0:	95 81       	ldd	r25, Z+5	; 0x05
     2c2:	89 2b       	or	r24, r25
     2c4:	01 f3       	breq	.-64     	; 0x286 <iqPutI+0x10>
     2c6:	8f ef       	ldi	r24, 0xFF	; 255
     2c8:	9f ef       	ldi	r25, 0xFF	; 255
     2ca:	08 95       	ret

000002cc <iqGetTimeout>:
     2cc:	0f 93       	push	r16
     2ce:	1f 93       	push	r17
     2d0:	cf 93       	push	r28
     2d2:	df 93       	push	r29
     2d4:	ec 01       	movw	r28, r24
     2d6:	8b 01       	movw	r16, r22
     2d8:	f8 94       	cli
     2da:	05 c0       	rjmp	.+10     	; 0x2e6 <iqGetTimeout+0x1a>
     2dc:	b8 01       	movw	r22, r16
     2de:	ce 01       	movw	r24, r28
     2e0:	fc d6       	rcall	.+3576   	; 0x10da <chThdEnqueueTimeoutS>
     2e2:	97 fd       	sbrc	r25, 7
     2e4:	27 c0       	rjmp	.+78     	; 0x334 <iqGetTimeout+0x68>
     2e6:	8c 81       	ldd	r24, Y+4	; 0x04
     2e8:	9d 81       	ldd	r25, Y+5	; 0x05
     2ea:	89 2b       	or	r24, r25
     2ec:	b9 f3       	breq	.-18     	; 0x2dc <iqGetTimeout+0x10>
     2ee:	8c 81       	ldd	r24, Y+4	; 0x04
     2f0:	9d 81       	ldd	r25, Y+5	; 0x05
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	9d 83       	std	Y+5, r25	; 0x05
     2f6:	8c 83       	std	Y+4, r24	; 0x04
     2f8:	ec 85       	ldd	r30, Y+12	; 0x0c
     2fa:	fd 85       	ldd	r31, Y+13	; 0x0d
     2fc:	cf 01       	movw	r24, r30
     2fe:	01 96       	adiw	r24, 0x01	; 1
     300:	9d 87       	std	Y+13, r25	; 0x0d
     302:	8c 87       	std	Y+12, r24	; 0x0c
     304:	10 81       	ld	r17, Z
     306:	28 85       	ldd	r18, Y+8	; 0x08
     308:	39 85       	ldd	r19, Y+9	; 0x09
     30a:	82 17       	cp	r24, r18
     30c:	93 07       	cpc	r25, r19
     30e:	20 f0       	brcs	.+8      	; 0x318 <iqGetTimeout+0x4c>
     310:	8e 81       	ldd	r24, Y+6	; 0x06
     312:	9f 81       	ldd	r25, Y+7	; 0x07
     314:	9d 87       	std	Y+13, r25	; 0x0d
     316:	8c 87       	std	Y+12, r24	; 0x0c
     318:	ee 85       	ldd	r30, Y+14	; 0x0e
     31a:	ff 85       	ldd	r31, Y+15	; 0x0f
     31c:	30 97       	sbiw	r30, 0x00	; 0
     31e:	11 f0       	breq	.+4      	; 0x324 <iqGetTimeout+0x58>
     320:	ce 01       	movw	r24, r28
     322:	09 95       	icall
     324:	78 94       	sei
     326:	81 2f       	mov	r24, r17
     328:	90 e0       	ldi	r25, 0x00	; 0
     32a:	df 91       	pop	r29
     32c:	cf 91       	pop	r28
     32e:	1f 91       	pop	r17
     330:	0f 91       	pop	r16
     332:	08 95       	ret
     334:	78 94       	sei
     336:	df 91       	pop	r29
     338:	cf 91       	pop	r28
     33a:	1f 91       	pop	r17
     33c:	0f 91       	pop	r16
     33e:	08 95       	ret

00000340 <iqReadTimeout>:
     340:	6f 92       	push	r6
     342:	7f 92       	push	r7
     344:	8f 92       	push	r8
     346:	9f 92       	push	r9
     348:	af 92       	push	r10
     34a:	bf 92       	push	r11
     34c:	cf 92       	push	r12
     34e:	df 92       	push	r13
     350:	ef 92       	push	r14
     352:	ff 92       	push	r15
     354:	0f 93       	push	r16
     356:	1f 93       	push	r17
     358:	cf 93       	push	r28
     35a:	df 93       	push	r29
     35c:	6c 01       	movw	r12, r24
     35e:	7b 01       	movw	r14, r22
     360:	4a 01       	movw	r8, r20
     362:	39 01       	movw	r6, r18
     364:	fc 01       	movw	r30, r24
     366:	a6 84       	ldd	r10, Z+14	; 0x0e
     368:	b7 84       	ldd	r11, Z+15	; 0x0f
     36a:	f8 94       	cli
     36c:	41 15       	cp	r20, r1
     36e:	51 05       	cpc	r21, r1
     370:	b9 f0       	breq	.+46     	; 0x3a0 <iqReadTimeout+0x60>
     372:	8a 01       	movw	r16, r20
     374:	a8 01       	movw	r20, r16
     376:	b7 01       	movw	r22, r14
     378:	c6 01       	movw	r24, r12
     37a:	ad de       	rcall	.-678    	; 0xd6 <iq_read>
     37c:	ec 01       	movw	r28, r24
     37e:	89 2b       	or	r24, r25
     380:	01 f1       	breq	.+64     	; 0x3c2 <iqReadTimeout+0x82>
     382:	a1 14       	cp	r10, r1
     384:	b1 04       	cpc	r11, r1
     386:	19 f0       	breq	.+6      	; 0x38e <iqReadTimeout+0x4e>
     388:	c6 01       	movw	r24, r12
     38a:	f5 01       	movw	r30, r10
     38c:	09 95       	icall
     38e:	78 94       	sei
     390:	0c 1b       	sub	r16, r28
     392:	1d 0b       	sbc	r17, r29
     394:	ec 0e       	add	r14, r28
     396:	fd 1e       	adc	r15, r29
     398:	f8 94       	cli
     39a:	01 15       	cp	r16, r1
     39c:	11 05       	cpc	r17, r1
     39e:	51 f7       	brne	.-44     	; 0x374 <iqReadTimeout+0x34>
     3a0:	c4 01       	movw	r24, r8
     3a2:	78 94       	sei
     3a4:	df 91       	pop	r29
     3a6:	cf 91       	pop	r28
     3a8:	1f 91       	pop	r17
     3aa:	0f 91       	pop	r16
     3ac:	ff 90       	pop	r15
     3ae:	ef 90       	pop	r14
     3b0:	df 90       	pop	r13
     3b2:	cf 90       	pop	r12
     3b4:	bf 90       	pop	r11
     3b6:	af 90       	pop	r10
     3b8:	9f 90       	pop	r9
     3ba:	8f 90       	pop	r8
     3bc:	7f 90       	pop	r7
     3be:	6f 90       	pop	r6
     3c0:	08 95       	ret
     3c2:	b3 01       	movw	r22, r6
     3c4:	c6 01       	movw	r24, r12
     3c6:	89 d6       	rcall	.+3346   	; 0x10da <chThdEnqueueTimeoutS>
     3c8:	89 2b       	or	r24, r25
     3ca:	a1 f2       	breq	.-88     	; 0x374 <iqReadTimeout+0x34>
     3cc:	c4 01       	movw	r24, r8
     3ce:	80 1b       	sub	r24, r16
     3d0:	91 0b       	sbc	r25, r17
     3d2:	e7 cf       	rjmp	.-50     	; 0x3a2 <iqReadTimeout+0x62>

000003d4 <oqObjectInit>:
     3d4:	0f 93       	push	r16
     3d6:	1f 93       	push	r17
     3d8:	fc 01       	movw	r30, r24
     3da:	91 83       	std	Z+1, r25	; 0x01
     3dc:	80 83       	st	Z, r24
     3de:	93 83       	std	Z+3, r25	; 0x03
     3e0:	82 83       	std	Z+2, r24	; 0x02
     3e2:	55 83       	std	Z+5, r21	; 0x05
     3e4:	44 83       	std	Z+4, r20	; 0x04
     3e6:	77 83       	std	Z+7, r23	; 0x07
     3e8:	66 83       	std	Z+6, r22	; 0x06
     3ea:	75 87       	std	Z+13, r23	; 0x0d
     3ec:	64 87       	std	Z+12, r22	; 0x0c
     3ee:	73 87       	std	Z+11, r23	; 0x0b
     3f0:	62 87       	std	Z+10, r22	; 0x0a
     3f2:	64 0f       	add	r22, r20
     3f4:	75 1f       	adc	r23, r21
     3f6:	71 87       	std	Z+9, r23	; 0x09
     3f8:	60 87       	std	Z+8, r22	; 0x08
     3fa:	37 87       	std	Z+15, r19	; 0x0f
     3fc:	26 87       	std	Z+14, r18	; 0x0e
     3fe:	11 8b       	std	Z+17, r17	; 0x11
     400:	00 8b       	std	Z+16, r16	; 0x10
     402:	1f 91       	pop	r17
     404:	0f 91       	pop	r16
     406:	08 95       	ret

00000408 <oqPutTimeout>:
     408:	ff 92       	push	r15
     40a:	0f 93       	push	r16
     40c:	1f 93       	push	r17
     40e:	cf 93       	push	r28
     410:	df 93       	push	r29
     412:	ec 01       	movw	r28, r24
     414:	f6 2e       	mov	r15, r22
     416:	8a 01       	movw	r16, r20
     418:	f8 94       	cli
     41a:	05 c0       	rjmp	.+10     	; 0x426 <oqPutTimeout+0x1e>
     41c:	b8 01       	movw	r22, r16
     41e:	ce 01       	movw	r24, r28
     420:	5c d6       	rcall	.+3256   	; 0x10da <chThdEnqueueTimeoutS>
     422:	97 fd       	sbrc	r25, 7
     424:	2a c0       	rjmp	.+84     	; 0x47a <oqPutTimeout+0x72>
     426:	8c 81       	ldd	r24, Y+4	; 0x04
     428:	9d 81       	ldd	r25, Y+5	; 0x05
     42a:	89 2b       	or	r24, r25
     42c:	b9 f3       	breq	.-18     	; 0x41c <oqPutTimeout+0x14>
     42e:	8c 81       	ldd	r24, Y+4	; 0x04
     430:	9d 81       	ldd	r25, Y+5	; 0x05
     432:	01 97       	sbiw	r24, 0x01	; 1
     434:	9d 83       	std	Y+5, r25	; 0x05
     436:	8c 83       	std	Y+4, r24	; 0x04
     438:	ea 85       	ldd	r30, Y+10	; 0x0a
     43a:	fb 85       	ldd	r31, Y+11	; 0x0b
     43c:	cf 01       	movw	r24, r30
     43e:	01 96       	adiw	r24, 0x01	; 1
     440:	9b 87       	std	Y+11, r25	; 0x0b
     442:	8a 87       	std	Y+10, r24	; 0x0a
     444:	f0 82       	st	Z, r15
     446:	2a 85       	ldd	r18, Y+10	; 0x0a
     448:	3b 85       	ldd	r19, Y+11	; 0x0b
     44a:	88 85       	ldd	r24, Y+8	; 0x08
     44c:	99 85       	ldd	r25, Y+9	; 0x09
     44e:	28 17       	cp	r18, r24
     450:	39 07       	cpc	r19, r25
     452:	20 f0       	brcs	.+8      	; 0x45c <oqPutTimeout+0x54>
     454:	8e 81       	ldd	r24, Y+6	; 0x06
     456:	9f 81       	ldd	r25, Y+7	; 0x07
     458:	9b 87       	std	Y+11, r25	; 0x0b
     45a:	8a 87       	std	Y+10, r24	; 0x0a
     45c:	ee 85       	ldd	r30, Y+14	; 0x0e
     45e:	ff 85       	ldd	r31, Y+15	; 0x0f
     460:	30 97       	sbiw	r30, 0x00	; 0
     462:	11 f0       	breq	.+4      	; 0x468 <oqPutTimeout+0x60>
     464:	ce 01       	movw	r24, r28
     466:	09 95       	icall
     468:	78 94       	sei
     46a:	90 e0       	ldi	r25, 0x00	; 0
     46c:	80 e0       	ldi	r24, 0x00	; 0
     46e:	df 91       	pop	r29
     470:	cf 91       	pop	r28
     472:	1f 91       	pop	r17
     474:	0f 91       	pop	r16
     476:	ff 90       	pop	r15
     478:	08 95       	ret
     47a:	78 94       	sei
     47c:	df 91       	pop	r29
     47e:	cf 91       	pop	r28
     480:	1f 91       	pop	r17
     482:	0f 91       	pop	r16
     484:	ff 90       	pop	r15
     486:	08 95       	ret

00000488 <oqGetI>:
     488:	cf 93       	push	r28
     48a:	fc 01       	movw	r30, r24
     48c:	a4 85       	ldd	r26, Z+12	; 0x0c
     48e:	b5 85       	ldd	r27, Z+13	; 0x0d
     490:	82 85       	ldd	r24, Z+10	; 0x0a
     492:	93 85       	ldd	r25, Z+11	; 0x0b
     494:	8a 17       	cp	r24, r26
     496:	9b 07       	cpc	r25, r27
     498:	e1 f0       	breq	.+56     	; 0x4d2 <oqGetI+0x4a>
     49a:	84 81       	ldd	r24, Z+4	; 0x04
     49c:	95 81       	ldd	r25, Z+5	; 0x05
     49e:	01 96       	adiw	r24, 0x01	; 1
     4a0:	95 83       	std	Z+5, r25	; 0x05
     4a2:	84 83       	std	Z+4, r24	; 0x04
     4a4:	cd 01       	movw	r24, r26
     4a6:	01 96       	adiw	r24, 0x01	; 1
     4a8:	95 87       	std	Z+13, r25	; 0x0d
     4aa:	84 87       	std	Z+12, r24	; 0x0c
     4ac:	cc 91       	ld	r28, X
     4ae:	20 85       	ldd	r18, Z+8	; 0x08
     4b0:	31 85       	ldd	r19, Z+9	; 0x09
     4b2:	82 17       	cp	r24, r18
     4b4:	93 07       	cpc	r25, r19
     4b6:	40 f4       	brcc	.+16     	; 0x4c8 <oqGetI+0x40>
     4b8:	cf 01       	movw	r24, r30
     4ba:	70 e0       	ldi	r23, 0x00	; 0
     4bc:	60 e0       	ldi	r22, 0x00	; 0
     4be:	2a d6       	rcall	.+3156   	; 0x1114 <chThdDequeueNextI>
     4c0:	8c 2f       	mov	r24, r28
     4c2:	90 e0       	ldi	r25, 0x00	; 0
     4c4:	cf 91       	pop	r28
     4c6:	08 95       	ret
     4c8:	86 81       	ldd	r24, Z+6	; 0x06
     4ca:	97 81       	ldd	r25, Z+7	; 0x07
     4cc:	95 87       	std	Z+13, r25	; 0x0d
     4ce:	84 87       	std	Z+12, r24	; 0x0c
     4d0:	f3 cf       	rjmp	.-26     	; 0x4b8 <oqGetI+0x30>
     4d2:	84 81       	ldd	r24, Z+4	; 0x04
     4d4:	95 81       	ldd	r25, Z+5	; 0x05
     4d6:	89 2b       	or	r24, r25
     4d8:	01 f3       	breq	.-64     	; 0x49a <oqGetI+0x12>
     4da:	8f ef       	ldi	r24, 0xFF	; 255
     4dc:	9f ef       	ldi	r25, 0xFF	; 255
     4de:	cf 91       	pop	r28
     4e0:	08 95       	ret

000004e2 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
     4e2:	6f 92       	push	r6
     4e4:	7f 92       	push	r7
     4e6:	8f 92       	push	r8
     4e8:	9f 92       	push	r9
     4ea:	af 92       	push	r10
     4ec:	bf 92       	push	r11
     4ee:	cf 92       	push	r12
     4f0:	df 92       	push	r13
     4f2:	ef 92       	push	r14
     4f4:	ff 92       	push	r15
     4f6:	0f 93       	push	r16
     4f8:	1f 93       	push	r17
     4fa:	cf 93       	push	r28
     4fc:	df 93       	push	r29
     4fe:	6c 01       	movw	r12, r24
     500:	7b 01       	movw	r14, r22
     502:	4a 01       	movw	r8, r20
     504:	39 01       	movw	r6, r18
  qnotify_t nfy = oqp->q_notify;
     506:	fc 01       	movw	r30, r24
     508:	a6 84       	ldd	r10, Z+14	; 0x0e
     50a:	b7 84       	ldd	r11, Z+15	; 0x0f
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
     50c:	f8 94       	cli

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
     50e:	41 15       	cp	r20, r1
     510:	51 05       	cpc	r21, r1
     512:	b9 f0       	breq	.+46     	; 0x542 <oqWriteTimeout+0x60>
     514:	8a 01       	movw	r16, r20
    size_t done;

    done = oq_write(oqp, bp, n);
     516:	a8 01       	movw	r20, r16
     518:	b7 01       	movw	r22, r14
     51a:	c6 01       	movw	r24, r12
     51c:	37 de       	rcall	.-914    	; 0x18c <oq_write>
     51e:	ec 01       	movw	r28, r24
    if (done == (size_t)0) {
     520:	89 2b       	or	r24, r25
     522:	01 f1       	breq	.+64     	; 0x564 <oqWriteTimeout+0x82>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
     524:	a1 14       	cp	r10, r1
     526:	b1 04       	cpc	r11, r1
     528:	19 f0       	breq	.+6      	; 0x530 <oqWriteTimeout+0x4e>
        nfy(oqp);
     52a:	c6 01       	movw	r24, r12
     52c:	f5 01       	movw	r30, r10
     52e:	09 95       	icall
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
     530:	78 94       	sei
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
     532:	0c 1b       	sub	r16, r28
     534:	1d 0b       	sbc	r17, r29
      bp += done;
     536:	ec 0e       	add	r14, r28
     538:	fd 1e       	adc	r15, r29
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
     53a:	f8 94       	cli

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
     53c:	01 15       	cp	r16, r1
     53e:	11 05       	cpc	r17, r1
     540:	51 f7       	brne	.-44     	; 0x516 <oqWriteTimeout+0x34>
     542:	c4 01       	movw	r24, r8
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
     544:	78 94       	sei
    }
  }

  osalSysUnlock();
  return max - n;
}
     546:	df 91       	pop	r29
     548:	cf 91       	pop	r28
     54a:	1f 91       	pop	r17
     54c:	0f 91       	pop	r16
     54e:	ff 90       	pop	r15
     550:	ef 90       	pop	r14
     552:	df 90       	pop	r13
     554:	cf 90       	pop	r12
     556:	bf 90       	pop	r11
     558:	af 90       	pop	r10
     55a:	9f 90       	pop	r9
     55c:	8f 90       	pop	r8
     55e:	7f 90       	pop	r7
     560:	6f 90       	pop	r6
     562:	08 95       	ret
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {

  return chThdEnqueueTimeoutS(tqp, timeout);
     564:	b3 01       	movw	r22, r6
     566:	c6 01       	movw	r24, r12
     568:	b8 d5       	rcall	.+2928   	; 0x10da <chThdEnqueueTimeoutS>
    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
     56a:	89 2b       	or	r24, r25
     56c:	a1 f2       	breq	.-88     	; 0x516 <oqWriteTimeout+0x34>
     56e:	c4 01       	movw	r24, r8
     570:	80 1b       	sub	r24, r16
     572:	91 0b       	sbc	r25, r17
     574:	e7 cf       	rjmp	.-50     	; 0x544 <oqWriteTimeout+0x62>

00000576 <_readt>:
  oqResetI(&sdp->oqueue);
  iqResetI(&sdp->iqueue);
  osalOsRescheduleS();

  osalSysUnlock();
}
     576:	05 96       	adiw	r24, 0x05	; 5
     578:	e3 ce       	rjmp	.-570    	; 0x340 <iqReadTimeout>

0000057a <_read>:
     57a:	2f ef       	ldi	r18, 0xFF	; 255
     57c:	3f ef       	ldi	r19, 0xFF	; 255
     57e:	05 96       	adiw	r24, 0x05	; 5
     580:	df ce       	rjmp	.-578    	; 0x340 <iqReadTimeout>

00000582 <_writet>:
     582:	47 96       	adiw	r24, 0x17	; 23
     584:	ae cf       	rjmp	.-164    	; 0x4e2 <oqWriteTimeout>

00000586 <_write>:
     586:	2f ef       	ldi	r18, 0xFF	; 255
     588:	3f ef       	ldi	r19, 0xFF	; 255
     58a:	47 96       	adiw	r24, 0x17	; 23
     58c:	aa cf       	rjmp	.-172    	; 0x4e2 <oqWriteTimeout>

0000058e <_gett>:
     58e:	05 96       	adiw	r24, 0x05	; 5
     590:	9d ce       	rjmp	.-710    	; 0x2cc <iqGetTimeout>

00000592 <_get>:
     592:	6f ef       	ldi	r22, 0xFF	; 255
     594:	7f ef       	ldi	r23, 0xFF	; 255
     596:	05 96       	adiw	r24, 0x05	; 5
     598:	99 ce       	rjmp	.-718    	; 0x2cc <iqGetTimeout>

0000059a <_putt>:
     59a:	47 96       	adiw	r24, 0x17	; 23
     59c:	35 cf       	rjmp	.-406    	; 0x408 <oqPutTimeout>

0000059e <_put>:
     59e:	4f ef       	ldi	r20, 0xFF	; 255
     5a0:	5f ef       	ldi	r21, 0xFF	; 255
     5a2:	47 96       	adiw	r24, 0x17	; 23
     5a4:	31 cf       	rjmp	.-414    	; 0x408 <oqPutTimeout>

000005a6 <_ctl>:
     5a6:	61 30       	cpi	r22, 0x01	; 1
     5a8:	71 05       	cpc	r23, r1
     5aa:	19 f0       	breq	.+6      	; 0x5b2 <_ctl+0xc>
     5ac:	8c ee       	ldi	r24, 0xEC	; 236
     5ae:	9f ef       	ldi	r25, 0xFF	; 255
     5b0:	08 95       	ret
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	80 e0       	ldi	r24, 0x00	; 0
     5b6:	08 95       	ret

000005b8 <sdInit>:
     5b8:	5d c1       	rjmp	.+698    	; 0x874 <sd_lld_init>

000005ba <sdObjectInit>:
     5ba:	ef 92       	push	r14
     5bc:	ff 92       	push	r15
     5be:	0f 93       	push	r16
     5c0:	1f 93       	push	r17
     5c2:	cf 93       	push	r28
     5c4:	df 93       	push	r29
     5c6:	ec 01       	movw	r28, r24
     5c8:	9b 01       	movw	r18, r22
     5ca:	7a 01       	movw	r14, r20
     5cc:	fc 01       	movw	r30, r24
     5ce:	83 e0       	ldi	r24, 0x03	; 3
     5d0:	91 e0       	ldi	r25, 0x01	; 1
     5d2:	81 93       	st	Z+, r24
     5d4:	91 93       	st	Z+, r25
     5d6:	fb 83       	std	Y+3, r31	; 0x03
     5d8:	ea 83       	std	Y+2, r30	; 0x02
     5da:	81 e0       	ldi	r24, 0x01	; 1
     5dc:	8c 83       	std	Y+4, r24	; 0x04
     5de:	be 01       	movw	r22, r28
     5e0:	67 5d       	subi	r22, 0xD7	; 215
     5e2:	7f 4f       	sbci	r23, 0xFF	; 255
     5e4:	8e 01       	movw	r16, r28
     5e6:	40 e1       	ldi	r20, 0x10	; 16
     5e8:	50 e0       	ldi	r21, 0x00	; 0
     5ea:	ce 01       	movw	r24, r28
     5ec:	05 96       	adiw	r24, 0x05	; 5
     5ee:	29 de       	rcall	.-942    	; 0x242 <iqObjectInit>
     5f0:	be 01       	movw	r22, r28
     5f2:	67 5c       	subi	r22, 0xC7	; 199
     5f4:	7f 4f       	sbci	r23, 0xFF	; 255
     5f6:	97 01       	movw	r18, r14
     5f8:	40 e1       	ldi	r20, 0x10	; 16
     5fa:	50 e0       	ldi	r21, 0x00	; 0
     5fc:	ce 01       	movw	r24, r28
     5fe:	47 96       	adiw	r24, 0x17	; 23
     600:	e9 de       	rcall	.-558    	; 0x3d4 <oqObjectInit>
     602:	df 91       	pop	r29
     604:	cf 91       	pop	r28
     606:	1f 91       	pop	r17
     608:	0f 91       	pop	r16
     60a:	ff 90       	pop	r15
     60c:	ef 90       	pop	r14
     60e:	08 95       	ret

00000610 <sdStart>:
     610:	cf 93       	push	r28
     612:	df 93       	push	r29
     614:	ec 01       	movw	r28, r24
     616:	f8 94       	cli
     618:	34 d1       	rcall	.+616    	; 0x882 <sd_lld_start>
     61a:	82 e0       	ldi	r24, 0x02	; 2
     61c:	8c 83       	std	Y+4, r24	; 0x04
     61e:	78 94       	sei
     620:	90 e0       	ldi	r25, 0x00	; 0
     622:	80 e0       	ldi	r24, 0x00	; 0
     624:	df 91       	pop	r29
     626:	cf 91       	pop	r28
     628:	08 95       	ret

0000062a <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
     62a:	1f 93       	push	r17
     62c:	cf 93       	push	r28
     62e:	df 93       	push	r29
     630:	ec 01       	movw	r28, r24
     632:	16 2f       	mov	r17, r22

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
     634:	89 85       	ldd	r24, Y+9	; 0x09
     636:	9a 85       	ldd	r25, Y+10	; 0x0a
     638:	89 2b       	or	r24, r25
     63a:	51 f0       	breq	.+20     	; 0x650 <sdIncomingDataI+0x26>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
     63c:	61 2f       	mov	r22, r17
     63e:	ce 01       	movw	r24, r28
     640:	05 96       	adiw	r24, 0x05	; 5
     642:	19 de       	rcall	.-974    	; 0x276 <iqPutI>
     644:	97 fd       	sbrc	r25, 7
     646:	0e c0       	rjmp	.+28     	; 0x664 <sdIncomingDataI+0x3a>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
     648:	df 91       	pop	r29
     64a:	cf 91       	pop	r28
     64c:	1f 91       	pop	r17
     64e:	08 95       	ret
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
     650:	64 e0       	ldi	r22, 0x04	; 4
     652:	ce 01       	movw	r24, r28
     654:	02 96       	adiw	r24, 0x02	; 2
     656:	67 d7       	rcall	.+3790   	; 0x1526 <chEvtBroadcastFlagsI>
  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
     658:	61 2f       	mov	r22, r17
     65a:	ce 01       	movw	r24, r28
     65c:	05 96       	adiw	r24, 0x05	; 5
     65e:	0b de       	rcall	.-1002   	; 0x276 <iqPutI>
     660:	97 ff       	sbrs	r25, 7
     662:	f2 cf       	rjmp	.-28     	; 0x648 <sdIncomingDataI+0x1e>
     664:	60 e0       	ldi	r22, 0x00	; 0
     666:	ce 01       	movw	r24, r28
     668:	02 96       	adiw	r24, 0x02	; 2
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
     66a:	df 91       	pop	r29
     66c:	cf 91       	pop	r28
     66e:	1f 91       	pop	r17
     670:	5a c7       	rjmp	.+3764   	; 0x1526 <chEvtBroadcastFlagsI>

00000672 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
     672:	0f 93       	push	r16
     674:	1f 93       	push	r17
     676:	cf 93       	push	r28
     678:	df 93       	push	r29
     67a:	8c 01       	movw	r16, r24
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
     67c:	47 96       	adiw	r24, 0x17	; 23
     67e:	04 df       	rcall	.-504    	; 0x488 <oqGetI>
     680:	ec 01       	movw	r28, r24
  if (b < MSG_OK)
     682:	97 fd       	sbrc	r25, 7
     684:	06 c0       	rjmp	.+12     	; 0x692 <sdRequestDataI+0x20>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
  return b;
}
     686:	ce 01       	movw	r24, r28
     688:	df 91       	pop	r29
     68a:	cf 91       	pop	r28
     68c:	1f 91       	pop	r17
     68e:	0f 91       	pop	r16
     690:	08 95       	ret
     692:	68 e0       	ldi	r22, 0x08	; 8
     694:	c8 01       	movw	r24, r16
     696:	02 96       	adiw	r24, 0x02	; 2
     698:	46 d7       	rcall	.+3724   	; 0x1526 <chEvtBroadcastFlagsI>
     69a:	ce 01       	movw	r24, r28
     69c:	df 91       	pop	r29
     69e:	cf 91       	pop	r28
     6a0:	1f 91       	pop	r17
     6a2:	0f 91       	pop	r16
     6a4:	08 95       	ret

000006a6 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  EICRA  = 0x00;
     6a6:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <__TEXT_REGION_LENGTH__+0x7f8069>
  EIMSK  = 0x00;
     6aa:	1d ba       	out	0x1d, r1	; 29

}
     6ac:	08 95       	ret

000006ae <hal_lld_init>:
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
}
     6ae:	08 95       	ret

000006b0 <_pal_lld_init>:
 *
 * @param[in] config    the AVR ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
     6b0:	fc 01       	movw	r30, r24
  PORTA = config->porta.out;
  DDRA = config->porta.dir;
#endif

#if defined(PORTB) || defined(__DOXYGEN__)
  PORTB = config->portb.out;
     6b2:	80 81       	ld	r24, Z
     6b4:	85 b9       	out	0x05, r24	; 5
  DDRB = config->portb.dir;
     6b6:	81 81       	ldd	r24, Z+1	; 0x01
     6b8:	84 b9       	out	0x04, r24	; 4
#endif

#if defined(PORTC) || defined(__DOXYGEN__)
  PORTC = config->portc.out;
     6ba:	82 81       	ldd	r24, Z+2	; 0x02
     6bc:	88 b9       	out	0x08, r24	; 8
  DDRC = config->portc.dir;
     6be:	83 81       	ldd	r24, Z+3	; 0x03
     6c0:	87 b9       	out	0x07, r24	; 7
#endif

#if defined(PORTD) || defined(__DOXYGEN__)
  PORTD = config->portd.out;
     6c2:	84 81       	ldd	r24, Z+4	; 0x04
     6c4:	8b b9       	out	0x0b, r24	; 11
  DDRD = config->portd.dir;
     6c6:	85 81       	ldd	r24, Z+5	; 0x05
     6c8:	8a b9       	out	0x0a, r24	; 10

#if defined(PORTL) || defined(__DOXYGEN__)
  PORTL = config->portl.out;
  DDRL = config->portl.dir;
#endif
}
     6ca:	08 95       	ret

000006cc <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
     6cc:	fc 01       	movw	r30, r24

  switch (mode) {
     6ce:	42 30       	cpi	r20, 0x02	; 2
     6d0:	c9 f0       	breq	.+50     	; 0x704 <_pal_lld_setgroupmode+0x38>
     6d2:	98 f0       	brcs	.+38     	; 0x6fa <_pal_lld_setgroupmode+0x2e>
     6d4:	45 30       	cpi	r20, 0x05	; 5
     6d6:	b1 f0       	breq	.+44     	; 0x704 <_pal_lld_setgroupmode+0x38>
     6d8:	46 30       	cpi	r20, 0x06	; 6
     6da:	21 f4       	brne	.+8      	; 0x6e4 <_pal_lld_setgroupmode+0x18>
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
    port->out |= mask;
    break;
  case PAL_MODE_OUTPUT_PUSHPULL:
    port->dir |= mask;
     6dc:	81 81       	ldd	r24, Z+1	; 0x01
     6de:	68 2b       	or	r22, r24
     6e0:	61 83       	std	Z+1, r22	; 0x01
    break;
  }
}
     6e2:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
     6e4:	43 30       	cpi	r20, 0x03	; 3
     6e6:	e9 f7       	brne	.-6      	; 0x6e2 <_pal_lld_setgroupmode+0x16>
    port->dir &= ~mask;
    port->out &= ~mask;
    break;
  case PAL_MODE_UNCONNECTED:
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
     6e8:	91 81       	ldd	r25, Z+1	; 0x01
     6ea:	86 2f       	mov	r24, r22
     6ec:	80 95       	com	r24
     6ee:	89 23       	and	r24, r25
     6f0:	81 83       	std	Z+1, r24	; 0x01
    port->out |= mask;
     6f2:	82 81       	ldd	r24, Z+2	; 0x02
     6f4:	68 2b       	or	r22, r24
     6f6:	62 83       	std	Z+2, r22	; 0x02
    break;
     6f8:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
     6fa:	44 23       	and	r20, r20
     6fc:	19 f0       	breq	.+6      	; 0x704 <_pal_lld_setgroupmode+0x38>
     6fe:	41 30       	cpi	r20, 0x01	; 1
     700:	99 f3       	breq	.-26     	; 0x6e8 <_pal_lld_setgroupmode+0x1c>
     702:	08 95       	ret
  case PAL_MODE_RESET:
  case PAL_MODE_INPUT:
  case PAL_MODE_INPUT_ANALOG:
    port->dir &= ~mask;
     704:	81 81       	ldd	r24, Z+1	; 0x01
     706:	60 95       	com	r22
     708:	86 23       	and	r24, r22
     70a:	81 83       	std	Z+1, r24	; 0x01
    port->out &= ~mask;
     70c:	82 81       	ldd	r24, Z+2	; 0x02
     70e:	68 23       	and	r22, r24
     710:	62 83       	std	Z+2, r22	; 0x02
    break;
     712:	08 95       	ret

00000714 <__vector_14>:
#if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined(__DOXYGEN__)

/**
 * @brief Timer handler for periodic mode.
 */
OSAL_IRQ_HANDLER(AVR_TIMER_VECT) {
     714:	1f 92       	push	r1
     716:	0f 92       	push	r0
     718:	0f b6       	in	r0, 0x3f	; 63
     71a:	0f 92       	push	r0
     71c:	11 24       	eor	r1, r1
     71e:	2f 93       	push	r18
     720:	3f 93       	push	r19
     722:	4f 93       	push	r20
     724:	5f 93       	push	r21
     726:	6f 93       	push	r22
     728:	7f 93       	push	r23
     72a:	8f 93       	push	r24
     72c:	9f 93       	push	r25
     72e:	af 93       	push	r26
     730:	bf 93       	push	r27
     732:	ef 93       	push	r30
     734:	ff 93       	push	r31

  OSAL_IRQ_PROLOGUE();
     736:	81 e0       	ldi	r24, 0x01	; 1
     738:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <__avr_in_isr>
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
     73c:	f3 d0       	rcall	.+486    	; 0x924 <chSysTimerHandlerI>

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
     73e:	10 92 f1 06 	sts	0x06F1, r1	; 0x8006f1 <__avr_in_isr>
     742:	de d2       	rcall	.+1468   	; 0xd00 <chSchIsPreemptionRequired>
     744:	81 11       	cpse	r24, r1
     746:	ec d2       	rcall	.+1496   	; 0xd20 <chSchDoPreemption>
}
     748:	ff 91       	pop	r31
     74a:	ef 91       	pop	r30
     74c:	bf 91       	pop	r27
     74e:	af 91       	pop	r26
     750:	9f 91       	pop	r25
     752:	8f 91       	pop	r24
     754:	7f 91       	pop	r23
     756:	6f 91       	pop	r22
     758:	5f 91       	pop	r21
     75a:	4f 91       	pop	r20
     75c:	3f 91       	pop	r19
     75e:	2f 91       	pop	r18
     760:	0f 90       	pop	r0
     762:	0f be       	out	0x3f, r0	; 63
     764:	0f 90       	pop	r0
     766:	1f 90       	pop	r1
     768:	18 95       	reti

0000076a <st_lld_init>:

  /*
   * Periodic mode uses Timer 0 (8 bit).
   */
#if defined(TCCR0B) /* Timer has multiple output comparators.               */
  TCCR0A  = (1 << WGM01) | (0 << WGM00) |                /* CTC mode.       */
     76a:	82 e0       	ldi	r24, 0x02	; 2
     76c:	84 bd       	out	0x24, r24	; 36
            (0 << COM0A1) | (0 << COM0A0) |              /* OC0A disabled.  */
            (0 << COM0B1) | (0 << COM0B0);               /* OC0B disabled.  */
  TCCR0B  = (0 << WGM02) | AVR_TIMER_PRESCALER_BITS;     /* CTC mode.       */
     76e:	85 bd       	out	0x25, r24	; 37
  OCR0A   = AVR_TIMER_COUNTER - 1;
     770:	9f e7       	ldi	r25, 0x7F	; 127
     772:	97 bd       	out	0x27, r25	; 39
  TCNT0   = 0;                                           /* Reset counter.  */
     774:	16 bc       	out	0x26, r1	; 38
  TIFR0   = (1 << OCF0A);                                /* Reset pending.  */
     776:	85 bb       	out	0x15, r24	; 21
  TIMSK0  = (1 << OCIE0A);                               /* IRQ on compare. */
     778:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7f806e>
#else
  #error "Neither TCCR0A nor TCCR0 registers are defined"
#endif

#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
     77c:	08 95       	ret

0000077e <notify1>:

#if AVR_SERIAL_USE_USART0 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  UCSR0B |= (1 << UDRIE0);
     77e:	e1 ec       	ldi	r30, 0xC1	; 193
     780:	f0 e0       	ldi	r31, 0x00	; 0
     782:	80 81       	ld	r24, Z
     784:	80 62       	ori	r24, 0x20	; 32
     786:	80 83       	st	Z, r24
}
     788:	08 95       	ret

0000078a <__vector_18>:
/**
 * @brief   USART0 RX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_RX_VECT) {
     78a:	1f 92       	push	r1
     78c:	0f 92       	push	r0
     78e:	0f b6       	in	r0, 0x3f	; 63
     790:	0f 92       	push	r0
     792:	11 24       	eor	r1, r1
     794:	2f 93       	push	r18
     796:	3f 93       	push	r19
     798:	4f 93       	push	r20
     79a:	5f 93       	push	r21
     79c:	6f 93       	push	r22
     79e:	7f 93       	push	r23
     7a0:	8f 93       	push	r24
     7a2:	9f 93       	push	r25
     7a4:	af 93       	push	r26
     7a6:	bf 93       	push	r27
     7a8:	ef 93       	push	r30
     7aa:	ff 93       	push	r31
  uint8_t sra;

  OSAL_IRQ_PROLOGUE();
     7ac:	81 e0       	ldi	r24, 0x01	; 1
     7ae:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <__avr_in_isr>

  sra = UCSR0A;
     7b2:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
     7b6:	98 2f       	mov	r25, r24
     7b8:	9c 71       	andi	r25, 0x1C	; 28
     7ba:	41 f0       	breq	.+16     	; 0x7cc <__vector_18+0x42>
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    sts |= SD_PARITY_ERROR;
     7bc:	60 e2       	ldi	r22, 0x20	; 32
  }
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
     7be:	82 ff       	sbrs	r24, 2
     7c0:	60 e0       	ldi	r22, 0x00	; 0
    sts |= SD_PARITY_ERROR;
  if (sra & fe)
     7c2:	84 fd       	sbrc	r24, 4
     7c4:	1e c0       	rjmp	.+60     	; 0x802 <__DATA_REGION_LENGTH__+0x2>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
     7c6:	80 e6       	ldi	r24, 0x60	; 96
     7c8:	96 e0       	ldi	r25, 0x06	; 6
     7ca:	ad d6       	rcall	.+3418   	; 0x1526 <chEvtBroadcastFlagsI>

  sra = UCSR0A;
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
    set_error(sra, &SD1);
  osalSysLockFromISR();
  sdIncomingDataI(&SD1, UDR0);
     7cc:	60 91 c6 00 	lds	r22, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
     7d0:	8e e5       	ldi	r24, 0x5E	; 94
     7d2:	96 e0       	ldi	r25, 0x06	; 6
     7d4:	2a df       	rcall	.-428    	; 0x62a <sdIncomingDataI>
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
     7d6:	10 92 f1 06 	sts	0x06F1, r1	; 0x8006f1 <__avr_in_isr>
     7da:	92 d2       	rcall	.+1316   	; 0xd00 <chSchIsPreemptionRequired>
     7dc:	81 11       	cpse	r24, r1
     7de:	a0 d2       	rcall	.+1344   	; 0xd20 <chSchDoPreemption>
}
     7e0:	ff 91       	pop	r31
     7e2:	ef 91       	pop	r30
     7e4:	bf 91       	pop	r27
     7e6:	af 91       	pop	r26
     7e8:	9f 91       	pop	r25
     7ea:	8f 91       	pop	r24
     7ec:	7f 91       	pop	r23
     7ee:	6f 91       	pop	r22
     7f0:	5f 91       	pop	r21
     7f2:	4f 91       	pop	r20
     7f4:	3f 91       	pop	r19
     7f6:	2f 91       	pop	r18
     7f8:	0f 90       	pop	r0
     7fa:	0f be       	out	0x3f, r0	; 63
     7fc:	0f 90       	pop	r0
     7fe:	1f 90       	pop	r1
     800:	18 95       	reti
  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    sts |= SD_PARITY_ERROR;
  if (sra & fe)
    sts |= SD_FRAMING_ERROR;
     802:	60 64       	ori	r22, 0x40	; 64
     804:	e0 cf       	rjmp	.-64     	; 0x7c6 <__vector_18+0x3c>

00000806 <__vector_19>:
/**
 * @brief   USART0 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_TX_VECT) {
     806:	1f 92       	push	r1
     808:	0f 92       	push	r0
     80a:	0f b6       	in	r0, 0x3f	; 63
     80c:	0f 92       	push	r0
     80e:	11 24       	eor	r1, r1
     810:	2f 93       	push	r18
     812:	3f 93       	push	r19
     814:	4f 93       	push	r20
     816:	5f 93       	push	r21
     818:	6f 93       	push	r22
     81a:	7f 93       	push	r23
     81c:	8f 93       	push	r24
     81e:	9f 93       	push	r25
     820:	af 93       	push	r26
     822:	bf 93       	push	r27
     824:	ef 93       	push	r30
     826:	ff 93       	push	r31
  msg_t b;

  OSAL_IRQ_PROLOGUE();
     828:	81 e0       	ldi	r24, 0x01	; 1
     82a:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <__avr_in_isr>

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
     82e:	8e e5       	ldi	r24, 0x5E	; 94
     830:	96 e0       	ldi	r25, 0x06	; 6
     832:	1f df       	rcall	.-450    	; 0x672 <sdRequestDataI>
  osalSysUnlockFromISR();
  if (b < MSG_OK)
     834:	97 fd       	sbrc	r25, 7
     836:	18 c0       	rjmp	.+48     	; 0x868 <__vector_19+0x62>
    UCSR0B &= ~(1 << UDRIE0);
  else
    UDR0 = b;
     838:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>

  OSAL_IRQ_EPILOGUE();
     83c:	10 92 f1 06 	sts	0x06F1, r1	; 0x8006f1 <__avr_in_isr>
     840:	5f d2       	rcall	.+1214   	; 0xd00 <chSchIsPreemptionRequired>
     842:	81 11       	cpse	r24, r1
     844:	6d d2       	rcall	.+1242   	; 0xd20 <chSchDoPreemption>
}
     846:	ff 91       	pop	r31
     848:	ef 91       	pop	r30
     84a:	bf 91       	pop	r27
     84c:	af 91       	pop	r26
     84e:	9f 91       	pop	r25
     850:	8f 91       	pop	r24
     852:	7f 91       	pop	r23
     854:	6f 91       	pop	r22
     856:	5f 91       	pop	r21
     858:	4f 91       	pop	r20
     85a:	3f 91       	pop	r19
     85c:	2f 91       	pop	r18
     85e:	0f 90       	pop	r0
     860:	0f be       	out	0x3f, r0	; 63
     862:	0f 90       	pop	r0
     864:	1f 90       	pop	r1
     866:	18 95       	reti

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
  osalSysUnlockFromISR();
  if (b < MSG_OK)
    UCSR0B &= ~(1 << UDRIE0);
     868:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     86c:	8f 7d       	andi	r24, 0xDF	; 223
     86e:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     872:	e4 cf       	rjmp	.-56     	; 0x83c <__vector_19+0x36>

00000874 <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if AVR_SERIAL_USE_USART0
  sdObjectInit(&SD1, NULL, notify1);
     874:	4f eb       	ldi	r20, 0xBF	; 191
     876:	53 e0       	ldi	r21, 0x03	; 3
     878:	70 e0       	ldi	r23, 0x00	; 0
     87a:	60 e0       	ldi	r22, 0x00	; 0
     87c:	8e e5       	ldi	r24, 0x5E	; 94
     87e:	96 e0       	ldi	r25, 0x06	; 6
     880:	9c ce       	rjmp	.-712    	; 0x5ba <sdObjectInit>

00000882 <sd_lld_start>:
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
     882:	61 15       	cp	r22, r1
     884:	71 05       	cpc	r23, r1
     886:	21 f0       	breq	.+8      	; 0x890 <sd_lld_start+0xe>
    config = &default_config;

#if AVR_SERIAL_USE_USART0
  if (&SD1 == sdp) {
     888:	8e 55       	subi	r24, 0x5E	; 94
     88a:	96 40       	sbci	r25, 0x06	; 6
     88c:	89 f0       	breq	.+34     	; 0x8b0 <sd_lld_start+0x2e>
  if (&SD2 == sdp) {
    usart1_init(config);
    return;
  }
#endif
}
     88e:	08 95       	ret

  if (config == NULL)
    config = &default_config;

#if AVR_SERIAL_USE_USART0
  if (&SD1 == sdp) {
     890:	8e 55       	subi	r24, 0x5E	; 94
     892:	96 40       	sbci	r25, 0x06	; 6
     894:	e1 f7       	brne	.-8      	; 0x88e <sd_lld_start+0xc>
 */
static void usart0_init(const SerialConfig *config) {

  uint8_t ucsr0c;

  UBRR0L = config->sc_brr;
     896:	83 e3       	ldi	r24, 0x33	; 51
     898:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
  UBRR0H = (config->sc_brr >> 8) & 0x0f;
     89c:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
  UCSR0A = (1 << U2X0);
     8a0:	82 e0       	ldi	r24, 0x02	; 2
     8a2:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
     8a6:	88 e9       	ldi	r24, 0x98	; 152
     8a8:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
    UCSR0B |= (1 << UCSZ02);
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_8:
  default:
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
     8ac:	86 e0       	ldi	r24, 0x06	; 6
     8ae:	1c c0       	rjmp	.+56     	; 0x8e8 <sd_lld_start+0x66>
 */
static void usart0_init(const SerialConfig *config) {

  uint8_t ucsr0c;

  UBRR0L = config->sc_brr;
     8b0:	fb 01       	movw	r30, r22
     8b2:	80 81       	ld	r24, Z
     8b4:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
  UBRR0H = (config->sc_brr >> 8) & 0x0f;
     8b8:	81 81       	ldd	r24, Z+1	; 0x01
     8ba:	8f 70       	andi	r24, 0x0F	; 15
     8bc:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
  UCSR0A = (1 << U2X0);
     8c0:	82 e0       	ldi	r24, 0x02	; 2
     8c2:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
     8c6:	88 e9       	ldi	r24, 0x98	; 152
     8c8:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
  switch (config->sc_bits_per_char) {
     8cc:	82 81       	ldd	r24, Z+2	; 0x02
     8ce:	81 30       	cpi	r24, 0x01	; 1
     8d0:	91 f0       	breq	.+36     	; 0x8f6 <sd_lld_start+0x74>
     8d2:	78 f0       	brcs	.+30     	; 0x8f2 <sd_lld_start+0x70>
     8d4:	82 30       	cpi	r24, 0x02	; 2
     8d6:	59 f0       	breq	.+22     	; 0x8ee <sd_lld_start+0x6c>
     8d8:	84 30       	cpi	r24, 0x04	; 4
     8da:	41 f7       	brne	.-48     	; 0x8ac <sd_lld_start+0x2a>
    break;
  case USART_CHAR_SIZE_7:
    ucsr0c = (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_9:
    UCSR0B |= (1 << UCSZ02);
     8dc:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     8e0:	84 60       	ori	r24, 0x04	; 4
     8e2:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
     8e6:	86 e0       	ldi	r24, 0x06	; 6
  }

#if defined(__AVR_ATmega162__)
  UCSR0C = (1 << URSEL0) | ucsr0c;
#else
  UCSR0C = ucsr0c;
     8e8:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
     8ec:	08 95       	ret
    break;
  case USART_CHAR_SIZE_6:
    ucsr0c = (1 << UCSZ00);
    break;
  case USART_CHAR_SIZE_7:
    ucsr0c = (1 << UCSZ01);
     8ee:	84 e0       	ldi	r24, 0x04	; 4
     8f0:	fb cf       	rjmp	.-10     	; 0x8e8 <sd_lld_start+0x66>
  UBRR0H = (config->sc_brr >> 8) & 0x0f;
  UCSR0A = (1 << U2X0);
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
  switch (config->sc_bits_per_char) {
  case USART_CHAR_SIZE_5:
    ucsr0c = 0;
     8f2:	80 e0       	ldi	r24, 0x00	; 0
     8f4:	f9 cf       	rjmp	.-14     	; 0x8e8 <sd_lld_start+0x66>
    break;
  case USART_CHAR_SIZE_6:
    ucsr0c = (1 << UCSZ00);
     8f6:	82 e0       	ldi	r24, 0x02	; 2
     8f8:	f7 cf       	rjmp	.-18     	; 0x8e8 <sd_lld_start+0x66>

000008fa <chSysInit>:
  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    ch_delta_list_t *dlp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
     8fa:	cf 93       	push	r28
     8fc:	df 93       	push	r29
     8fe:	c7 ea       	ldi	r28, 0xA7	; 167
     900:	d6 e0       	ldi	r29, 0x06	; 6
     902:	81 e0       	ldi	r24, 0x01	; 1
     904:	88 83       	st	Y, r24
     906:	1a 82       	std	Y+2, r1	; 0x02
     908:	19 82       	std	Y+1, r1	; 0x01
     90a:	32 d6       	rcall	.+3172   	; 0x1570 <__core_init>
     90c:	61 d6       	rcall	.+3266   	; 0x15d0 <__heap_init>
     90e:	60 e2       	ldi	r22, 0x20	; 32
     910:	71 e0       	ldi	r23, 0x01	; 1
     912:	8a ea       	ldi	r24, 0xAA	; 170
     914:	96 e0       	ldi	r25, 0x06	; 6
     916:	53 d2       	rcall	.+1190   	; 0xdbe <chInstanceObjectInit>
     918:	82 e0       	ldi	r24, 0x02	; 2
     91a:	88 83       	st	Y, r24
     91c:	78 94       	sei
     91e:	df 91       	pop	r29
     920:	cf 91       	pop	r28
     922:	08 95       	ret

00000924 <chSysTimerHandlerI>:
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
     924:	68 c0       	rjmp	.+208    	; 0x9f6 <chVTDoTickI>

00000926 <chVTDoSetI>:
  } while (dlp != &vtlp->dlist);

  chDbgAssert(false, "timer not in list");

  return (sysinterval_t)-1;
}
     926:	cf 93       	push	r28
     928:	df 93       	push	r29
     92a:	dc 01       	movw	r26, r24
     92c:	19 96       	adiw	r26, 0x09	; 9
     92e:	3c 93       	st	X, r19
     930:	2e 93       	st	-X, r18
     932:	18 97       	sbiw	r26, 0x08	; 8
     934:	17 96       	adiw	r26, 0x07	; 7
     936:	5c 93       	st	X, r21
     938:	4e 93       	st	-X, r20
     93a:	16 97       	sbiw	r26, 0x06	; 6
     93c:	1b 96       	adiw	r26, 0x0b	; 11
     93e:	1c 92       	st	X, r1
     940:	1e 92       	st	-X, r1
     942:	1a 97       	sbiw	r26, 0x0a	; 10
     944:	e0 91 b1 06 	lds	r30, 0x06B1	; 0x8006b1 <ch0+0x7>
     948:	f0 91 b2 06 	lds	r31, 0x06B2	; 0x8006b2 <ch0+0x8>
     94c:	24 81       	ldd	r18, Z+4	; 0x04
     94e:	35 81       	ldd	r19, Z+5	; 0x05
     950:	26 17       	cp	r18, r22
     952:	37 07       	cpc	r19, r23
     954:	50 f4       	brcc	.+20     	; 0x96a <chVTDoSetI+0x44>
     956:	62 1b       	sub	r22, r18
     958:	73 0b       	sbc	r23, r19
     95a:	01 90       	ld	r0, Z+
     95c:	f0 81       	ld	r31, Z
     95e:	e0 2d       	mov	r30, r0
     960:	24 81       	ldd	r18, Z+4	; 0x04
     962:	35 81       	ldd	r19, Z+5	; 0x05
     964:	26 17       	cp	r18, r22
     966:	37 07       	cpc	r19, r23
     968:	b0 f3       	brcs	.-20     	; 0x956 <chVTDoSetI+0x30>
     96a:	15 96       	adiw	r26, 0x05	; 5
     96c:	7c 93       	st	X, r23
     96e:	6e 93       	st	-X, r22
     970:	14 97       	sbiw	r26, 0x04	; 4
     972:	11 96       	adiw	r26, 0x01	; 1
     974:	fc 93       	st	X, r31
     976:	ee 93       	st	-X, r30
     978:	c2 81       	ldd	r28, Z+2	; 0x02
     97a:	d3 81       	ldd	r29, Z+3	; 0x03
     97c:	13 96       	adiw	r26, 0x03	; 3
     97e:	dc 93       	st	X, r29
     980:	ce 93       	st	-X, r28
     982:	12 97       	sbiw	r26, 0x02	; 2
     984:	b9 83       	std	Y+1, r27	; 0x01
     986:	a8 83       	st	Y, r26
     988:	b3 83       	std	Z+3, r27	; 0x03
     98a:	a2 83       	std	Z+2, r26	; 0x02
     98c:	84 81       	ldd	r24, Z+4	; 0x04
     98e:	95 81       	ldd	r25, Z+5	; 0x05
     990:	86 1b       	sub	r24, r22
     992:	97 0b       	sbc	r25, r23
     994:	95 83       	std	Z+5, r25	; 0x05
     996:	84 83       	std	Z+4, r24	; 0x04
     998:	8f ef       	ldi	r24, 0xFF	; 255
     99a:	9f ef       	ldi	r25, 0xFF	; 255
     99c:	90 93 b6 06 	sts	0x06B6, r25	; 0x8006b6 <ch0+0xc>
     9a0:	80 93 b5 06 	sts	0x06B5, r24	; 0x8006b5 <ch0+0xb>
     9a4:	df 91       	pop	r29
     9a6:	cf 91       	pop	r28
     9a8:	08 95       	ret

000009aa <chVTDoResetI>:
     9aa:	cf 93       	push	r28
     9ac:	df 93       	push	r29
     9ae:	fc 01       	movw	r30, r24
     9b0:	a0 81       	ld	r26, Z
     9b2:	b1 81       	ldd	r27, Z+1	; 0x01
     9b4:	14 96       	adiw	r26, 0x04	; 4
     9b6:	8d 91       	ld	r24, X+
     9b8:	9c 91       	ld	r25, X
     9ba:	15 97       	sbiw	r26, 0x05	; 5
     9bc:	24 81       	ldd	r18, Z+4	; 0x04
     9be:	35 81       	ldd	r19, Z+5	; 0x05
     9c0:	82 0f       	add	r24, r18
     9c2:	93 1f       	adc	r25, r19
     9c4:	15 96       	adiw	r26, 0x05	; 5
     9c6:	9c 93       	st	X, r25
     9c8:	8e 93       	st	-X, r24
     9ca:	14 97       	sbiw	r26, 0x04	; 4
     9cc:	c2 81       	ldd	r28, Z+2	; 0x02
     9ce:	d3 81       	ldd	r29, Z+3	; 0x03
     9d0:	b9 83       	std	Y+1, r27	; 0x01
     9d2:	a8 83       	st	Y, r26
     9d4:	a0 81       	ld	r26, Z
     9d6:	b1 81       	ldd	r27, Z+1	; 0x01
     9d8:	13 96       	adiw	r26, 0x03	; 3
     9da:	dc 93       	st	X, r29
     9dc:	ce 93       	st	-X, r28
     9de:	12 97       	sbiw	r26, 0x02	; 2
     9e0:	11 82       	std	Z+1, r1	; 0x01
     9e2:	10 82       	st	Z, r1
     9e4:	8f ef       	ldi	r24, 0xFF	; 255
     9e6:	9f ef       	ldi	r25, 0xFF	; 255
     9e8:	90 93 b6 06 	sts	0x06B6, r25	; 0x8006b6 <ch0+0xc>
     9ec:	80 93 b5 06 	sts	0x06B5, r24	; 0x8006b5 <ch0+0xb>
     9f0:	df 91       	pop	r29
     9f2:	cf 91       	pop	r28
     9f4:	08 95       	ret

000009f6 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
     9f6:	0f 93       	push	r16
     9f8:	1f 93       	push	r17
     9fa:	cf 93       	push	r28
     9fc:	df 93       	push	r29
  virtual_timers_list_t *vtlp = &currcore->vtlist;

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime++;
     9fe:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <ch0+0xd>
     a02:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <ch0+0xe>
     a06:	01 96       	adiw	r24, 0x01	; 1
     a08:	90 93 b8 06 	sts	0x06B8, r25	; 0x8006b8 <ch0+0xe>
     a0c:	80 93 b7 06 	sts	0x06B7, r24	; 0x8006b7 <ch0+0xd>
 *
 * @notapi
 */
static inline bool ch_dlist_notempty(ch_delta_list_t *dlhp) {

  return (bool)(dlhp != dlhp->next);
     a10:	c0 91 b1 06 	lds	r28, 0x06B1	; 0x8006b1 <ch0+0x7>
     a14:	d0 91 b2 06 	lds	r29, 0x06B2	; 0x8006b2 <ch0+0x8>
  if (ch_dlist_notempty(&vtlp->dlist)) {
     a18:	86 e0       	ldi	r24, 0x06	; 6
     a1a:	c1 3b       	cpi	r28, 0xB1	; 177
     a1c:	d8 07       	cpc	r29, r24
     a1e:	41 f1       	breq	.+80     	; 0xa70 <chVTDoTickI+0x7a>
    /* The list is not empty, processing elements on top.*/
    --vtlp->dlist.next->delta;
     a20:	8c 81       	ldd	r24, Y+4	; 0x04
     a22:	9d 81       	ldd	r25, Y+5	; 0x05
     a24:	01 97       	sbiw	r24, 0x01	; 1
     a26:	9d 83       	std	Y+5, r25	; 0x05
     a28:	8c 83       	std	Y+4, r24	; 0x04
  dlp->delta -= delta;

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
     a2a:	0f ef       	ldi	r16, 0xFF	; 255
     a2c:	1f ef       	ldi	r17, 0xFF	; 255
    while (vtlp->dlist.next->delta == (sysinterval_t)0) {
     a2e:	1e c0       	rjmp	.+60     	; 0xa6c <chVTDoTickI+0x76>
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {

  dlp->prev->next = dlp->next;
     a30:	ea 81       	ldd	r30, Y+2	; 0x02
     a32:	fb 81       	ldd	r31, Y+3	; 0x03
     a34:	88 81       	ld	r24, Y
     a36:	99 81       	ldd	r25, Y+1	; 0x01
     a38:	91 83       	std	Z+1, r25	; 0x01
     a3a:	80 83       	st	Z, r24
  dlp->next->prev = dlp->prev;
     a3c:	a8 81       	ld	r26, Y
     a3e:	b9 81       	ldd	r27, Y+1	; 0x01
     a40:	13 96       	adiw	r26, 0x03	; 3
     a42:	fc 93       	st	X, r31
     a44:	ee 93       	st	-X, r30
     a46:	12 97       	sbiw	r26, 0x02	; 2
      /* Triggered timer.*/
      vtp = (virtual_timer_t *)vtlp->dlist.next;

      /* Removing the element from the delta list, marking it as not armed.*/
      (void) ch_dlist_dequeue(&vtp->dlist);
      vtp->dlist.next = NULL;
     a48:	19 82       	std	Y+1, r1	; 0x01
     a4a:	18 82       	st	Y, r1

      chSysUnlockFromISR();
      vtp->func(vtp, vtp->par);
     a4c:	68 85       	ldd	r22, Y+8	; 0x08
     a4e:	79 85       	ldd	r23, Y+9	; 0x09
     a50:	ee 81       	ldd	r30, Y+6	; 0x06
     a52:	ff 81       	ldd	r31, Y+7	; 0x07
     a54:	ce 01       	movw	r24, r28
     a56:	09 95       	icall
      chSysLockFromISR();

      /* If a reload is defined the timer needs to be restarted.*/
      if (vtp->reload > (sysinterval_t)0) {
     a58:	8a 85       	ldd	r24, Y+10	; 0x0a
     a5a:	9b 85       	ldd	r25, Y+11	; 0x0b
     a5c:	00 97       	sbiw	r24, 0x00	; 0
     a5e:	69 f4       	brne	.+26     	; 0xa7a <chVTDoTickI+0x84>
     a60:	c0 91 b1 06 	lds	r28, 0x06B1	; 0x8006b1 <ch0+0x7>
     a64:	d0 91 b2 06 	lds	r29, 0x06B2	; 0x8006b2 <ch0+0x8>
     a68:	8c 81       	ldd	r24, Y+4	; 0x04
     a6a:	9d 81       	ldd	r25, Y+5	; 0x05
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime++;
  if (ch_dlist_notempty(&vtlp->dlist)) {
    /* The list is not empty, processing elements on top.*/
    --vtlp->dlist.next->delta;
    while (vtlp->dlist.next->delta == (sysinterval_t)0) {
     a6c:	89 2b       	or	r24, r25
     a6e:	01 f3       	breq	.-64     	; 0xa30 <chVTDoTickI+0x3a>
  vtp->dlist.delta -= nowdelta;

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     a70:	df 91       	pop	r29
     a72:	cf 91       	pop	r28
     a74:	1f 91       	pop	r17
     a76:	0f 91       	pop	r16
     a78:	08 95       	ret
     a7a:	e0 91 b1 06 	lds	r30, 0x06B1	; 0x8006b1 <ch0+0x7>
     a7e:	f0 91 b2 06 	lds	r31, 0x06B2	; 0x8006b2 <ch0+0x8>
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
     a82:	24 81       	ldd	r18, Z+4	; 0x04
     a84:	35 81       	ldd	r19, Z+5	; 0x05
     a86:	28 17       	cp	r18, r24
     a88:	39 07       	cpc	r19, r25
     a8a:	50 f4       	brcc	.+20     	; 0xaa0 <chVTDoTickI+0xaa>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
     a8c:	82 1b       	sub	r24, r18
     a8e:	93 0b       	sbc	r25, r19
    dlp = dlp->next;
     a90:	01 90       	ld	r0, Z+
     a92:	f0 81       	ld	r31, Z
     a94:	e0 2d       	mov	r30, r0
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
     a96:	24 81       	ldd	r18, Z+4	; 0x04
     a98:	35 81       	ldd	r19, Z+5	; 0x05
     a9a:	28 17       	cp	r18, r24
     a9c:	39 07       	cpc	r19, r25
     a9e:	b0 f3       	brcs	.-20     	; 0xa8c <chVTDoTickI+0x96>
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {

  dlp->delta      = delta;
     aa0:	9d 83       	std	Y+5, r25	; 0x05
     aa2:	8c 83       	std	Y+4, r24	; 0x04
  dlp->next       = dlhp;
     aa4:	f9 83       	std	Y+1, r31	; 0x01
     aa6:	e8 83       	st	Y, r30
  dlp->prev       = dlp->next->prev;
     aa8:	a2 81       	ldd	r26, Z+2	; 0x02
     aaa:	b3 81       	ldd	r27, Z+3	; 0x03
     aac:	bb 83       	std	Y+3, r27	; 0x03
     aae:	aa 83       	std	Y+2, r26	; 0x02
  dlp->prev->next = dlp;
     ab0:	cd 93       	st	X+, r28
     ab2:	dc 93       	st	X, r29
  dlhp->prev      = dlp;
     ab4:	d3 83       	std	Z+3, r29	; 0x03
     ab6:	c2 83       	std	Z+2, r28	; 0x02

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
     ab8:	24 81       	ldd	r18, Z+4	; 0x04
     aba:	35 81       	ldd	r19, Z+5	; 0x05
     abc:	28 1b       	sub	r18, r24
     abe:	39 0b       	sbc	r19, r25
     ac0:	35 83       	std	Z+5, r19	; 0x05
     ac2:	24 83       	std	Z+4, r18	; 0x04

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
     ac4:	10 93 b6 06 	sts	0x06B6, r17	; 0x8006b6 <ch0+0xc>
     ac8:	00 93 b5 06 	sts	0x06B5, r16	; 0x8006b5 <ch0+0xb>
     acc:	c9 cf       	rjmp	.-110    	; 0xa60 <chVTDoTickI+0x6a>

00000ace <__sch_wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
     ace:	cf 93       	push	r28
     ad0:	df 93       	push	r29
     ad2:	db 01       	movw	r26, r22
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
     ad4:	1f 96       	adiw	r26, 0x0f	; 15
     ad6:	8c 91       	ld	r24, X
     ad8:	1f 97       	sbiw	r26, 0x0f	; 15
     ada:	84 30       	cpi	r24, 0x04	; 4
     adc:	f1 f1       	breq	.+124    	; 0xb5a <__sch_wakeup+0x8c>
     ade:	80 f5       	brcc	.+96     	; 0xb40 <__sch_wakeup+0x72>
     ae0:	88 23       	and	r24, r24
     ae2:	59 f1       	breq	.+86     	; 0xb3a <__sch_wakeup+0x6c>
     ae4:	83 30       	cpi	r24, 0x03	; 3
     ae6:	31 f4       	brne	.+12     	; 0xaf4 <__sch_wakeup+0x26>
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
     ae8:	52 96       	adiw	r26, 0x12	; 18
     aea:	ed 91       	ld	r30, X+
     aec:	fc 91       	ld	r31, X
     aee:	53 97       	sbiw	r26, 0x13	; 19
     af0:	11 82       	std	Z+1, r1	; 0x01
     af2:	10 82       	st	Z, r1
    /* Any other state, nothing to do.*/
    break;
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
     af4:	8f ef       	ldi	r24, 0xFF	; 255
     af6:	9f ef       	ldi	r25, 0xFF	; 255
     af8:	53 96       	adiw	r26, 0x13	; 19
     afa:	9c 93       	st	X, r25
     afc:	8e 93       	st	-X, r24
     afe:	52 97       	sbiw	r26, 0x12	; 18

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     b00:	1f 96       	adiw	r26, 0x0f	; 15
     b02:	1c 92       	st	X, r1
     b04:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     b06:	1b 96       	adiw	r26, 0x0b	; 11
     b08:	ed 91       	ld	r30, X+
     b0a:	fc 91       	ld	r31, X
     b0c:	1c 97       	sbiw	r26, 0x0c	; 12
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio >= p->prio));
     b0e:	14 96       	adiw	r26, 0x04	; 4
     b10:	9c 91       	ld	r25, X
     b12:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     b14:	01 90       	ld	r0, Z+
     b16:	f0 81       	ld	r31, Z
     b18:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     b1a:	84 81       	ldd	r24, Z+4	; 0x04
     b1c:	89 17       	cp	r24, r25
     b1e:	d0 f7       	brcc	.-12     	; 0xb14 <__sch_wakeup+0x46>

  /* Insertion on prev.*/
  p->next       = pqp;
     b20:	11 96       	adiw	r26, 0x01	; 1
     b22:	fc 93       	st	X, r31
     b24:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     b26:	c2 81       	ldd	r28, Z+2	; 0x02
     b28:	d3 81       	ldd	r29, Z+3	; 0x03
     b2a:	13 96       	adiw	r26, 0x03	; 3
     b2c:	dc 93       	st	X, r29
     b2e:	ce 93       	st	-X, r28
     b30:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     b32:	b9 83       	std	Y+1, r27	; 0x01
     b34:	a8 83       	st	Y, r26
  pqp->prev     = p;
     b36:	b3 83       	std	Z+3, r27	; 0x03
     b38:	a2 83       	std	Z+2, r26	; 0x02
  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
  chSysUnlockFromISR();

  return;
}
     b3a:	df 91       	pop	r29
     b3c:	cf 91       	pop	r28
     b3e:	08 95       	ret
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
     b40:	87 30       	cpi	r24, 0x07	; 7
     b42:	59 f0       	breq	.+22     	; 0xb5a <__sch_wakeup+0x8c>
     b44:	8c 30       	cpi	r24, 0x0C	; 12
     b46:	49 f0       	breq	.+18     	; 0xb5a <__sch_wakeup+0x8c>
     b48:	85 30       	cpi	r24, 0x05	; 5
     b4a:	a1 f6       	brne	.-88     	; 0xaf4 <__sch_wakeup+0x26>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
     b4c:	52 96       	adiw	r26, 0x12	; 18
     b4e:	ed 91       	ld	r30, X+
     b50:	fc 91       	ld	r31, X
     b52:	53 97       	sbiw	r26, 0x13	; 19
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
     b54:	84 81       	ldd	r24, Z+4	; 0x04
     b56:	8f 5f       	subi	r24, 0xFF	; 255
     b58:	84 83       	std	Z+4, r24	; 0x04
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {

  p->prev->next = p->next;
     b5a:	12 96       	adiw	r26, 0x02	; 2
     b5c:	ed 91       	ld	r30, X+
     b5e:	fc 91       	ld	r31, X
     b60:	13 97       	sbiw	r26, 0x03	; 3
     b62:	8d 91       	ld	r24, X+
     b64:	9c 91       	ld	r25, X
     b66:	11 97       	sbiw	r26, 0x01	; 1
     b68:	91 83       	std	Z+1, r25	; 0x01
     b6a:	80 83       	st	Z, r24
  p->next->prev = p->prev;
     b6c:	cd 91       	ld	r28, X+
     b6e:	dc 91       	ld	r29, X
     b70:	11 97       	sbiw	r26, 0x01	; 1
     b72:	fb 83       	std	Y+3, r31	; 0x03
     b74:	ea 83       	std	Y+2, r30	; 0x02
     b76:	be cf       	rjmp	.-132    	; 0xaf4 <__sch_wakeup+0x26>

00000b78 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
     b78:	cf 93       	push	r28
     b7a:	df 93       	push	r29
     b7c:	dc 01       	movw	r26, r24

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     b7e:	1f 96       	adiw	r26, 0x0f	; 15
     b80:	1c 92       	st	X, r1
     b82:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     b84:	1b 96       	adiw	r26, 0x0b	; 11
     b86:	ed 91       	ld	r30, X+
     b88:	fc 91       	ld	r31, X
     b8a:	1c 97       	sbiw	r26, 0x0c	; 12
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio >= p->prio));
     b8c:	14 96       	adiw	r26, 0x04	; 4
     b8e:	8c 91       	ld	r24, X
     b90:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     b92:	01 90       	ld	r0, Z+
     b94:	f0 81       	ld	r31, Z
     b96:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     b98:	94 81       	ldd	r25, Z+4	; 0x04
     b9a:	98 17       	cp	r25, r24
     b9c:	d0 f7       	brcc	.-12     	; 0xb92 <chSchReadyI+0x1a>

  /* Insertion on prev.*/
  p->next       = pqp;
     b9e:	11 96       	adiw	r26, 0x01	; 1
     ba0:	fc 93       	st	X, r31
     ba2:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     ba4:	c2 81       	ldd	r28, Z+2	; 0x02
     ba6:	d3 81       	ldd	r29, Z+3	; 0x03
     ba8:	13 96       	adiw	r26, 0x03	; 3
     baa:	dc 93       	st	X, r29
     bac:	ce 93       	st	-X, r28
     bae:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     bb0:	b9 83       	std	Y+1, r27	; 0x01
     bb2:	a8 83       	st	Y, r26
  pqp->prev     = p;
     bb4:	b3 83       	std	Z+3, r27	; 0x03
     bb6:	a2 83       	std	Z+2, r26	; 0x02
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
}
     bb8:	cd 01       	movw	r24, r26
     bba:	df 91       	pop	r29
     bbc:	cf 91       	pop	r28
     bbe:	08 95       	ret

00000bc0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
     bc0:	cf 93       	push	r28
     bc2:	df 93       	push	r29
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     bc4:	ea ea       	ldi	r30, 0xAA	; 170
     bc6:	f6 e0       	ldi	r31, 0x06	; 6
     bc8:	65 81       	ldd	r22, Z+5	; 0x05
     bca:	76 81       	ldd	r23, Z+6	; 0x06

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
  chDbgAssert(otp->owner == oip, "invalid core");

  /* New state.*/
  otp->state = newstate;
     bcc:	db 01       	movw	r26, r22
     bce:	1f 96       	adiw	r26, 0x0f	; 15
     bd0:	8c 93       	st	X, r24
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
     bd2:	80 81       	ld	r24, Z
     bd4:	91 81       	ldd	r25, Z+1	; 0x01

  pqp->next       = p->next;
     bd6:	ec 01       	movw	r28, r24
     bd8:	a8 81       	ld	r26, Y
     bda:	b9 81       	ldd	r27, Y+1	; 0x01
     bdc:	b1 83       	std	Z+1, r27	; 0x01
     bde:	a0 83       	st	Z, r26
  pqp->next->prev = pqp;
     be0:	13 96       	adiw	r26, 0x03	; 3
     be2:	fc 93       	st	X, r31
     be4:	ee 93       	st	-X, r30
     be6:	12 97       	sbiw	r26, 0x02	; 2
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
     be8:	21 e0       	ldi	r18, 0x01	; 1
     bea:	2f 87       	std	Y+15, r18	; 0x0f
  __instance_set_currthread(oip, ntp);
     bec:	96 83       	std	Z+6, r25	; 0x06
     bee:	85 83       	std	Z+5, r24	; 0x05
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
     bf0:	fc d4       	rcall	.+2552   	; 0x15ea <_port_switch>
}
     bf2:	df 91       	pop	r29
     bf4:	cf 91       	pop	r28
     bf6:	08 95       	ret

00000bf8 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
     bf8:	ff 92       	push	r15
     bfa:	0f 93       	push	r16
     bfc:	1f 93       	push	r17
     bfe:	cf 93       	push	r28
     c00:	df 93       	push	r29
     c02:	cd b7       	in	r28, 0x3d	; 61
     c04:	de b7       	in	r29, 0x3e	; 62
     c06:	2c 97       	sbiw	r28, 0x0c	; 12
     c08:	0f b6       	in	r0, 0x3f	; 63
     c0a:	f8 94       	cli
     c0c:	de bf       	out	0x3e, r29	; 62
     c0e:	0f be       	out	0x3f, r0	; 63
     c10:	cd bf       	out	0x3d, r28	; 61
     c12:	f8 2e       	mov	r15, r24
  thread_t *tp = __instance_get_currthread(currcore);
     c14:	00 91 af 06 	lds	r16, 0x06AF	; 0x8006af <ch0+0x5>
     c18:	10 91 b0 06 	lds	r17, 0x06B0	; 0x8006b0 <ch0+0x6>

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
     c1c:	6f 3f       	cpi	r22, 0xFF	; 255
     c1e:	76 07       	cpc	r23, r22
     c20:	f1 f0       	breq	.+60     	; 0xc5e <chSchGoSleepTimeoutS+0x66>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
     c22:	98 01       	movw	r18, r16
     c24:	47 e6       	ldi	r20, 0x67	; 103
     c26:	55 e0       	ldi	r21, 0x05	; 5
     c28:	ce 01       	movw	r24, r28
     c2a:	01 96       	adiw	r24, 0x01	; 1
     c2c:	7c de       	rcall	.-776    	; 0x926 <chVTDoSetI>
    chSchGoSleepS(newstate);
     c2e:	8f 2d       	mov	r24, r15
     c30:	c7 df       	rcall	.-114    	; 0xbc0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
     c32:	89 81       	ldd	r24, Y+1	; 0x01
     c34:	9a 81       	ldd	r25, Y+2	; 0x02
     c36:	89 2b       	or	r24, r25
     c38:	19 f0       	breq	.+6      	; 0xc40 <chSchGoSleepTimeoutS+0x48>
      chVTDoResetI(&vt);
     c3a:	ce 01       	movw	r24, r28
     c3c:	01 96       	adiw	r24, 0x01	; 1
     c3e:	b5 de       	rcall	.-662    	; 0x9aa <chVTDoResetI>
  else {
    chSchGoSleepS(newstate);
  }

  return tp->u.rdymsg;
}
     c40:	f8 01       	movw	r30, r16
     c42:	82 89       	ldd	r24, Z+18	; 0x12
     c44:	93 89       	ldd	r25, Z+19	; 0x13
     c46:	2c 96       	adiw	r28, 0x0c	; 12
     c48:	0f b6       	in	r0, 0x3f	; 63
     c4a:	f8 94       	cli
     c4c:	de bf       	out	0x3e, r29	; 62
     c4e:	0f be       	out	0x3f, r0	; 63
     c50:	cd bf       	out	0x3d, r28	; 61
     c52:	df 91       	pop	r29
     c54:	cf 91       	pop	r28
     c56:	1f 91       	pop	r17
     c58:	0f 91       	pop	r16
     c5a:	ff 90       	pop	r15
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
     c5c:	08 95       	ret
     c5e:	8f 2d       	mov	r24, r15
     c60:	af df       	rcall	.-162    	; 0xbc0 <chSchGoSleepS>
     c62:	ee cf       	rjmp	.-36     	; 0xc40 <chSchGoSleepTimeoutS+0x48>

00000c64 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
     c64:	cf 93       	push	r28
     c66:	df 93       	push	r29
     c68:	dc 01       	movw	r26, r24
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     c6a:	c0 91 af 06 	lds	r28, 0x06AF	; 0x8006af <ch0+0x5>
     c6e:	d0 91 b0 06 	lds	r29, 0x06B0	; 0x8006b0 <ch0+0x6>
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
     c72:	53 96       	adiw	r26, 0x13	; 19
     c74:	7c 93       	st	X, r23
     c76:	6e 93       	st	-X, r22
     c78:	52 97       	sbiw	r26, 0x12	; 18
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
     c7a:	14 96       	adiw	r26, 0x04	; 4
     c7c:	2c 91       	ld	r18, X
     c7e:	14 97       	sbiw	r26, 0x04	; 4
     c80:	9c 81       	ldd	r25, Y+4	; 0x04
     c82:	92 17       	cp	r25, r18
     c84:	e8 f0       	brcs	.+58     	; 0xcc0 <chSchWakeupS+0x5c>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     c86:	1f 96       	adiw	r26, 0x0f	; 15
     c88:	1c 92       	st	X, r1
     c8a:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     c8c:	1b 96       	adiw	r26, 0x0b	; 11
     c8e:	ed 91       	ld	r30, X+
     c90:	fc 91       	ld	r31, X
     c92:	1c 97       	sbiw	r26, 0x0c	; 12
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     c94:	01 90       	ld	r0, Z+
     c96:	f0 81       	ld	r31, Z
     c98:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     c9a:	84 81       	ldd	r24, Z+4	; 0x04
     c9c:	82 17       	cp	r24, r18
     c9e:	d0 f7       	brcc	.-12     	; 0xc94 <chSchWakeupS+0x30>

  /* Insertion on prev.*/
  p->next       = pqp;
     ca0:	11 96       	adiw	r26, 0x01	; 1
     ca2:	fc 93       	st	X, r31
     ca4:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     ca6:	c2 81       	ldd	r28, Z+2	; 0x02
     ca8:	d3 81       	ldd	r29, Z+3	; 0x03
     caa:	13 96       	adiw	r26, 0x03	; 3
     cac:	dc 93       	st	X, r29
     cae:	ce 93       	st	-X, r28
     cb0:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     cb2:	b9 83       	std	Y+1, r27	; 0x01
     cb4:	a8 83       	st	Y, r26
  pqp->prev     = p;
     cb6:	b3 83       	std	Z+3, r27	; 0x03
     cb8:	a2 83       	std	Z+2, r26	; 0x02
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
     cba:	df 91       	pop	r29
     cbc:	cf 91       	pop	r28
     cbe:	08 95       	ret

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     cc0:	1f 86       	std	Y+15, r1	; 0x0f

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
     cc2:	eb 85       	ldd	r30, Y+11	; 0x0b
     cc4:	fc 85       	ldd	r31, Y+12	; 0x0c
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     cc6:	01 90       	ld	r0, Z+
     cc8:	f0 81       	ld	r31, Z
     cca:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio > p->prio));
     ccc:	84 81       	ldd	r24, Z+4	; 0x04
     cce:	98 17       	cp	r25, r24
     cd0:	d0 f3       	brcs	.-12     	; 0xcc6 <chSchWakeupS+0x62>
     cd2:	cd 01       	movw	r24, r26

  /* Insertion on prev.*/
  p->next       = pqp;
     cd4:	f9 83       	std	Y+1, r31	; 0x01
     cd6:	e8 83       	st	Y, r30
  p->prev       = pqp->prev;
     cd8:	a2 81       	ldd	r26, Z+2	; 0x02
     cda:	b3 81       	ldd	r27, Z+3	; 0x03
     cdc:	bb 83       	std	Y+3, r27	; 0x03
     cde:	aa 83       	std	Y+2, r26	; 0x02
  p->prev->next = p;
     ce0:	cd 93       	st	X+, r28
     ce2:	dc 93       	st	X, r29
  pqp->prev     = p;
     ce4:	d3 83       	std	Z+3, r29	; 0x03
     ce6:	c2 83       	std	Z+2, r28	; 0x02
    if (otp->hdr.pqueue.prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    ntp->state = CH_STATE_CURRENT;
     ce8:	21 e0       	ldi	r18, 0x01	; 1
     cea:	fc 01       	movw	r30, r24
     cec:	27 87       	std	Z+15, r18	; 0x0f
    __instance_set_currthread(oip, ntp);
     cee:	90 93 b0 06 	sts	0x06B0, r25	; 0x8006b0 <ch0+0x6>
     cf2:	80 93 af 06 	sts	0x06AF, r24	; 0x8006af <ch0+0x5>

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
     cf6:	be 01       	movw	r22, r28
     cf8:	78 d4       	rcall	.+2288   	; 0x15ea <_port_switch>
  }
}
     cfa:	df 91       	pop	r29
     cfc:	cf 91       	pop	r28
     cfe:	08 95       	ret

00000d00 <chSchIsPreemptionRequired>:
 */
bool chSchIsPreemptionRequired(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
     d00:	a0 91 aa 06 	lds	r26, 0x06AA	; 0x8006aa <ch0>
     d04:	b0 91 ab 06 	lds	r27, 0x06AB	; 0x8006ab <ch0+0x1>
  tprio_t p2 = tp->hdr.pqueue.prio;
     d08:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <ch0+0x5>
     d0c:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <ch0+0x6>
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
     d10:	81 e0       	ldi	r24, 0x01	; 1
     d12:	14 96       	adiw	r26, 0x04	; 4
     d14:	2c 91       	ld	r18, X
     d16:	94 81       	ldd	r25, Z+4	; 0x04
     d18:	92 17       	cp	r25, r18
     d1a:	08 f0       	brcs	.+2      	; 0xd1e <chSchIsPreemptionRequired+0x1e>
     d1c:	80 e0       	ldi	r24, 0x00	; 0
#endif
}
     d1e:	08 95       	ret

00000d20 <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
     d20:	cf 93       	push	r28
     d22:	df 93       	push	r29
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     d24:	a0 91 af 06 	lds	r26, 0x06AF	; 0x8006af <ch0+0x5>
     d28:	b0 91 b0 06 	lds	r27, 0x06B0	; 0x8006b0 <ch0+0x6>
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
     d2c:	40 91 aa 06 	lds	r20, 0x06AA	; 0x8006aa <ch0>
     d30:	50 91 ab 06 	lds	r21, 0x06AB	; 0x8006ab <ch0+0x1>

  pqp->next       = p->next;
     d34:	ea 01       	movw	r28, r20
     d36:	e8 81       	ld	r30, Y
     d38:	f9 81       	ldd	r31, Y+1	; 0x01
     d3a:	f0 93 ab 06 	sts	0x06AB, r31	; 0x8006ab <ch0+0x1>
     d3e:	e0 93 aa 06 	sts	0x06AA, r30	; 0x8006aa <ch0>
  pqp->next->prev = pqp;
     d42:	8a ea       	ldi	r24, 0xAA	; 170
     d44:	96 e0       	ldi	r25, 0x06	; 6
     d46:	93 83       	std	Z+3, r25	; 0x03
     d48:	82 83       	std	Z+2, r24	; 0x02
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
     d4a:	81 e0       	ldi	r24, 0x01	; 1
     d4c:	8f 87       	std	Y+15, r24	; 0x0f
  __instance_set_currthread(oip, ntp);
     d4e:	50 93 b0 06 	sts	0x06B0, r21	; 0x8006b0 <ch0+0x6>
     d52:	40 93 af 06 	sts	0x06AF, r20	; 0x8006af <ch0+0x5>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     d56:	1f 96       	adiw	r26, 0x0f	; 15
     d58:	1c 92       	st	X, r1
     d5a:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
     d5c:	1b 96       	adiw	r26, 0x0b	; 11
     d5e:	ed 91       	ld	r30, X+
     d60:	fc 91       	ld	r31, X
     d62:	1c 97       	sbiw	r26, 0x0c	; 12
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio > p->prio));
     d64:	14 96       	adiw	r26, 0x04	; 4
     d66:	2c 91       	ld	r18, X
     d68:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     d6a:	01 90       	ld	r0, Z+
     d6c:	f0 81       	ld	r31, Z
     d6e:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio > p->prio));
     d70:	94 81       	ldd	r25, Z+4	; 0x04
     d72:	29 17       	cp	r18, r25
     d74:	d0 f3       	brcs	.-12     	; 0xd6a <chSchDoPreemption+0x4a>

  /* Insertion on prev.*/
  p->next       = pqp;
     d76:	11 96       	adiw	r26, 0x01	; 1
     d78:	fc 93       	st	X, r31
     d7a:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     d7c:	82 81       	ldd	r24, Z+2	; 0x02
     d7e:	93 81       	ldd	r25, Z+3	; 0x03
     d80:	13 96       	adiw	r26, 0x03	; 3
     d82:	9c 93       	st	X, r25
     d84:	8e 93       	st	-X, r24
     d86:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     d88:	ec 01       	movw	r28, r24
     d8a:	b9 83       	std	Y+1, r27	; 0x01
     d8c:	a8 83       	st	Y, r26
  pqp->prev     = p;
     d8e:	b3 83       	std	Z+3, r27	; 0x03
     d90:	a2 83       	std	Z+2, r26	; 0x02
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
     d92:	bd 01       	movw	r22, r26
     d94:	ca 01       	movw	r24, r20
     d96:	29 d4       	rcall	.+2130   	; 0x15ea <_port_switch>
}
     d98:	df 91       	pop	r29
     d9a:	cf 91       	pop	r28
     d9c:	08 95       	ret

00000d9e <chSchRescheduleS>:

  chDbgCheckClassS();

  /* Note, we are favoring the path where the reschedule is necessary
     because higher priority threads are ready.*/
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
     d9e:	a0 91 aa 06 	lds	r26, 0x06AA	; 0x8006aa <ch0>
     da2:	b0 91 ab 06 	lds	r27, 0x06AB	; 0x8006ab <ch0+0x1>
     da6:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <ch0+0x5>
     daa:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <ch0+0x6>
     dae:	14 96       	adiw	r26, 0x04	; 4
     db0:	9c 91       	ld	r25, X
     db2:	84 81       	ldd	r24, Z+4	; 0x04
     db4:	89 17       	cp	r24, r25
     db6:	08 f0       	brcs	.+2      	; 0xdba <chSchRescheduleS+0x1c>
    __sch_reschedule_ahead();
  }
}
     db8:	08 95       	ret
  chDbgCheckClassS();

  /* Note, we are favoring the path where the reschedule is necessary
     because higher priority threads are ready.*/
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
    __sch_reschedule_ahead();
     dba:	b2 cf       	rjmp	.-156    	; 0xd20 <chSchDoPreemption>

00000dbc <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
     dbc:	ff cf       	rjmp	.-2      	; 0xdbc <__idle_thread>

00000dbe <chInstanceObjectInit>:
 * @param[in] oicp      pointer to the @p os_instance_config_t structure
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
     dbe:	df 92       	push	r13
     dc0:	ef 92       	push	r14
     dc2:	ff 92       	push	r15
     dc4:	0f 93       	push	r16
     dc6:	1f 93       	push	r17
     dc8:	cf 93       	push	r28
     dca:	df 93       	push	r29
     dcc:	cd b7       	in	r28, 0x3d	; 61
     dce:	de b7       	in	r29, 0x3e	; 62
     dd0:	2b 97       	sbiw	r28, 0x0b	; 11
     dd2:	0f b6       	in	r0, 0x3f	; 63
     dd4:	f8 94       	cli
     dd6:	de bf       	out	0x3e, r29	; 62
     dd8:	0f be       	out	0x3f, r0	; 63
     dda:	cd bf       	out	0x3d, r28	; 61
     ddc:	8c 01       	movw	r16, r24
     dde:	7b 01       	movw	r14, r22
  core_id = port_get_core_id();
#else
  core_id = 0U;
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
     de0:	90 93 a9 06 	sts	0x06A9, r25	; 0x8006a9 <ch_system+0x2>
     de4:	80 93 a8 06 	sts	0x06A8, r24	; 0x8006a8 <ch_system+0x1>

  /* Core associated to this instance.*/
  oip->core_id = core_id;
     de8:	fc 01       	movw	r30, r24
     dea:	14 8e       	std	Z+28, r1	; 0x1c
     dec:	13 8e       	std	Z+27, r1	; 0x1b

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
     dee:	72 a3       	std	Z+34, r23	; 0x22
     df0:	61 a3       	std	Z+33, r22	; 0x21

  /* Port initialization for the current instance.*/
  port_init(oip);
     df2:	dd 24       	eor	r13, r13
     df4:	d3 94       	inc	r13
     df6:	d0 92 f1 06 	sts	0x06F1, r13	; 0x8006f1 <__avr_in_isr>
 *
 * @notapi
 */
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {

  pqp->next = pqp;
     dfa:	91 83       	std	Z+1, r25	; 0x01
     dfc:	80 83       	st	Z, r24
  pqp->prev = pqp;
     dfe:	93 83       	std	Z+3, r25	; 0x03
     e00:	82 83       	std	Z+2, r24	; 0x02
  pqp->prio = (tprio_t)0;
     e02:	14 82       	std	Z+4, r1	; 0x04
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {

  ch_queue_init(&rp->queue);
     e04:	47 96       	adiw	r24, 0x17	; 23
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
     e06:	90 8f       	std	Z+24, r25	; 0x18
     e08:	87 8b       	std	Z+23, r24	; 0x17
  qp->prev = qp;
     e0a:	92 8f       	std	Z+26, r25	; 0x1a
     e0c:	81 8f       	std	Z+25, r24	; 0x19
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {

  rfcup->mask = (rfcu_mask_t)0;
     e0e:	15 8e       	std	Z+29, r1	; 0x1d
     e10:	16 8e       	std	Z+30, r1	; 0x1e
     e12:	17 8e       	std	Z+31, r1	; 0x1f
     e14:	10 a2       	std	Z+32, r1	; 0x20
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {

  ch_dlist_init(&vtlp->dlist);
     e16:	40 97       	sbiw	r24, 0x10	; 16
 *
 * @notapi
 */
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {

  dlhp->next  = dlhp;
     e18:	90 87       	std	Z+8, r25	; 0x08
     e1a:	87 83       	std	Z+7, r24	; 0x07
  dlhp->prev  = dlhp;
     e1c:	92 87       	std	Z+10, r25	; 0x0a
     e1e:	81 87       	std	Z+9, r24	; 0x09
  dlhp->delta = (sysinterval_t)-1;
     e20:	8f ef       	ldi	r24, 0xFF	; 255
     e22:	9f ef       	ldi	r25, 0xFF	; 255
     e24:	94 87       	std	Z+12, r25	; 0x0c
     e26:	83 87       	std	Z+11, r24	; 0x0b
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
     e28:	16 86       	std	Z+14, r1	; 0x0e
     e2a:	15 86       	std	Z+13, r1	; 0x0d
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return currcore->vtlist.systime;
     e2c:	20 91 b7 06 	lds	r18, 0x06B7	; 0x8006b7 <ch0+0xd>
     e30:	30 91 b8 06 	lds	r19, 0x06B8	; 0x8006b8 <ch0+0xe>
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
     e34:	27 87       	std	Z+15, r18	; 0x0f
     e36:	30 8b       	std	Z+16, r19	; 0x10
     e38:	11 8a       	std	Z+17, r1	; 0x11
     e3a:	12 8a       	std	Z+18, r1	; 0x12
     e3c:	13 8a       	std	Z+19, r1	; 0x13
     e3e:	14 8a       	std	Z+20, r1	; 0x14
     e40:	15 8a       	std	Z+21, r1	; 0x15
     e42:	16 8a       	std	Z+22, r1	; 0x16
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {

  sdp->panic_msg = NULL;
     e44:	ef 5b       	subi	r30, 0xBF	; 191
     e46:	ff 4f       	sbci	r31, 0xFF	; 255
     e48:	11 82       	std	Z+1, r1	; 0x01
     e4a:	10 82       	st	Z, r1
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
     e4c:	b8 01       	movw	r22, r16
     e4e:	6d 5d       	subi	r22, 0xDD	; 221
     e50:	7f 4f       	sbci	r23, 0xFF	; 255
     e52:	20 e8       	ldi	r18, 0x80	; 128
     e54:	42 e3       	ldi	r20, 0x32	; 50
     e56:	51 e0       	ldi	r21, 0x01	; 1
     e58:	c8 01       	movw	r24, r16
     e5a:	2a d0       	rcall	.+84     	; 0xeb0 <__thd_object_init>
     e5c:	f8 01       	movw	r30, r16
     e5e:	96 83       	std	Z+6, r25	; 0x06
     e60:	85 83       	std	Z+5, r24	; 0x05
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
     e62:	fc 01       	movw	r30, r24
     e64:	d7 86       	std	Z+15, r13	; 0x0f
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
     e66:	86 e2       	ldi	r24, 0x26	; 38
     e68:	91 e0       	ldi	r25, 0x01	; 1
     e6a:	9a 83       	std	Y+2, r25	; 0x02
     e6c:	89 83       	std	Y+1, r24	; 0x01
     e6e:	f7 01       	movw	r30, r14
     e70:	82 81       	ldd	r24, Z+2	; 0x02
     e72:	93 81       	ldd	r25, Z+3	; 0x03
     e74:	9c 83       	std	Y+4, r25	; 0x04
     e76:	8b 83       	std	Y+3, r24	; 0x03
     e78:	84 81       	ldd	r24, Z+4	; 0x04
     e7a:	95 81       	ldd	r25, Z+5	; 0x05
     e7c:	9e 83       	std	Y+6, r25	; 0x06
     e7e:	8d 83       	std	Y+5, r24	; 0x05
     e80:	df 82       	std	Y+7, r13	; 0x07
     e82:	8e ed       	ldi	r24, 0xDE	; 222
     e84:	96 e0       	ldi	r25, 0x06	; 6
     e86:	99 87       	std	Y+9, r25	; 0x09
     e88:	88 87       	std	Y+8, r24	; 0x08
     e8a:	1b 86       	std	Y+11, r1	; 0x0b
     e8c:	1a 86       	std	Y+10, r1	; 0x0a
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
     e8e:	ce 01       	movw	r24, r28
     e90:	01 96       	adiw	r24, 0x01	; 1
     e92:	9e d0       	rcall	.+316    	; 0xfd0 <chThdCreateI>
  }
#endif
}
     e94:	2b 96       	adiw	r28, 0x0b	; 11
     e96:	0f b6       	in	r0, 0x3f	; 63
     e98:	f8 94       	cli
     e9a:	de bf       	out	0x3e, r29	; 62
     e9c:	0f be       	out	0x3f, r0	; 63
     e9e:	cd bf       	out	0x3d, r28	; 61
     ea0:	df 91       	pop	r29
     ea2:	cf 91       	pop	r28
     ea4:	1f 91       	pop	r17
     ea6:	0f 91       	pop	r16
     ea8:	ff 90       	pop	r15
     eaa:	ef 90       	pop	r14
     eac:	df 90       	pop	r13
     eae:	08 95       	ret

00000eb0 <__thd_object_init>:
void chThdResume(thread_reference_t *trp, msg_t msg) {

  chSysLock();
  chThdResumeS(trp, msg);
  chSysUnlock();
}
     eb0:	cf 93       	push	r28
     eb2:	df 93       	push	r29
     eb4:	fb 01       	movw	r30, r22
     eb6:	24 83       	std	Z+4, r18	; 0x04
     eb8:	32 e0       	ldi	r19, 0x02	; 2
     eba:	37 87       	std	Z+15, r19	; 0x0f
     ebc:	10 8a       	std	Z+16, r1	; 0x10
     ebe:	94 87       	std	Z+12, r25	; 0x0c
     ec0:	83 87       	std	Z+11, r24	; 0x0b
     ec2:	25 8f       	std	Z+29, r18	; 0x1d
     ec4:	14 8e       	std	Z+28, r1	; 0x1c
     ec6:	13 8e       	std	Z+27, r1	; 0x1b
     ec8:	12 8e       	std	Z+26, r1	; 0x1a
     eca:	21 e0       	ldi	r18, 0x01	; 1
     ecc:	21 8b       	std	Z+17, r18	; 0x11
     ece:	56 87       	std	Z+14, r21	; 0x0e
     ed0:	45 87       	std	Z+13, r20	; 0x0d
     ed2:	9b 01       	movw	r18, r22
     ed4:	29 5f       	subi	r18, 0xF9	; 249
     ed6:	3f 4f       	sbci	r19, 0xFF	; 255
     ed8:	ac 01       	movw	r20, r24
     eda:	49 5e       	subi	r20, 0xE9	; 233
     edc:	5f 4f       	sbci	r21, 0xFF	; 255
     ede:	50 87       	std	Z+8, r21	; 0x08
     ee0:	47 83       	std	Z+7, r20	; 0x07
     ee2:	ec 01       	movw	r28, r24
     ee4:	a9 8d       	ldd	r26, Y+25	; 0x19
     ee6:	ba 8d       	ldd	r27, Y+26	; 0x1a
     ee8:	b2 87       	std	Z+10, r27	; 0x0a
     eea:	a1 87       	std	Z+9, r26	; 0x09
     eec:	2d 93       	st	X+, r18
     eee:	3c 93       	st	X, r19
     ef0:	3a 8f       	std	Y+26, r19	; 0x1a
     ef2:	29 8f       	std	Y+25, r18	; 0x19
     ef4:	cb 01       	movw	r24, r22
     ef6:	44 96       	adiw	r24, 0x14	; 20
     ef8:	95 8b       	std	Z+21, r25	; 0x15
     efa:	84 8b       	std	Z+20, r24	; 0x14
     efc:	02 96       	adiw	r24, 0x02	; 2
     efe:	97 8b       	std	Z+23, r25	; 0x17
     f00:	86 8b       	std	Z+22, r24	; 0x16
     f02:	91 8f       	std	Z+25, r25	; 0x19
     f04:	80 8f       	std	Z+24, r24	; 0x18
     f06:	cb 01       	movw	r24, r22
     f08:	df 91       	pop	r29
     f0a:	cf 91       	pop	r28
     f0c:	08 95       	ret

00000f0e <chThdCreateSuspendedI>:
     f0e:	cf 93       	push	r28
     f10:	df 93       	push	r29
     f12:	dc 01       	movw	r26, r24
     f14:	14 96       	adiw	r26, 0x04	; 4
     f16:	2d 91       	ld	r18, X+
     f18:	3c 91       	ld	r19, X
     f1a:	15 97       	sbiw	r26, 0x05	; 5
     f1c:	f9 01       	movw	r30, r18
     f1e:	7e 97       	sbiw	r30, 0x1e	; 30
     f20:	e9 01       	movw	r28, r18
     f22:	e3 97       	sbiw	r28, 0x33	; 51
     f24:	d6 83       	std	Z+6, r29	; 0x06
     f26:	c5 83       	std	Z+5, r28	; 0x05
     f28:	17 96       	adiw	r26, 0x07	; 7
     f2a:	9c 91       	ld	r25, X
     f2c:	17 97       	sbiw	r26, 0x07	; 7
     f2e:	18 96       	adiw	r26, 0x08	; 8
     f30:	8c 91       	ld	r24, X
     f32:	18 97       	sbiw	r26, 0x08	; 8
     f34:	9a 8b       	std	Y+18, r25	; 0x12
     f36:	89 8b       	std	Y+17, r24	; 0x11
     f38:	19 96       	adiw	r26, 0x09	; 9
     f3a:	9c 91       	ld	r25, X
     f3c:	19 97       	sbiw	r26, 0x09	; 9
     f3e:	1a 96       	adiw	r26, 0x0a	; 10
     f40:	8c 91       	ld	r24, X
     f42:	1a 97       	sbiw	r26, 0x0a	; 10
     f44:	98 8b       	std	Y+16, r25	; 0x10
     f46:	8f 87       	std	Y+15, r24	; 0x0f
     f48:	84 e2       	ldi	r24, 0x24	; 36
     f4a:	9b e0       	ldi	r25, 0x0B	; 11
     f4c:	9b 8b       	std	Y+19, r25	; 0x13
     f4e:	8c 8b       	std	Y+20, r24	; 0x14
     f50:	16 96       	adiw	r26, 0x06	; 6
     f52:	8c 91       	ld	r24, X
     f54:	16 97       	sbiw	r26, 0x06	; 6
     f56:	4d 91       	ld	r20, X+
     f58:	5c 91       	ld	r21, X
     f5a:	84 83       	std	Z+4, r24	; 0x04
     f5c:	92 e0       	ldi	r25, 0x02	; 2
     f5e:	97 87       	std	Z+15, r25	; 0x0f
     f60:	10 8a       	std	Z+16, r1	; 0x10
     f62:	6a ea       	ldi	r22, 0xAA	; 170
     f64:	76 e0       	ldi	r23, 0x06	; 6
     f66:	74 87       	std	Z+12, r23	; 0x0c
     f68:	63 87       	std	Z+11, r22	; 0x0b
     f6a:	85 8f       	std	Z+29, r24	; 0x1d
     f6c:	14 8e       	std	Z+28, r1	; 0x1c
     f6e:	13 8e       	std	Z+27, r1	; 0x1b
     f70:	12 8e       	std	Z+26, r1	; 0x1a
     f72:	81 e0       	ldi	r24, 0x01	; 1
     f74:	81 8b       	std	Z+17, r24	; 0x11
     f76:	56 87       	std	Z+14, r21	; 0x0e
     f78:	45 87       	std	Z+13, r20	; 0x0d
     f7a:	d9 01       	movw	r26, r18
     f7c:	57 97       	sbiw	r26, 0x17	; 23
     f7e:	81 ec       	ldi	r24, 0xC1	; 193
     f80:	96 e0       	ldi	r25, 0x06	; 6
     f82:	11 96       	adiw	r26, 0x01	; 1
     f84:	9c 93       	st	X, r25
     f86:	8e 93       	st	-X, r24
     f88:	eb 01       	movw	r28, r22
     f8a:	89 8d       	ldd	r24, Y+25	; 0x19
     f8c:	9a 8d       	ldd	r25, Y+26	; 0x1a
     f8e:	13 96       	adiw	r26, 0x03	; 3
     f90:	9c 93       	st	X, r25
     f92:	8e 93       	st	-X, r24
     f94:	12 97       	sbiw	r26, 0x02	; 2
     f96:	ec 01       	movw	r28, r24
     f98:	b9 83       	std	Y+1, r27	; 0x01
     f9a:	a8 83       	st	Y, r26
     f9c:	eb 01       	movw	r28, r22
     f9e:	ba 8f       	std	Y+26, r27	; 0x1a
     fa0:	a9 8f       	std	Y+25, r26	; 0x19
     fa2:	1d 96       	adiw	r26, 0x0d	; 13
     fa4:	0b 2e       	mov	r0, r27
     fa6:	11 96       	adiw	r26, 0x01	; 1
     fa8:	0c 92       	st	X, r0
     faa:	11 97       	sbiw	r26, 0x01	; 1
     fac:	ac 93       	st	X, r26
     fae:	12 96       	adiw	r26, 0x02	; 2
     fb0:	0b 2e       	mov	r0, r27
     fb2:	11 96       	adiw	r26, 0x01	; 1
     fb4:	0c 92       	st	X, r0
     fb6:	11 97       	sbiw	r26, 0x01	; 1
     fb8:	ac 93       	st	X, r26
     fba:	0a 2e       	mov	r0, r26
     fbc:	1b 2e       	mov	r1, r27
     fbe:	13 96       	adiw	r26, 0x03	; 3
     fc0:	1c 92       	st	X, r1
     fc2:	0e 92       	st	-X, r0
     fc4:	11 24       	eor	r1, r1
     fc6:	12 97       	sbiw	r26, 0x02	; 2
     fc8:	cf 01       	movw	r24, r30
     fca:	df 91       	pop	r29
     fcc:	cf 91       	pop	r28
     fce:	08 95       	ret

00000fd0 <chThdCreateI>:
     fd0:	9e df       	rcall	.-196    	; 0xf0e <chThdCreateSuspendedI>
     fd2:	d2 cd       	rjmp	.-1116   	; 0xb78 <chSchReadyI>

00000fd4 <chThdCreateStatic>:
     fd4:	0f 93       	push	r16
     fd6:	1f 93       	push	r17
     fd8:	cf 93       	push	r28
     fda:	df 93       	push	r29
     fdc:	f8 94       	cli
     fde:	6e 51       	subi	r22, 0x1E	; 30
     fe0:	71 09       	sbc	r23, r1
     fe2:	ec 01       	movw	r28, r24
     fe4:	c6 0f       	add	r28, r22
     fe6:	d7 1f       	adc	r29, r23
     fe8:	fe 01       	movw	r30, r28
     fea:	75 97       	sbiw	r30, 0x15	; 21
     fec:	fe 83       	std	Y+6, r31	; 0x06
     fee:	ed 83       	std	Y+5, r30	; 0x05
     ff0:	22 8b       	std	Z+18, r18	; 0x12
     ff2:	31 8b       	std	Z+17, r19	; 0x11
     ff4:	00 8b       	std	Z+16, r16	; 0x10
     ff6:	17 87       	std	Z+15, r17	; 0x0f
     ff8:	84 e2       	ldi	r24, 0x24	; 36
     ffa:	9b e0       	ldi	r25, 0x0B	; 11
     ffc:	93 8b       	std	Z+19, r25	; 0x13
     ffe:	84 8b       	std	Z+20, r24	; 0x14
    1000:	4c 83       	std	Y+4, r20	; 0x04
    1002:	82 e0       	ldi	r24, 0x02	; 2
    1004:	8f 87       	std	Y+15, r24	; 0x0f
    1006:	18 8a       	std	Y+16, r1	; 0x10
    1008:	ea ea       	ldi	r30, 0xAA	; 170
    100a:	f6 e0       	ldi	r31, 0x06	; 6
    100c:	fc 87       	std	Y+12, r31	; 0x0c
    100e:	eb 87       	std	Y+11, r30	; 0x0b
    1010:	4d 8f       	std	Y+29, r20	; 0x1d
    1012:	1c 8e       	std	Y+28, r1	; 0x1c
    1014:	1b 8e       	std	Y+27, r1	; 0x1b
    1016:	1a 8e       	std	Y+26, r1	; 0x1a
    1018:	81 e0       	ldi	r24, 0x01	; 1
    101a:	89 8b       	std	Y+17, r24	; 0x11
    101c:	8b e2       	ldi	r24, 0x2B	; 43
    101e:	91 e0       	ldi	r25, 0x01	; 1
    1020:	9e 87       	std	Y+14, r25	; 0x0e
    1022:	8d 87       	std	Y+13, r24	; 0x0d
    1024:	ce 01       	movw	r24, r28
    1026:	07 96       	adiw	r24, 0x07	; 7
    1028:	21 ec       	ldi	r18, 0xC1	; 193
    102a:	36 e0       	ldi	r19, 0x06	; 6
    102c:	38 87       	std	Y+8, r19	; 0x08
    102e:	2f 83       	std	Y+7, r18	; 0x07
    1030:	a1 8d       	ldd	r26, Z+25	; 0x19
    1032:	b2 8d       	ldd	r27, Z+26	; 0x1a
    1034:	ba 87       	std	Y+10, r27	; 0x0a
    1036:	a9 87       	std	Y+9, r26	; 0x09
    1038:	8d 93       	st	X+, r24
    103a:	9c 93       	st	X, r25
    103c:	92 8f       	std	Z+26, r25	; 0x1a
    103e:	81 8f       	std	Z+25, r24	; 0x19
    1040:	0d 96       	adiw	r24, 0x0d	; 13
    1042:	9d 8b       	std	Y+21, r25	; 0x15
    1044:	8c 8b       	std	Y+20, r24	; 0x14
    1046:	02 96       	adiw	r24, 0x02	; 2
    1048:	9f 8b       	std	Y+23, r25	; 0x17
    104a:	8e 8b       	std	Y+22, r24	; 0x16
    104c:	99 8f       	std	Y+25, r25	; 0x19
    104e:	88 8f       	std	Y+24, r24	; 0x18
    1050:	70 e0       	ldi	r23, 0x00	; 0
    1052:	60 e0       	ldi	r22, 0x00	; 0
    1054:	ce 01       	movw	r24, r28
    1056:	06 de       	rcall	.-1012   	; 0xc64 <chSchWakeupS>
    1058:	78 94       	sei
    105a:	ce 01       	movw	r24, r28
    105c:	df 91       	pop	r29
    105e:	cf 91       	pop	r28
    1060:	1f 91       	pop	r17
    1062:	0f 91       	pop	r16
    1064:	08 95       	ret

00001066 <chThdExitS>:
    1066:	0f 93       	push	r16
    1068:	1f 93       	push	r17
    106a:	cf 93       	push	r28
    106c:	df 93       	push	r29
    106e:	c0 91 af 06 	lds	r28, 0x06AF	; 0x8006af <ch0+0x5>
    1072:	d0 91 b0 06 	lds	r29, 0x06B0	; 0x8006b0 <ch0+0x6>
    1076:	9b 8b       	std	Y+19, r25	; 0x13
    1078:	8a 8b       	std	Y+18, r24	; 0x12
    107a:	8e 01       	movw	r16, r28
    107c:	0c 5e       	subi	r16, 0xEC	; 236
    107e:	1f 4f       	sbci	r17, 0xFF	; 255
    1080:	8c 89       	ldd	r24, Y+20	; 0x14
    1082:	9d 89       	ldd	r25, Y+21	; 0x15
    1084:	08 17       	cp	r16, r24
    1086:	19 07       	cpc	r17, r25
    1088:	59 f0       	breq	.+22     	; 0x10a0 <chThdExitS+0x3a>
    108a:	fc 01       	movw	r30, r24
    108c:	20 81       	ld	r18, Z
    108e:	31 81       	ldd	r19, Z+1	; 0x01
    1090:	3d 8b       	std	Y+21, r19	; 0x15
    1092:	2c 8b       	std	Y+20, r18	; 0x14
    1094:	71 dd       	rcall	.-1310   	; 0xb78 <chSchReadyI>
    1096:	8c 89       	ldd	r24, Y+20	; 0x14
    1098:	9d 89       	ldd	r25, Y+21	; 0x15
    109a:	80 17       	cp	r24, r16
    109c:	91 07       	cpc	r25, r17
    109e:	a9 f7       	brne	.-22     	; 0x108a <chThdExitS+0x24>
    10a0:	89 89       	ldd	r24, Y+17	; 0x11
    10a2:	81 11       	cpse	r24, r1
    10a4:	0c c0       	rjmp	.+24     	; 0x10be <chThdExitS+0x58>
    10a6:	e9 85       	ldd	r30, Y+9	; 0x09
    10a8:	fa 85       	ldd	r31, Y+10	; 0x0a
    10aa:	8f 81       	ldd	r24, Y+7	; 0x07
    10ac:	98 85       	ldd	r25, Y+8	; 0x08
    10ae:	91 83       	std	Z+1, r25	; 0x01
    10b0:	80 83       	st	Z, r24
    10b2:	af 81       	ldd	r26, Y+7	; 0x07
    10b4:	b8 85       	ldd	r27, Y+8	; 0x08
    10b6:	13 96       	adiw	r26, 0x03	; 3
    10b8:	fc 93       	st	X, r31
    10ba:	ee 93       	st	-X, r30
    10bc:	12 97       	sbiw	r26, 0x02	; 2
    10be:	8f e0       	ldi	r24, 0x0F	; 15
    10c0:	df 91       	pop	r29
    10c2:	cf 91       	pop	r28
    10c4:	1f 91       	pop	r17
    10c6:	0f 91       	pop	r16
    10c8:	7b cd       	rjmp	.-1290   	; 0xbc0 <chSchGoSleepS>

000010ca <chThdExit>:
    10ca:	f8 94       	cli
    10cc:	cc cf       	rjmp	.-104    	; 0x1066 <chThdExitS>

000010ce <chThdSleep>:
    10ce:	f8 94       	cli
    10d0:	bc 01       	movw	r22, r24
    10d2:	88 e0       	ldi	r24, 0x08	; 8
    10d4:	91 dd       	rcall	.-1246   	; 0xbf8 <chSchGoSleepTimeoutS>
    10d6:	78 94       	sei
    10d8:	08 95       	ret

000010da <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
    10da:	cf 93       	push	r28
    10dc:	df 93       	push	r29
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
    10de:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <ch0+0x5>
    10e2:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <ch0+0x6>
  thread_t *currtp = chThdGetSelfX();

  if (unlikely(TIME_IMMEDIATE == timeout)) {
    10e6:	61 15       	cp	r22, r1
    10e8:	71 05       	cpc	r23, r1
    10ea:	79 f0       	breq	.+30     	; 0x110a <chThdEnqueueTimeoutS+0x30>
 *
 * @notapi
 */
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {

  p->next       = qp;
    10ec:	91 83       	std	Z+1, r25	; 0x01
    10ee:	80 83       	st	Z, r24
  p->prev       = qp->prev;
    10f0:	ec 01       	movw	r28, r24
    10f2:	aa 81       	ldd	r26, Y+2	; 0x02
    10f4:	bb 81       	ldd	r27, Y+3	; 0x03
    10f6:	b3 83       	std	Z+3, r27	; 0x03
    10f8:	a2 83       	std	Z+2, r26	; 0x02
  p->prev->next = p;
    10fa:	ed 93       	st	X+, r30
    10fc:	fc 93       	st	X, r31
  qp->prev      = p;
    10fe:	fb 83       	std	Y+3, r31	; 0x03
    1100:	ea 83       	std	Y+2, r30	; 0x02
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    1102:	84 e0       	ldi	r24, 0x04	; 4
}
    1104:	df 91       	pop	r29
    1106:	cf 91       	pop	r28
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    1108:	77 cd       	rjmp	.-1298   	; 0xbf8 <chSchGoSleepTimeoutS>
}
    110a:	8f ef       	ldi	r24, 0xFF	; 255
    110c:	9f ef       	ldi	r25, 0xFF	; 255
    110e:	df 91       	pop	r29
    1110:	cf 91       	pop	r28
    1112:	08 95       	ret

00001114 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    1114:	cf 93       	push	r28
    1116:	df 93       	push	r29
    1118:	fc 01       	movw	r30, r24
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    111a:	80 81       	ld	r24, Z
    111c:	91 81       	ldd	r25, Z+1	; 0x01

  if (ch_queue_notempty(&tqp->queue)) {
    111e:	e8 17       	cp	r30, r24
    1120:	f9 07       	cpc	r31, r25
    1122:	71 f0       	breq	.+28     	; 0x1140 <chThdDequeueNextI+0x2c>
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;

  qp->next       = p->next;
    1124:	ec 01       	movw	r28, r24
    1126:	a8 81       	ld	r26, Y
    1128:	b9 81       	ldd	r27, Y+1	; 0x01
    112a:	b1 83       	std	Z+1, r27	; 0x01
    112c:	a0 83       	st	Z, r26
  qp->next->prev = qp;
    112e:	13 96       	adiw	r26, 0x03	; 3
    1130:	fc 93       	st	X, r31
    1132:	ee 93       	st	-X, r30
    1134:	12 97       	sbiw	r26, 0x02	; 2

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
    1136:	7b 8b       	std	Y+19, r23	; 0x13
    1138:	6a 8b       	std	Y+18, r22	; 0x12
    chThdDoDequeueNextI(tqp, msg);
  }
}
    113a:	df 91       	pop	r29
    113c:	cf 91       	pop	r28
  (void) chSchReadyI(tp);
    113e:	1c cd       	rjmp	.-1480   	; 0xb78 <chSchReadyI>
    1140:	df 91       	pop	r29
    1142:	cf 91       	pop	r28
    1144:	08 95       	ret

00001146 <chMtxObjectInit>:
  mp->cnt++;
#endif
  mp->owner = currtp;
  mp->next = currtp->mtxlist;
  currtp->mtxlist = mp;
  return true;
    1146:	fc 01       	movw	r30, r24
    1148:	91 83       	std	Z+1, r25	; 0x01
    114a:	80 83       	st	Z, r24
    114c:	93 83       	std	Z+3, r25	; 0x03
    114e:	82 83       	std	Z+2, r24	; 0x02
    1150:	15 82       	std	Z+5, r1	; 0x05
    1152:	14 82       	std	Z+4, r1	; 0x04
    1154:	08 95       	ret

00001156 <chMtxLockS>:
    1156:	0f 93       	push	r16
    1158:	1f 93       	push	r17
    115a:	cf 93       	push	r28
    115c:	df 93       	push	r29
    115e:	ec 01       	movw	r28, r24
    1160:	00 91 af 06 	lds	r16, 0x06AF	; 0x8006af <ch0+0x5>
    1164:	10 91 b0 06 	lds	r17, 0x06B0	; 0x8006b0 <ch0+0x6>
    1168:	ec 81       	ldd	r30, Y+4	; 0x04
    116a:	fd 81       	ldd	r31, Y+5	; 0x05
    116c:	30 97       	sbiw	r30, 0x00	; 0
    116e:	09 f4       	brne	.+2      	; 0x1172 <chMtxLockS+0x1c>
    1170:	7e c0       	rjmp	.+252    	; 0x126e <chMtxLockS+0x118>
    1172:	d8 01       	movw	r26, r16
    1174:	14 96       	adiw	r26, 0x04	; 4
    1176:	8c 91       	ld	r24, X
    1178:	94 81       	ldd	r25, Z+4	; 0x04
    117a:	98 17       	cp	r25, r24
    117c:	50 f4       	brcc	.+20     	; 0x1192 <chMtxLockS+0x3c>
    117e:	84 83       	std	Z+4, r24	; 0x04
    1180:	87 85       	ldd	r24, Z+15	; 0x0f
    1182:	86 30       	cpi	r24, 0x06	; 6
    1184:	09 f4       	brne	.+2      	; 0x1188 <chMtxLockS+0x32>
    1186:	85 c0       	rjmp	.+266    	; 0x1292 <chMtxLockS+0x13c>
    1188:	87 30       	cpi	r24, 0x07	; 7
    118a:	71 f1       	breq	.+92     	; 0x11e8 <chMtxLockS+0x92>
    118c:	88 23       	and	r24, r24
    118e:	09 f4       	brne	.+2      	; 0x1192 <chMtxLockS+0x3c>
    1190:	5b c0       	rjmp	.+182    	; 0x1248 <chMtxLockS+0xf2>
    1192:	9e 01       	movw	r18, r28
    1194:	fe 01       	movw	r30, r28
    1196:	07 c0       	rjmp	.+14     	; 0x11a6 <chMtxLockS+0x50>
    1198:	94 81       	ldd	r25, Z+4	; 0x04
    119a:	d8 01       	movw	r26, r16
    119c:	14 96       	adiw	r26, 0x04	; 4
    119e:	8c 91       	ld	r24, X
    11a0:	98 17       	cp	r25, r24
    11a2:	08 f4       	brcc	.+2      	; 0x11a6 <chMtxLockS+0x50>
    11a4:	62 c0       	rjmp	.+196    	; 0x126a <chMtxLockS+0x114>
    11a6:	01 90       	ld	r0, Z+
    11a8:	f0 81       	ld	r31, Z
    11aa:	e0 2d       	mov	r30, r0
    11ac:	ce 17       	cp	r28, r30
    11ae:	df 07       	cpc	r29, r31
    11b0:	99 f7       	brne	.-26     	; 0x1198 <chMtxLockS+0x42>
    11b2:	f8 01       	movw	r30, r16
    11b4:	31 83       	std	Z+1, r19	; 0x01
    11b6:	20 83       	st	Z, r18
    11b8:	d9 01       	movw	r26, r18
    11ba:	12 96       	adiw	r26, 0x02	; 2
    11bc:	ed 91       	ld	r30, X+
    11be:	fc 91       	ld	r31, X
    11c0:	d8 01       	movw	r26, r16
    11c2:	13 96       	adiw	r26, 0x03	; 3
    11c4:	fc 93       	st	X, r31
    11c6:	ee 93       	st	-X, r30
    11c8:	12 97       	sbiw	r26, 0x02	; 2
    11ca:	11 83       	std	Z+1, r17	; 0x01
    11cc:	00 83       	st	Z, r16
    11ce:	f9 01       	movw	r30, r18
    11d0:	13 83       	std	Z+3, r17	; 0x03
    11d2:	02 83       	std	Z+2, r16	; 0x02
    11d4:	53 96       	adiw	r26, 0x13	; 19
    11d6:	dc 93       	st	X, r29
    11d8:	ce 93       	st	-X, r28
    11da:	52 97       	sbiw	r26, 0x12	; 18
    11dc:	86 e0       	ldi	r24, 0x06	; 6
    11de:	df 91       	pop	r29
    11e0:	cf 91       	pop	r28
    11e2:	1f 91       	pop	r17
    11e4:	0f 91       	pop	r16
    11e6:	ec cc       	rjmp	.-1576   	; 0xbc0 <chSchGoSleepS>
    11e8:	22 81       	ldd	r18, Z+2	; 0x02
    11ea:	33 81       	ldd	r19, Z+3	; 0x03
    11ec:	80 81       	ld	r24, Z
    11ee:	91 81       	ldd	r25, Z+1	; 0x01
    11f0:	d9 01       	movw	r26, r18
    11f2:	8d 93       	st	X+, r24
    11f4:	9c 93       	st	X, r25
    11f6:	80 81       	ld	r24, Z
    11f8:	91 81       	ldd	r25, Z+1	; 0x01
    11fa:	dc 01       	movw	r26, r24
    11fc:	13 96       	adiw	r26, 0x03	; 3
    11fe:	3c 93       	st	X, r19
    1200:	2e 93       	st	-X, r18
    1202:	12 97       	sbiw	r26, 0x02	; 2
    1204:	22 89       	ldd	r18, Z+18	; 0x12
    1206:	33 89       	ldd	r19, Z+19	; 0x13
    1208:	d9 01       	movw	r26, r18
    120a:	07 c0       	rjmp	.+14     	; 0x121a <chMtxLockS+0xc4>
    120c:	14 96       	adiw	r26, 0x04	; 4
    120e:	9c 91       	ld	r25, X
    1210:	14 97       	sbiw	r26, 0x04	; 4
    1212:	84 81       	ldd	r24, Z+4	; 0x04
    1214:	98 17       	cp	r25, r24
    1216:	08 f4       	brcc	.+2      	; 0x121a <chMtxLockS+0xc4>
    1218:	78 c0       	rjmp	.+240    	; 0x130a <chMtxLockS+0x1b4>
    121a:	0d 90       	ld	r0, X+
    121c:	bc 91       	ld	r27, X
    121e:	a0 2d       	mov	r26, r0
    1220:	2a 17       	cp	r18, r26
    1222:	3b 07       	cpc	r19, r27
    1224:	99 f7       	brne	.-26     	; 0x120c <chMtxLockS+0xb6>
    1226:	31 83       	std	Z+1, r19	; 0x01
    1228:	20 83       	st	Z, r18
    122a:	d9 01       	movw	r26, r18
    122c:	12 96       	adiw	r26, 0x02	; 2
    122e:	8d 91       	ld	r24, X+
    1230:	9c 91       	ld	r25, X
    1232:	93 83       	std	Z+3, r25	; 0x03
    1234:	82 83       	std	Z+2, r24	; 0x02
    1236:	dc 01       	movw	r26, r24
    1238:	ed 93       	st	X+, r30
    123a:	fc 93       	st	X, r31
    123c:	d9 01       	movw	r26, r18
    123e:	13 96       	adiw	r26, 0x03	; 3
    1240:	fc 93       	st	X, r31
    1242:	ee 93       	st	-X, r30
    1244:	12 97       	sbiw	r26, 0x02	; 2
    1246:	a5 cf       	rjmp	.-182    	; 0x1192 <chMtxLockS+0x3c>
    1248:	22 81       	ldd	r18, Z+2	; 0x02
    124a:	33 81       	ldd	r19, Z+3	; 0x03
    124c:	80 81       	ld	r24, Z
    124e:	91 81       	ldd	r25, Z+1	; 0x01
    1250:	d9 01       	movw	r26, r18
    1252:	8d 93       	st	X+, r24
    1254:	9c 93       	st	X, r25
    1256:	80 81       	ld	r24, Z
    1258:	91 81       	ldd	r25, Z+1	; 0x01
    125a:	dc 01       	movw	r26, r24
    125c:	13 96       	adiw	r26, 0x03	; 3
    125e:	3c 93       	st	X, r19
    1260:	2e 93       	st	-X, r18
    1262:	12 97       	sbiw	r26, 0x02	; 2
    1264:	cf 01       	movw	r24, r30
    1266:	88 dc       	rcall	.-1776   	; 0xb78 <chSchReadyI>
    1268:	94 cf       	rjmp	.-216    	; 0x1192 <chMtxLockS+0x3c>
    126a:	9f 01       	movw	r18, r30
    126c:	a2 cf       	rjmp	.-188    	; 0x11b2 <chMtxLockS+0x5c>
    126e:	1d 83       	std	Y+5, r17	; 0x05
    1270:	0c 83       	std	Y+4, r16	; 0x04
    1272:	d8 01       	movw	r26, r16
    1274:	5b 96       	adiw	r26, 0x1b	; 27
    1276:	8d 91       	ld	r24, X+
    1278:	9c 91       	ld	r25, X
    127a:	5c 97       	sbiw	r26, 0x1c	; 28
    127c:	9f 83       	std	Y+7, r25	; 0x07
    127e:	8e 83       	std	Y+6, r24	; 0x06
    1280:	5c 96       	adiw	r26, 0x1c	; 28
    1282:	dc 93       	st	X, r29
    1284:	ce 93       	st	-X, r28
    1286:	5b 97       	sbiw	r26, 0x1b	; 27
    1288:	df 91       	pop	r29
    128a:	cf 91       	pop	r28
    128c:	1f 91       	pop	r17
    128e:	0f 91       	pop	r16
    1290:	08 95       	ret
    1292:	22 81       	ldd	r18, Z+2	; 0x02
    1294:	33 81       	ldd	r19, Z+3	; 0x03
    1296:	80 81       	ld	r24, Z
    1298:	91 81       	ldd	r25, Z+1	; 0x01
    129a:	d9 01       	movw	r26, r18
    129c:	8d 93       	st	X+, r24
    129e:	9c 93       	st	X, r25
    12a0:	80 81       	ld	r24, Z
    12a2:	91 81       	ldd	r25, Z+1	; 0x01
    12a4:	dc 01       	movw	r26, r24
    12a6:	13 96       	adiw	r26, 0x03	; 3
    12a8:	3c 93       	st	X, r19
    12aa:	2e 93       	st	-X, r18
    12ac:	12 97       	sbiw	r26, 0x02	; 2
    12ae:	22 89       	ldd	r18, Z+18	; 0x12
    12b0:	33 89       	ldd	r19, Z+19	; 0x13
    12b2:	d9 01       	movw	r26, r18
    12b4:	06 c0       	rjmp	.+12     	; 0x12c2 <chMtxLockS+0x16c>
    12b6:	14 96       	adiw	r26, 0x04	; 4
    12b8:	9c 91       	ld	r25, X
    12ba:	14 97       	sbiw	r26, 0x04	; 4
    12bc:	84 81       	ldd	r24, Z+4	; 0x04
    12be:	98 17       	cp	r25, r24
    12c0:	30 f1       	brcs	.+76     	; 0x130e <chMtxLockS+0x1b8>
    12c2:	0d 90       	ld	r0, X+
    12c4:	bc 91       	ld	r27, X
    12c6:	a0 2d       	mov	r26, r0
    12c8:	2a 17       	cp	r18, r26
    12ca:	3b 07       	cpc	r19, r27
    12cc:	a1 f7       	brne	.-24     	; 0x12b6 <chMtxLockS+0x160>
    12ce:	31 83       	std	Z+1, r19	; 0x01
    12d0:	20 83       	st	Z, r18
    12d2:	d9 01       	movw	r26, r18
    12d4:	12 96       	adiw	r26, 0x02	; 2
    12d6:	8d 91       	ld	r24, X+
    12d8:	9c 91       	ld	r25, X
    12da:	93 83       	std	Z+3, r25	; 0x03
    12dc:	82 83       	std	Z+2, r24	; 0x02
    12de:	dc 01       	movw	r26, r24
    12e0:	ed 93       	st	X+, r30
    12e2:	fc 93       	st	X, r31
    12e4:	d9 01       	movw	r26, r18
    12e6:	13 96       	adiw	r26, 0x03	; 3
    12e8:	fc 93       	st	X, r31
    12ea:	ee 93       	st	-X, r30
    12ec:	12 97       	sbiw	r26, 0x02	; 2
    12ee:	02 88       	ldd	r0, Z+18	; 0x12
    12f0:	f3 89       	ldd	r31, Z+19	; 0x13
    12f2:	e0 2d       	mov	r30, r0
    12f4:	04 80       	ldd	r0, Z+4	; 0x04
    12f6:	f5 81       	ldd	r31, Z+5	; 0x05
    12f8:	e0 2d       	mov	r30, r0
    12fa:	d8 01       	movw	r26, r16
    12fc:	14 96       	adiw	r26, 0x04	; 4
    12fe:	8c 91       	ld	r24, X
    1300:	94 81       	ldd	r25, Z+4	; 0x04
    1302:	98 17       	cp	r25, r24
    1304:	08 f4       	brcc	.+2      	; 0x1308 <chMtxLockS+0x1b2>
    1306:	3b cf       	rjmp	.-394    	; 0x117e <chMtxLockS+0x28>
    1308:	44 cf       	rjmp	.-376    	; 0x1192 <chMtxLockS+0x3c>
    130a:	9d 01       	movw	r18, r26
    130c:	8c cf       	rjmp	.-232    	; 0x1226 <chMtxLockS+0xd0>
    130e:	9d 01       	movw	r18, r26
    1310:	de cf       	rjmp	.-68     	; 0x12ce <chMtxLockS+0x178>

00001312 <chMtxLock>:
    1312:	f8 94       	cli
    1314:	20 df       	rcall	.-448    	; 0x1156 <chMtxLockS>
    1316:	78 94       	sei
    1318:	08 95       	ret

0000131a <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
    131a:	cf 93       	push	r28
    131c:	df 93       	push	r29
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
    131e:	c0 91 af 06 	lds	r28, 0x06AF	; 0x8006af <ch0+0x5>
    1322:	d0 91 b0 06 	lds	r29, 0x06B0	; 0x8006b0 <ch0+0x6>
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1326:	f8 94       	cli
    chDbgAssert(currtp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
    1328:	dc 01       	movw	r26, r24
    132a:	16 96       	adiw	r26, 0x06	; 6
    132c:	ed 91       	ld	r30, X+
    132e:	fc 91       	ld	r31, X
    1330:	17 97       	sbiw	r26, 0x07	; 7
    1332:	fc 8f       	std	Y+28, r31	; 0x1c
    1334:	eb 8f       	std	Y+27, r30	; 0x1b

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
    1336:	2d 91       	ld	r18, X+
    1338:	3c 91       	ld	r19, X
    133a:	28 17       	cp	r18, r24
    133c:	39 07       	cpc	r19, r25
    133e:	81 f1       	breq	.+96     	; 0x13a0 <chMtxUnlock+0x86>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
    1340:	3d 8d       	ldd	r19, Y+29	; 0x1d
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    1342:	30 97       	sbiw	r30, 0x00	; 0
    1344:	79 f0       	breq	.+30     	; 0x1364 <chMtxUnlock+0x4a>
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    1346:	a0 81       	ld	r26, Z
    1348:	b1 81       	ldd	r27, Z+1	; 0x01
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    134a:	ea 17       	cp	r30, r26
    134c:	fb 07       	cpc	r31, r27
    134e:	29 f0       	breq	.+10     	; 0x135a <chMtxUnlock+0x40>
    1350:	14 96       	adiw	r26, 0x04	; 4
    1352:	2c 91       	ld	r18, X
    1354:	32 17       	cp	r19, r18
    1356:	08 f4       	brcc	.+2      	; 0x135a <chMtxUnlock+0x40>
    1358:	32 2f       	mov	r19, r18
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
        }
        lmp = lmp->next;
    135a:	06 80       	ldd	r0, Z+6	; 0x06
    135c:	f7 81       	ldd	r31, Z+7	; 0x07
    135e:	e0 2d       	mov	r30, r0

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    1360:	30 97       	sbiw	r30, 0x00	; 0
    1362:	89 f7       	brne	.-30     	; 0x1346 <chMtxUnlock+0x2c>
    1364:	fc 01       	movw	r30, r24
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
    1366:	3c 83       	std	Y+4, r19	; 0x04
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;
    1368:	a0 81       	ld	r26, Z
    136a:	b1 81       	ldd	r27, Z+1	; 0x01

  qp->next       = p->next;
    136c:	cd 91       	ld	r28, X+
    136e:	dc 91       	ld	r29, X
    1370:	11 97       	sbiw	r26, 0x01	; 1
    1372:	d1 83       	std	Z+1, r29	; 0x01
    1374:	c0 83       	st	Z, r28
  qp->next->prev = qp;
    1376:	9b 83       	std	Y+3, r25	; 0x03
    1378:	8a 83       	std	Y+2, r24	; 0x02
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
    137a:	b5 83       	std	Z+5, r27	; 0x05
    137c:	a4 83       	std	Z+4, r26	; 0x04
      mp->next = tp->mtxlist;
    137e:	5b 96       	adiw	r26, 0x1b	; 27
    1380:	8d 91       	ld	r24, X+
    1382:	9c 91       	ld	r25, X
    1384:	5c 97       	sbiw	r26, 0x1c	; 28
    1386:	97 83       	std	Z+7, r25	; 0x07
    1388:	86 83       	std	Z+6, r24	; 0x06
      tp->mtxlist = mp;
    138a:	5c 96       	adiw	r26, 0x1c	; 28
    138c:	fc 93       	st	X, r31
    138e:	ee 93       	st	-X, r30
    1390:	5b 97       	sbiw	r26, 0x1b	; 27

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
    1392:	cd 01       	movw	r24, r26
    1394:	f1 db       	rcall	.-2078   	; 0xb78 <chSchReadyI>
      chSchRescheduleS();
    1396:	03 dd       	rcall	.-1530   	; 0xd9e <chSchRescheduleS>
    1398:	78 94       	sei
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    139a:	df 91       	pop	r29
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
    139c:	cf 91       	pop	r28
    139e:	08 95       	ret
    13a0:	f9 01       	movw	r30, r18
         just changed priority.*/
      (void) chSchReadyI(tp);
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
    13a2:	15 82       	std	Z+5, r1	; 0x05
    13a4:	14 82       	std	Z+4, r1	; 0x04
    13a6:	78 94       	sei
    13a8:	df 91       	pop	r29
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
    13aa:	cf 91       	pop	r28
    13ac:	08 95       	ret

000013ae <chMtxUnlockS>:
    13ae:	cf 93       	push	r28
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
    13b0:	df 93       	push	r29
    13b2:	ec 01       	movw	r28, r24
    13b4:	20 91 af 06 	lds	r18, 0x06AF	; 0x8006af <ch0+0x5>
    13b8:	30 91 b0 06 	lds	r19, 0x06B0	; 0x8006b0 <ch0+0x6>
    chDbgAssert(currtp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
    13bc:	ee 81       	ldd	r30, Y+6	; 0x06
    13be:	ff 81       	ldd	r31, Y+7	; 0x07
    13c0:	d9 01       	movw	r26, r18
    13c2:	5c 96       	adiw	r26, 0x1c	; 28
    13c4:	fc 93       	st	X, r31
    13c6:	ee 93       	st	-X, r30
    13c8:	5b 97       	sbiw	r26, 0x1b	; 27

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
    13ca:	a8 81       	ld	r26, Y
    13cc:	b9 81       	ldd	r27, Y+1	; 0x01
    13ce:	a8 17       	cp	r26, r24
    13d0:	b9 07       	cpc	r27, r25
    13d2:	61 f1       	breq	.+88     	; 0x142c <chMtxUnlockS+0x7e>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
    13d4:	d9 01       	movw	r26, r18
    13d6:	5d 96       	adiw	r26, 0x1d	; 29
    13d8:	9c 91       	ld	r25, X
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    13da:	30 97       	sbiw	r30, 0x00	; 0
    13dc:	79 f0       	breq	.+30     	; 0x13fc <chMtxUnlockS+0x4e>
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    13de:	a0 81       	ld	r26, Z
    13e0:	b1 81       	ldd	r27, Z+1	; 0x01
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    13e2:	ea 17       	cp	r30, r26
    13e4:	fb 07       	cpc	r31, r27
    13e6:	29 f0       	breq	.+10     	; 0x13f2 <chMtxUnlockS+0x44>
    13e8:	14 96       	adiw	r26, 0x04	; 4
    13ea:	8c 91       	ld	r24, X
    13ec:	98 17       	cp	r25, r24
    13ee:	08 f4       	brcc	.+2      	; 0x13f2 <chMtxUnlockS+0x44>
    13f0:	98 2f       	mov	r25, r24
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
          newprio = threadref(lmp->queue.next)->hdr.pqueue.prio;
        }
        lmp = lmp->next;
    13f2:	06 80       	ldd	r0, Z+6	; 0x06
    13f4:	f7 81       	ldd	r31, Z+7	; 0x07
    13f6:	e0 2d       	mov	r30, r0

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    13f8:	30 97       	sbiw	r30, 0x00	; 0
    13fa:	89 f7       	brne	.-30     	; 0x13de <chMtxUnlockS+0x30>
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
    13fc:	f9 01       	movw	r30, r18
    13fe:	94 83       	std	Z+4, r25	; 0x04
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;
    1400:	e8 81       	ld	r30, Y
    1402:	f9 81       	ldd	r31, Y+1	; 0x01

  qp->next       = p->next;
    1404:	a0 81       	ld	r26, Z
    1406:	b1 81       	ldd	r27, Z+1	; 0x01
    1408:	b9 83       	std	Y+1, r27	; 0x01
    140a:	a8 83       	st	Y, r26
  qp->next->prev = qp;
    140c:	13 96       	adiw	r26, 0x03	; 3
    140e:	dc 93       	st	X, r29
    1410:	ce 93       	st	-X, r28
    1412:	12 97       	sbiw	r26, 0x02	; 2
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
    1414:	fd 83       	std	Y+5, r31	; 0x05
    1416:	ec 83       	std	Y+4, r30	; 0x04
      mp->next = tp->mtxlist;
    1418:	83 8d       	ldd	r24, Z+27	; 0x1b
    141a:	94 8d       	ldd	r25, Z+28	; 0x1c
    141c:	9f 83       	std	Y+7, r25	; 0x07
    141e:	8e 83       	std	Y+6, r24	; 0x06
      tp->mtxlist = mp;
    1420:	d4 8f       	std	Z+28, r29	; 0x1c
    1422:	c3 8f       	std	Z+27, r28	; 0x1b
      (void) chSchReadyI(tp);
    1424:	cf 01       	movw	r24, r30
      mp->owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
    1426:	df 91       	pop	r29
    1428:	cf 91       	pop	r28
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
      (void) chSchReadyI(tp);
    142a:	a6 cb       	rjmp	.-2228   	; 0xb78 <chSchReadyI>
    }
    else {
      mp->owner = NULL;
    142c:	15 96       	adiw	r26, 0x05	; 5
    142e:	1c 92       	st	X, r1
    1430:	1e 92       	st	-X, r1
    1432:	14 97       	sbiw	r26, 0x04	; 4
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
    1434:	df 91       	pop	r29
    1436:	cf 91       	pop	r28
    1438:	08 95       	ret

0000143a <chCondObjectInit>:
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (ch_queue_notempty(&cp->queue)) {
    chSchReadyI(threadref(ch_queue_fifo_remove(&cp->queue)))->u.rdymsg = MSG_RESET;
  }
}
    143a:	fc 01       	movw	r30, r24
    143c:	91 83       	std	Z+1, r25	; 0x01
    143e:	80 83       	st	Z, r24
    1440:	93 83       	std	Z+3, r25	; 0x03
    1442:	82 83       	std	Z+2, r24	; 0x02
    1444:	08 95       	ret

00001446 <chCondSignal>:
    1446:	cf 93       	push	r28
    1448:	df 93       	push	r29
    144a:	fc 01       	movw	r30, r24
    144c:	f8 94       	cli
    144e:	80 81       	ld	r24, Z
    1450:	91 81       	ldd	r25, Z+1	; 0x01
    1452:	e8 17       	cp	r30, r24
    1454:	f9 07       	cpc	r31, r25
    1456:	61 f0       	breq	.+24     	; 0x1470 <chCondSignal+0x2a>
    1458:	ec 01       	movw	r28, r24
    145a:	a8 81       	ld	r26, Y
    145c:	b9 81       	ldd	r27, Y+1	; 0x01
    145e:	b1 83       	std	Z+1, r27	; 0x01
    1460:	a0 83       	st	Z, r26
    1462:	13 96       	adiw	r26, 0x03	; 3
    1464:	fc 93       	st	X, r31
    1466:	ee 93       	st	-X, r30
    1468:	12 97       	sbiw	r26, 0x02	; 2
    146a:	70 e0       	ldi	r23, 0x00	; 0
    146c:	60 e0       	ldi	r22, 0x00	; 0
    146e:	fa db       	rcall	.-2060   	; 0xc64 <chSchWakeupS>
    1470:	78 94       	sei
    1472:	df 91       	pop	r29
    1474:	cf 91       	pop	r28
    1476:	08 95       	ret

00001478 <chCondWaitS>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
    1478:	ef 92       	push	r14
    147a:	ff 92       	push	r15
    147c:	0f 93       	push	r16
    147e:	1f 93       	push	r17
    1480:	cf 93       	push	r28
    1482:	df 93       	push	r29
    1484:	8c 01       	movw	r16, r24
    1486:	c0 91 af 06 	lds	r28, 0x06AF	; 0x8006af <ch0+0x5>
    148a:	d0 91 b0 06 	lds	r29, 0x06B0	; 0x8006b0 <ch0+0x6>
 *
 * @xclass
 */
static inline mutex_t *chMtxGetNextMutexX(void) {

  return chThdGetSelfX()->mtxlist;
    148e:	eb 8c       	ldd	r14, Y+27	; 0x1b
    1490:	fc 8c       	ldd	r15, Y+28	; 0x1c
  chDbgCheckClassS();
  chDbgCheck(cp != NULL);
  chDbgAssert(mp != NULL, "not owning a mutex");

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
    1492:	c7 01       	movw	r24, r14
    1494:	8c df       	rcall	.-232    	; 0x13ae <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currtp->u.wtobjp = cp;
    1496:	1b 8b       	std	Y+19, r17	; 0x13
    1498:	0a 8b       	std	Y+18, r16	; 0x12
  ch_sch_prio_insert(&cp->queue, &currtp->hdr.queue);
    149a:	d8 01       	movw	r26, r16
    149c:	f8 01       	movw	r30, r16
    149e:	04 c0       	rjmp	.+8      	; 0x14a8 <chCondWaitS+0x30>
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
  } while ((cp != qp) &&
    14a0:	94 81       	ldd	r25, Z+4	; 0x04
    14a2:	8c 81       	ldd	r24, Y+4	; 0x04
    14a4:	98 17       	cp	r25, r24
    14a6:	18 f1       	brcs	.+70     	; 0x14ee <chCondWaitS+0x76>
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
    14a8:	01 90       	ld	r0, Z+
    14aa:	f0 81       	ld	r31, Z
    14ac:	e0 2d       	mov	r30, r0
  } while ((cp != qp) &&
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
    14ae:	0e 17       	cp	r16, r30
    14b0:	1f 07       	cpc	r17, r31
    14b2:	b1 f7       	brne	.-20     	; 0x14a0 <chCondWaitS+0x28>
  tp->next       = cp;
    14b4:	b9 83       	std	Y+1, r27	; 0x01
    14b6:	a8 83       	st	Y, r26
  tp->prev       = cp->prev;
    14b8:	12 96       	adiw	r26, 0x02	; 2
    14ba:	ed 91       	ld	r30, X+
    14bc:	fc 91       	ld	r31, X
    14be:	13 97       	sbiw	r26, 0x03	; 3
    14c0:	fb 83       	std	Y+3, r31	; 0x03
    14c2:	ea 83       	std	Y+2, r30	; 0x02
  tp->prev->next = tp;
    14c4:	d1 83       	std	Z+1, r29	; 0x01
    14c6:	c0 83       	st	Z, r28
  cp->prev       = tp;
    14c8:	13 96       	adiw	r26, 0x03	; 3
    14ca:	dc 93       	st	X, r29
    14cc:	ce 93       	st	-X, r28
    14ce:	12 97       	sbiw	r26, 0x02	; 2
  chSchGoSleepS(CH_STATE_WTCOND);
    14d0:	87 e0       	ldi	r24, 0x07	; 7
    14d2:	76 db       	rcall	.-2324   	; 0xbc0 <chSchGoSleepS>
  msg = currtp->u.rdymsg;
    14d4:	0a 88       	ldd	r0, Y+18	; 0x12
    14d6:	db 89       	ldd	r29, Y+19	; 0x13
  chMtxLockS(mp);
    14d8:	c0 2d       	mov	r28, r0
    14da:	c7 01       	movw	r24, r14
    14dc:	3c de       	rcall	.-904    	; 0x1156 <chMtxLockS>

  return msg;
}
    14de:	ce 01       	movw	r24, r28
    14e0:	df 91       	pop	r29
    14e2:	cf 91       	pop	r28
    14e4:	1f 91       	pop	r17
    14e6:	0f 91       	pop	r16
    14e8:	ff 90       	pop	r15
    14ea:	ef 90       	pop	r14
    14ec:	08 95       	ret
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
    14ee:	df 01       	movw	r26, r30
    14f0:	e1 cf       	rjmp	.-62     	; 0x14b4 <chCondWaitS+0x3c>

000014f2 <chCondWait>:
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    14f2:	f8 94       	cli
 */
msg_t chCondWait(condition_variable_t *cp) {
  msg_t msg;

  chSysLock();
  msg = chCondWaitS(cp);
    14f4:	c1 df       	rcall	.-126    	; 0x1478 <chCondWaitS>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    14f6:	78 94       	sei
  chSysUnlock();
  return msg;
}
    14f8:	08 95       	ret

000014fa <chEvtSignalI>:

  chSysLock();
  chEvtSignalI(tp, events);
  chSchRescheduleS();
  chSysUnlock();
}
    14fa:	fc 01       	movw	r30, r24
    14fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    14fe:	68 2b       	or	r22, r24
    1500:	62 8f       	std	Z+26, r22	; 0x1a
    1502:	87 85       	ldd	r24, Z+15	; 0x0f
    1504:	8a 30       	cpi	r24, 0x0A	; 10
    1506:	59 f0       	breq	.+22     	; 0x151e <chEvtSignalI+0x24>
    1508:	8b 30       	cpi	r24, 0x0B	; 11
    150a:	09 f0       	breq	.+2      	; 0x150e <chEvtSignalI+0x14>
    150c:	08 95       	ret
    150e:	82 89       	ldd	r24, Z+18	; 0x12
    1510:	68 23       	and	r22, r24
    1512:	86 13       	cpse	r24, r22
    1514:	fb cf       	rjmp	.-10     	; 0x150c <chEvtSignalI+0x12>
    1516:	13 8a       	std	Z+19, r1	; 0x13
    1518:	12 8a       	std	Z+18, r1	; 0x12
    151a:	cf 01       	movw	r24, r30
    151c:	2d cb       	rjmp	.-2470   	; 0xb78 <chSchReadyI>
    151e:	82 89       	ldd	r24, Z+18	; 0x12
    1520:	68 23       	and	r22, r24
    1522:	c9 f7       	brne	.-14     	; 0x1516 <chEvtSignalI+0x1c>
    1524:	08 95       	ret

00001526 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
    1526:	ef 92       	push	r14
    1528:	ff 92       	push	r15
    152a:	1f 93       	push	r17
    152c:	cf 93       	push	r28
    152e:	df 93       	push	r29
    1530:	7c 01       	movw	r14, r24
    1532:	16 2f       	mov	r17, r22
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
    1534:	fc 01       	movw	r30, r24
    1536:	c0 81       	ld	r28, Z
    1538:	d1 81       	ldd	r29, Z+1	; 0x01
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    153a:	8c 17       	cp	r24, r28
    153c:	9d 07       	cpc	r25, r29
    153e:	91 f0       	breq	.+36     	; 0x1564 <chEvtBroadcastFlagsI+0x3e>
  /*lint -restore*/
    elp->flags |= flags;
    1540:	8d 81       	ldd	r24, Y+5	; 0x05
    1542:	81 2b       	or	r24, r17
    1544:	8d 83       	std	Y+5, r24	; 0x05
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    1546:	11 23       	and	r17, r17
    1548:	19 f0       	breq	.+6      	; 0x1550 <chEvtBroadcastFlagsI+0x2a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
    154a:	8e 81       	ldd	r24, Y+6	; 0x06
    154c:	81 23       	and	r24, r17
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    154e:	21 f0       	breq	.+8      	; 0x1558 <chEvtBroadcastFlagsI+0x32>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    1550:	6c 81       	ldd	r22, Y+4	; 0x04
    1552:	8a 81       	ldd	r24, Y+2	; 0x02
    1554:	9b 81       	ldd	r25, Y+3	; 0x03
    1556:	d1 df       	rcall	.-94     	; 0x14fa <chEvtSignalI>
    }
    elp = elp->next;
    1558:	09 90       	ld	r0, Y+
    155a:	d8 81       	ld	r29, Y
    155c:	c0 2d       	mov	r28, r0
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    155e:	ec 16       	cp	r14, r28
    1560:	fd 06       	cpc	r15, r29
    1562:	71 f7       	brne	.-36     	; 0x1540 <chEvtBroadcastFlagsI+0x1a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
  }
}
    1564:	df 91       	pop	r29
    1566:	cf 91       	pop	r28
    1568:	1f 91       	pop	r17
    156a:	ff 90       	pop	r15
    156c:	ef 90       	pop	r14
    156e:	08 95       	ret

00001570 <__core_init>:
  chSysLock();
  p = chCoreAllocFromBaseI(size, align, offset);
  chSysUnlock();

  return p;
}
    1570:	ed ee       	ldi	r30, 0xED	; 237
    1572:	f6 e0       	ldi	r31, 0x06	; 6
    1574:	8b ef       	ldi	r24, 0xFB	; 251
    1576:	91 e0       	ldi	r25, 0x01	; 1
    1578:	91 83       	std	Z+1, r25	; 0x01
    157a:	80 83       	st	Z, r24
    157c:	8b e7       	ldi	r24, 0x7B	; 123
    157e:	92 e0       	ldi	r25, 0x02	; 2
    1580:	93 83       	std	Z+3, r25	; 0x03
    1582:	82 83       	std	Z+2, r24	; 0x02
    1584:	08 95       	ret

00001586 <chCoreAllocFromTop>:
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1586:	f8 94       	cli
  uint8_t *p, *prev;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
    1588:	e0 91 ef 06 	lds	r30, 0x06EF	; 0x8006ef <ch_memcore+0x2>
    158c:	f0 91 f0 06 	lds	r31, 0x06F0	; 0x8006f0 <ch_memcore+0x3>
    1590:	9f 01       	movw	r18, r30
    1592:	28 1b       	sub	r18, r24
    1594:	39 0b       	sbc	r19, r25
    1596:	c9 01       	movw	r24, r18
    1598:	71 95       	neg	r23
    159a:	61 95       	neg	r22
    159c:	71 09       	sbc	r23, r1
    159e:	86 23       	and	r24, r22
    15a0:	97 23       	and	r25, r23
  prev = p - offset;
    15a2:	9c 01       	movw	r18, r24
    15a4:	24 1b       	sub	r18, r20
    15a6:	35 0b       	sbc	r19, r21

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
    15a8:	40 91 ed 06 	lds	r20, 0x06ED	; 0x8006ed <ch_memcore>
    15ac:	50 91 ee 06 	lds	r21, 0x06EE	; 0x8006ee <ch_memcore+0x1>
    15b0:	24 17       	cp	r18, r20
    15b2:	35 07       	cpc	r19, r21
    15b4:	48 f0       	brcs	.+18     	; 0x15c8 <chCoreAllocFromTop+0x42>
    15b6:	e2 17       	cp	r30, r18
    15b8:	f3 07       	cpc	r31, r19
    15ba:	30 f0       	brcs	.+12     	; 0x15c8 <chCoreAllocFromTop+0x42>
    return NULL;
  }

  ch_memcore.topmem = prev;
    15bc:	30 93 f0 06 	sts	0x06F0, r19	; 0x8006f0 <ch_memcore+0x3>
    15c0:	20 93 ef 06 	sts	0x06EF, r18	; 0x8006ef <ch_memcore+0x2>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    15c4:	78 94       	sei
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
    15c6:	08 95       	ret
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
  prev = p - offset;

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
    return NULL;
    15c8:	90 e0       	ldi	r25, 0x00	; 0
    15ca:	80 e0       	ldi	r24, 0x00	; 0
    15cc:	78 94       	sei
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
    15ce:	08 95       	ret

000015d0 <__heap_init>:
 *
 * @notapi
 */
void __heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
    15d0:	eb e7       	ldi	r30, 0x7B	; 123
    15d2:	f2 e0       	ldi	r31, 0x02	; 2
    15d4:	83 ec       	ldi	r24, 0xC3	; 195
    15d6:	9a e0       	ldi	r25, 0x0A	; 10
    15d8:	91 83       	std	Z+1, r25	; 0x01
    15da:	80 83       	st	Z, r24
  H_NEXT(&default_heap.header) = NULL;
    15dc:	13 82       	std	Z+3, r1	; 0x03
    15de:	12 82       	std	Z+2, r1	; 0x02
  H_PAGES(&default_heap.header) = 0;
    15e0:	15 82       	std	Z+5, r1	; 0x05
    15e2:	14 82       	std	Z+4, r1	; 0x04
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
    15e4:	81 e8       	ldi	r24, 0x81	; 129
    15e6:	92 e0       	ldi	r25, 0x02	; 2
    15e8:	ae cd       	rjmp	.-1188   	; 0x1146 <chMtxObjectInit>

000015ea <_port_switch>:
void _port_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;
  (void)otp;

  asm volatile ("push    r2");
    15ea:	2f 92       	push	r2
  asm volatile ("push    r3");
    15ec:	3f 92       	push	r3
  asm volatile ("push    r4");
    15ee:	4f 92       	push	r4
  asm volatile ("push    r5");
    15f0:	5f 92       	push	r5
  asm volatile ("push    r6");
    15f2:	6f 92       	push	r6
  asm volatile ("push    r7");
    15f4:	7f 92       	push	r7
  asm volatile ("push    r8");
    15f6:	8f 92       	push	r8
  asm volatile ("push    r9");
    15f8:	9f 92       	push	r9
  asm volatile ("push    r10");
    15fa:	af 92       	push	r10
  asm volatile ("push    r11");
    15fc:	bf 92       	push	r11
  asm volatile ("push    r12");
    15fe:	cf 92       	push	r12
  asm volatile ("push    r13");
    1600:	df 92       	push	r13
  asm volatile ("push    r14");
    1602:	ef 92       	push	r14
  asm volatile ("push    r15");
    1604:	ff 92       	push	r15
  asm volatile ("push    r16");
    1606:	0f 93       	push	r16
  asm volatile ("push    r17");
    1608:	1f 93       	push	r17
  asm volatile ("push    r28");
    160a:	cf 93       	push	r28
  asm volatile ("push    r29");
    160c:	df 93       	push	r29

#if defined(__CHIBIOS_RT__)
  asm volatile ("movw    r30, r22");
    160e:	fb 01       	movw	r30, r22
  asm volatile ("in      r0, 0x3d");
    1610:	0d b6       	in	r0, 0x3d	; 61
  asm volatile ("std     Z+5, r0");
    1612:	05 82       	std	Z+5, r0	; 0x05
  asm volatile ("in      r0, 0x3e");
    1614:	0e b6       	in	r0, 0x3e	; 62
  asm volatile ("std     Z+6, r0");
    1616:	06 82       	std	Z+6, r0	; 0x06

  asm volatile ("movw    r30, r24");
    1618:	fc 01       	movw	r30, r24
  asm volatile ("ldd     r0, Z+5");
    161a:	05 80       	ldd	r0, Z+5	; 0x05
  asm volatile ("out     0x3d, r0");
    161c:	0d be       	out	0x3d, r0	; 61
  asm volatile ("ldd     r0, Z+6");
    161e:	06 80       	ldd	r0, Z+6	; 0x06
  asm volatile ("out     0x3e, r0");
    1620:	0e be       	out	0x3e, r0	; 62
  asm volatile ("out     0x3d, r0");
  asm volatile ("ldd     r0, Z+1");
  asm volatile ("out     0x3e, r0");
#endif

  asm volatile ("pop     r29");
    1622:	df 91       	pop	r29
  asm volatile ("pop     r28");
    1624:	cf 91       	pop	r28
  asm volatile ("pop     r17");
    1626:	1f 91       	pop	r17
  asm volatile ("pop     r16");
    1628:	0f 91       	pop	r16
  asm volatile ("pop     r15");
    162a:	ff 90       	pop	r15
  asm volatile ("pop     r14");
    162c:	ef 90       	pop	r14
  asm volatile ("pop     r13");
    162e:	df 90       	pop	r13
  asm volatile ("pop     r12");
    1630:	cf 90       	pop	r12
  asm volatile ("pop     r11");
    1632:	bf 90       	pop	r11
  asm volatile ("pop     r10");
    1634:	af 90       	pop	r10
  asm volatile ("pop     r9");
    1636:	9f 90       	pop	r9
  asm volatile ("pop     r8");
    1638:	8f 90       	pop	r8
  asm volatile ("pop     r7");
    163a:	7f 90       	pop	r7
  asm volatile ("pop     r6");
    163c:	6f 90       	pop	r6
  asm volatile ("pop     r5");
    163e:	5f 90       	pop	r5
  asm volatile ("pop     r4");
    1640:	4f 90       	pop	r4
  asm volatile ("pop     r3");
    1642:	3f 90       	pop	r3
  asm volatile ("pop     r2");
    1644:	2f 90       	pop	r2
  asm volatile ("ret");
    1646:	08 95       	ret

00001648 <_port_thread_start>:
    1648:	78 94       	sei
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
  asm volatile ("movw    r24, r4");
    164a:	c2 01       	movw	r24, r4
  asm volatile ("movw    r30, r2");
    164c:	f1 01       	movw	r30, r2
  asm volatile ("icall");
    164e:	09 95       	icall
  asm volatile ("call    chThdExit");  /* Used for avr5 Architecture. */
    1650:	3c cd       	rjmp	.-1416   	; 0x10ca <chThdExit>
}
    1652:	08 95       	ret

00001654 <Via_Pedestre_Sinal_Verde>:
}

int IsBufferFull()
{
  return qsize >= QUEUE_SIZE;
}
    1654:	cf 93       	push	r28
    1656:	df 93       	push	r29
    1658:	ec 01       	movw	r28, r24
    165a:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <counter>
    165e:	90 91 36 05 	lds	r25, 0x0536	; 0x800536 <counter+0x1>
    1662:	a0 91 37 05 	lds	r26, 0x0537	; 0x800537 <counter+0x2>
    1666:	b0 91 38 05 	lds	r27, 0x0538	; 0x800538 <counter+0x3>
    166a:	01 96       	adiw	r24, 0x01	; 1
    166c:	a1 1d       	adc	r26, r1
    166e:	b1 1d       	adc	r27, r1
    1670:	83 30       	cpi	r24, 0x03	; 3
    1672:	91 05       	cpc	r25, r1
    1674:	a1 05       	cpc	r26, r1
    1676:	b1 05       	cpc	r27, r1
    1678:	28 f1       	brcs	.+74     	; 0x16c4 <Via_Pedestre_Sinal_Verde+0x70>
    167a:	10 92 35 05 	sts	0x0535, r1	; 0x800535 <counter>
    167e:	10 92 36 05 	sts	0x0536, r1	; 0x800536 <counter+0x1>
    1682:	10 92 37 05 	sts	0x0537, r1	; 0x800537 <counter+0x2>
    1686:	10 92 38 05 	sts	0x0538, r1	; 0x800538 <counter+0x3>
    168a:	83 e0       	ldi	r24, 0x03	; 3
    168c:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <STATE>
    1690:	81 e0       	ldi	r24, 0x01	; 1
    1692:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
    1696:	f8 94       	cli
    1698:	88 81       	ld	r24, Y
    169a:	99 81       	ldd	r25, Y+1	; 0x01
    169c:	89 2b       	or	r24, r25
    169e:	11 f0       	breq	.+4      	; 0x16a4 <Via_Pedestre_Sinal_Verde+0x50>
    16a0:	ce 01       	movw	r24, r28
    16a2:	83 d9       	rcall	.-3322   	; 0x9aa <chVTDoResetI>
    16a4:	78 94       	sei
    16a6:	88 81       	ld	r24, Y
    16a8:	99 81       	ldd	r25, Y+1	; 0x01
    16aa:	89 2b       	or	r24, r25
    16ac:	11 f0       	breq	.+4      	; 0x16b2 <Via_Pedestre_Sinal_Verde+0x5e>
    16ae:	ce 01       	movw	r24, r28
    16b0:	7c d9       	rcall	.-3336   	; 0x9aa <chVTDoResetI>
    16b2:	9e 01       	movw	r18, r28
    16b4:	4a e2       	ldi	r20, 0x2A	; 42
    16b6:	5b e0       	ldi	r21, 0x0B	; 11
    16b8:	68 e0       	ldi	r22, 0x08	; 8
    16ba:	7d e3       	ldi	r23, 0x3D	; 61
    16bc:	ce 01       	movw	r24, r28
    16be:	df 91       	pop	r29
    16c0:	cf 91       	pop	r28
    16c2:	31 c9       	rjmp	.-3486   	; 0x926 <chVTDoSetI>
    16c4:	80 93 35 05 	sts	0x0535, r24	; 0x800535 <counter>
    16c8:	90 93 36 05 	sts	0x0536, r25	; 0x800536 <counter+0x1>
    16cc:	a0 93 37 05 	sts	0x0537, r26	; 0x800537 <counter+0x2>
    16d0:	b0 93 38 05 	sts	0x0538, r27	; 0x800538 <counter+0x3>
    16d4:	e8 cf       	rjmp	.-48     	; 0x16a6 <Via_Pedestre_Sinal_Verde+0x52>

000016d6 <Avenida_Secundaria_Sinal_Verde>:
    16d6:	cf 93       	push	r28
    16d8:	df 93       	push	r29
    16da:	ec 01       	movw	r28, r24
    16dc:	80 91 34 05 	lds	r24, 0x0534	; 0x800534 <amb_sec>
    16e0:	81 11       	cpse	r24, r1
    16e2:	20 c0       	rjmp	.+64     	; 0x1724 <Avenida_Secundaria_Sinal_Verde+0x4e>
    16e4:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <counter>
    16e8:	90 91 36 05 	lds	r25, 0x0536	; 0x800536 <counter+0x1>
    16ec:	a0 91 37 05 	lds	r26, 0x0537	; 0x800537 <counter+0x2>
    16f0:	b0 91 38 05 	lds	r27, 0x0538	; 0x800538 <counter+0x3>
    16f4:	01 96       	adiw	r24, 0x01	; 1
    16f6:	a1 1d       	adc	r26, r1
    16f8:	b1 1d       	adc	r27, r1
    16fa:	86 30       	cpi	r24, 0x06	; 6
    16fc:	91 05       	cpc	r25, r1
    16fe:	a1 05       	cpc	r26, r1
    1700:	b1 05       	cpc	r27, r1
    1702:	f8 f4       	brcc	.+62     	; 0x1742 <Avenida_Secundaria_Sinal_Verde+0x6c>
    1704:	80 93 35 05 	sts	0x0535, r24	; 0x800535 <counter>
    1708:	90 93 36 05 	sts	0x0536, r25	; 0x800536 <counter+0x1>
    170c:	a0 93 37 05 	sts	0x0537, r26	; 0x800537 <counter+0x2>
    1710:	b0 93 38 05 	sts	0x0538, r27	; 0x800538 <counter+0x3>
    1714:	05 97       	sbiw	r24, 0x05	; 5
    1716:	a1 05       	cpc	r26, r1
    1718:	b1 05       	cpc	r27, r1
    171a:	20 f0       	brcs	.+8      	; 0x1724 <Avenida_Secundaria_Sinal_Verde+0x4e>
    171c:	80 91 33 05 	lds	r24, 0x0533	; 0x800533 <amb_pri>
    1720:	81 30       	cpi	r24, 0x01	; 1
    1722:	71 f1       	breq	.+92     	; 0x1780 <Avenida_Secundaria_Sinal_Verde+0xaa>
    1724:	88 81       	ld	r24, Y
    1726:	99 81       	ldd	r25, Y+1	; 0x01
    1728:	89 2b       	or	r24, r25
    172a:	11 f0       	breq	.+4      	; 0x1730 <Avenida_Secundaria_Sinal_Verde+0x5a>
    172c:	ce 01       	movw	r24, r28
    172e:	3d d9       	rcall	.-3462   	; 0x9aa <chVTDoResetI>
    1730:	9e 01       	movw	r18, r28
    1732:	4b e6       	ldi	r20, 0x6B	; 107
    1734:	5b e0       	ldi	r21, 0x0B	; 11
    1736:	68 e0       	ldi	r22, 0x08	; 8
    1738:	7d e3       	ldi	r23, 0x3D	; 61
    173a:	ce 01       	movw	r24, r28
    173c:	df 91       	pop	r29
    173e:	cf 91       	pop	r28
    1740:	f2 c8       	rjmp	.-3612   	; 0x926 <chVTDoSetI>
    1742:	10 92 35 05 	sts	0x0535, r1	; 0x800535 <counter>
    1746:	10 92 36 05 	sts	0x0536, r1	; 0x800536 <counter+0x1>
    174a:	10 92 37 05 	sts	0x0537, r1	; 0x800537 <counter+0x2>
    174e:	10 92 38 05 	sts	0x0538, r1	; 0x800538 <counter+0x3>
    1752:	82 e0       	ldi	r24, 0x02	; 2
    1754:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <STATE>
    1758:	81 e0       	ldi	r24, 0x01	; 1
    175a:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <LED_SECUNDARIA>
    175e:	f8 94       	cli
    1760:	88 81       	ld	r24, Y
    1762:	99 81       	ldd	r25, Y+1	; 0x01
    1764:	89 2b       	or	r24, r25
    1766:	11 f0       	breq	.+4      	; 0x176c <Avenida_Secundaria_Sinal_Verde+0x96>
    1768:	ce 01       	movw	r24, r28
    176a:	1f d9       	rcall	.-3522   	; 0x9aa <chVTDoResetI>
    176c:	78 94       	sei
    176e:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <counter>
    1772:	90 91 36 05 	lds	r25, 0x0536	; 0x800536 <counter+0x1>
    1776:	a0 91 37 05 	lds	r26, 0x0537	; 0x800537 <counter+0x2>
    177a:	b0 91 38 05 	lds	r27, 0x0538	; 0x800538 <counter+0x3>
    177e:	ca cf       	rjmp	.-108    	; 0x1714 <Avenida_Secundaria_Sinal_Verde+0x3e>
    1780:	10 92 35 05 	sts	0x0535, r1	; 0x800535 <counter>
    1784:	10 92 36 05 	sts	0x0536, r1	; 0x800536 <counter+0x1>
    1788:	10 92 37 05 	sts	0x0537, r1	; 0x800537 <counter+0x2>
    178c:	10 92 38 05 	sts	0x0538, r1	; 0x800538 <counter+0x3>
    1790:	5d 98       	cbi	0x0b, 5	; 11
    1792:	92 e0       	ldi	r25, 0x02	; 2
    1794:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <STATE>
    1798:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <LED_SECUNDARIA>
    179c:	f8 94       	cli
    179e:	88 81       	ld	r24, Y
    17a0:	99 81       	ldd	r25, Y+1	; 0x01
    17a2:	89 2b       	or	r24, r25
    17a4:	11 f0       	breq	.+4      	; 0x17aa <Avenida_Secundaria_Sinal_Verde+0xd4>
    17a6:	ce 01       	movw	r24, r28
    17a8:	00 d9       	rcall	.-3584   	; 0x9aa <chVTDoResetI>
    17aa:	78 94       	sei
    17ac:	bb cf       	rjmp	.-138    	; 0x1724 <Avenida_Secundaria_Sinal_Verde+0x4e>

000017ae <Via_Pedestre_Sinal_Amarelo>:
    17ae:	cf 93       	push	r28
    17b0:	df 93       	push	r29
    17b2:	ec 01       	movw	r28, r24
    17b4:	88 b1       	in	r24, 0x08	; 8
    17b6:	21 e0       	ldi	r18, 0x01	; 1
    17b8:	82 27       	eor	r24, r18
    17ba:	88 b9       	out	0x08, r24	; 8
    17bc:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <counter>
    17c0:	90 91 36 05 	lds	r25, 0x0536	; 0x800536 <counter+0x1>
    17c4:	a0 91 37 05 	lds	r26, 0x0537	; 0x800537 <counter+0x2>
    17c8:	b0 91 38 05 	lds	r27, 0x0538	; 0x800538 <counter+0x3>
    17cc:	01 96       	adiw	r24, 0x01	; 1
    17ce:	a1 1d       	adc	r26, r1
    17d0:	b1 1d       	adc	r27, r1
    17d2:	84 30       	cpi	r24, 0x04	; 4
    17d4:	91 05       	cpc	r25, r1
    17d6:	a1 05       	cpc	r26, r1
    17d8:	b1 05       	cpc	r27, r1
    17da:	68 f1       	brcs	.+90     	; 0x1836 <Via_Pedestre_Sinal_Amarelo+0x88>
    17dc:	10 92 35 05 	sts	0x0535, r1	; 0x800535 <counter>
    17e0:	10 92 36 05 	sts	0x0536, r1	; 0x800536 <counter+0x1>
    17e4:	10 92 37 05 	sts	0x0537, r1	; 0x800537 <counter+0x2>
    17e8:	10 92 38 05 	sts	0x0538, r1	; 0x800538 <counter+0x3>
    17ec:	80 91 32 05 	lds	r24, 0x0532	; 0x800532 <ped_sec>
    17f0:	81 fd       	sbrc	r24, 1
    17f2:	2a c0       	rjmp	.+84     	; 0x1848 <Via_Pedestre_Sinal_Amarelo+0x9a>
    17f4:	82 fd       	sbrc	r24, 2
    17f6:	2f c0       	rjmp	.+94     	; 0x1856 <Via_Pedestre_Sinal_Amarelo+0xa8>
    17f8:	81 e0       	ldi	r24, 0x01	; 1
    17fa:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <STATE>
    17fe:	10 92 39 05 	sts	0x0539, r1	; 0x800539 <LED_PRINCIPAL>
    1802:	40 9a       	sbi	0x08, 0	; 8
    1804:	10 92 3b 05 	sts	0x053B, r1	; 0x80053b <EVENT>
    1808:	f8 94       	cli
    180a:	88 81       	ld	r24, Y
    180c:	99 81       	ldd	r25, Y+1	; 0x01
    180e:	89 2b       	or	r24, r25
    1810:	11 f0       	breq	.+4      	; 0x1816 <Via_Pedestre_Sinal_Amarelo+0x68>
    1812:	ce 01       	movw	r24, r28
    1814:	ca d8       	rcall	.-3692   	; 0x9aa <chVTDoResetI>
    1816:	78 94       	sei
    1818:	88 81       	ld	r24, Y
    181a:	99 81       	ldd	r25, Y+1	; 0x01
    181c:	89 2b       	or	r24, r25
    181e:	11 f0       	breq	.+4      	; 0x1824 <Via_Pedestre_Sinal_Amarelo+0x76>
    1820:	ce 01       	movw	r24, r28
    1822:	c3 d8       	rcall	.-3706   	; 0x9aa <chVTDoResetI>
    1824:	9e 01       	movw	r18, r28
    1826:	47 ed       	ldi	r20, 0xD7	; 215
    1828:	5b e0       	ldi	r21, 0x0B	; 11
    182a:	64 e8       	ldi	r22, 0x84	; 132
    182c:	7e e1       	ldi	r23, 0x1E	; 30
    182e:	ce 01       	movw	r24, r28
    1830:	df 91       	pop	r29
    1832:	cf 91       	pop	r28
    1834:	78 c8       	rjmp	.-3856   	; 0x926 <chVTDoSetI>
    1836:	80 93 35 05 	sts	0x0535, r24	; 0x800535 <counter>
    183a:	90 93 36 05 	sts	0x0536, r25	; 0x800536 <counter+0x1>
    183e:	a0 93 37 05 	sts	0x0537, r26	; 0x800537 <counter+0x2>
    1842:	b0 93 38 05 	sts	0x0538, r27	; 0x800538 <counter+0x3>
    1846:	e8 cf       	rjmp	.-48     	; 0x1818 <Via_Pedestre_Sinal_Amarelo+0x6a>
    1848:	10 92 32 05 	sts	0x0532, r1	; 0x800532 <ped_sec>
    184c:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <STATE>
    1850:	10 92 39 05 	sts	0x0539, r1	; 0x800539 <LED_PRINCIPAL>
    1854:	d6 cf       	rjmp	.-84     	; 0x1802 <Via_Pedestre_Sinal_Amarelo+0x54>
    1856:	80 91 3b 05 	lds	r24, 0x053B	; 0x80053b <EVENT>
    185a:	83 30       	cpi	r24, 0x03	; 3
    185c:	69 f6       	brne	.-102    	; 0x17f8 <Via_Pedestre_Sinal_Amarelo+0x4a>
    185e:	82 e0       	ldi	r24, 0x02	; 2
    1860:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <STATE>
    1864:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <LED_SECUNDARIA>
    1868:	cc cf       	rjmp	.-104    	; 0x1802 <Via_Pedestre_Sinal_Amarelo+0x54>

0000186a <Avenida_Secundaria_Sinal_Amarelo>:
    186a:	cf 93       	push	r28
    186c:	df 93       	push	r29
    186e:	ec 01       	movw	r28, r24
    1870:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <counter>
    1874:	90 91 36 05 	lds	r25, 0x0536	; 0x800536 <counter+0x1>
    1878:	a0 91 37 05 	lds	r26, 0x0537	; 0x800537 <counter+0x2>
    187c:	b0 91 38 05 	lds	r27, 0x0538	; 0x800538 <counter+0x3>
    1880:	01 96       	adiw	r24, 0x01	; 1
    1882:	a1 1d       	adc	r26, r1
    1884:	b1 1d       	adc	r27, r1
    1886:	82 30       	cpi	r24, 0x02	; 2
    1888:	91 05       	cpc	r25, r1
    188a:	a1 05       	cpc	r26, r1
    188c:	b1 05       	cpc	r27, r1
    188e:	08 f4       	brcc	.+2      	; 0x1892 <Avenida_Secundaria_Sinal_Amarelo+0x28>
    1890:	40 c0       	rjmp	.+128    	; 0x1912 <Avenida_Secundaria_Sinal_Amarelo+0xa8>
    1892:	10 92 35 05 	sts	0x0535, r1	; 0x800535 <counter>
    1896:	10 92 36 05 	sts	0x0536, r1	; 0x800536 <counter+0x1>
    189a:	10 92 37 05 	sts	0x0537, r1	; 0x800537 <counter+0x2>
    189e:	10 92 38 05 	sts	0x0538, r1	; 0x800538 <counter+0x3>
    18a2:	5d 98       	cbi	0x0b, 5	; 11
    18a4:	5c 98       	cbi	0x0b, 4	; 11
    18a6:	5b 9a       	sbi	0x0b, 3	; 11
    18a8:	80 91 33 05 	lds	r24, 0x0533	; 0x800533 <amb_pri>
    18ac:	81 30       	cpi	r24, 0x01	; 1
    18ae:	a1 f0       	breq	.+40     	; 0x18d8 <Avenida_Secundaria_Sinal_Amarelo+0x6e>
    18b0:	80 91 32 05 	lds	r24, 0x0532	; 0x800532 <ped_sec>
    18b4:	82 fd       	sbrc	r24, 2
    18b6:	0d c0       	rjmp	.+26     	; 0x18d2 <Avenida_Secundaria_Sinal_Amarelo+0x68>
    18b8:	90 91 3b 05 	lds	r25, 0x053B	; 0x80053b <EVENT>
    18bc:	94 30       	cpi	r25, 0x04	; 4
    18be:	81 f4       	brne	.+32     	; 0x18e0 <Avenida_Secundaria_Sinal_Amarelo+0x76>
    18c0:	82 60       	ori	r24, 0x02	; 2
    18c2:	80 93 32 05 	sts	0x0532, r24	; 0x800532 <ped_sec>
    18c6:	83 e0       	ldi	r24, 0x03	; 3
    18c8:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <STATE>
    18cc:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__DATA_REGION_ORIGIN__>
    18d0:	07 c0       	rjmp	.+14     	; 0x18e0 <Avenida_Secundaria_Sinal_Amarelo+0x76>
    18d2:	10 92 32 05 	sts	0x0532, r1	; 0x800532 <ped_sec>
    18d6:	81 e0       	ldi	r24, 0x01	; 1
    18d8:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <STATE>
    18dc:	10 92 39 05 	sts	0x0539, r1	; 0x800539 <LED_PRINCIPAL>
    18e0:	10 92 3b 05 	sts	0x053B, r1	; 0x80053b <EVENT>
    18e4:	f8 94       	cli
    18e6:	88 81       	ld	r24, Y
    18e8:	99 81       	ldd	r25, Y+1	; 0x01
    18ea:	89 2b       	or	r24, r25
    18ec:	11 f0       	breq	.+4      	; 0x18f2 <Avenida_Secundaria_Sinal_Amarelo+0x88>
    18ee:	ce 01       	movw	r24, r28
    18f0:	5c d8       	rcall	.-3912   	; 0x9aa <chVTDoResetI>
    18f2:	78 94       	sei
    18f4:	88 81       	ld	r24, Y
    18f6:	99 81       	ldd	r25, Y+1	; 0x01
    18f8:	89 2b       	or	r24, r25
    18fa:	11 f0       	breq	.+4      	; 0x1900 <Avenida_Secundaria_Sinal_Amarelo+0x96>
    18fc:	ce 01       	movw	r24, r28
    18fe:	55 d8       	rcall	.-3926   	; 0x9aa <chVTDoResetI>
    1900:	9e 01       	movw	r18, r28
    1902:	45 e3       	ldi	r20, 0x35	; 53
    1904:	5c e0       	ldi	r21, 0x0C	; 12
    1906:	68 e0       	ldi	r22, 0x08	; 8
    1908:	7d e3       	ldi	r23, 0x3D	; 61
    190a:	ce 01       	movw	r24, r28
    190c:	df 91       	pop	r29
    190e:	cf 91       	pop	r28
    1910:	0a c8       	rjmp	.-4076   	; 0x926 <chVTDoSetI>
    1912:	80 93 35 05 	sts	0x0535, r24	; 0x800535 <counter>
    1916:	90 93 36 05 	sts	0x0536, r25	; 0x800536 <counter+0x1>
    191a:	a0 93 37 05 	sts	0x0537, r26	; 0x800537 <counter+0x2>
    191e:	b0 93 38 05 	sts	0x0538, r27	; 0x800538 <counter+0x3>
    1922:	e8 cf       	rjmp	.-48     	; 0x18f4 <Avenida_Secundaria_Sinal_Amarelo+0x8a>

00001924 <Avenida_Principal_Sinal_Verde>:
    1924:	cf 93       	push	r28
    1926:	df 93       	push	r29
    1928:	ec 01       	movw	r28, r24
    192a:	80 91 33 05 	lds	r24, 0x0533	; 0x800533 <amb_pri>
    192e:	81 11       	cpse	r24, r1
    1930:	21 c0       	rjmp	.+66     	; 0x1974 <Avenida_Principal_Sinal_Verde+0x50>
    1932:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <counter>
    1936:	90 91 36 05 	lds	r25, 0x0536	; 0x800536 <counter+0x1>
    193a:	a0 91 37 05 	lds	r26, 0x0537	; 0x800537 <counter+0x2>
    193e:	b0 91 38 05 	lds	r27, 0x0538	; 0x800538 <counter+0x3>
    1942:	01 96       	adiw	r24, 0x01	; 1
    1944:	a1 1d       	adc	r26, r1
    1946:	b1 1d       	adc	r27, r1
    1948:	80 93 35 05 	sts	0x0535, r24	; 0x800535 <counter>
    194c:	90 93 36 05 	sts	0x0536, r25	; 0x800536 <counter+0x1>
    1950:	a0 93 37 05 	sts	0x0537, r26	; 0x800537 <counter+0x2>
    1954:	b0 93 38 05 	sts	0x0538, r27	; 0x800538 <counter+0x3>
    1958:	8a 30       	cpi	r24, 0x0A	; 10
    195a:	91 05       	cpc	r25, r1
    195c:	a1 05       	cpc	r26, r1
    195e:	b1 05       	cpc	r27, r1
    1960:	c0 f1       	brcs	.+112    	; 0x19d2 <Avenida_Principal_Sinal_Verde+0xae>
    1962:	80 91 3b 05 	lds	r24, 0x053B	; 0x80053b <EVENT>
    1966:	83 50       	subi	r24, 0x03	; 3
    1968:	82 30       	cpi	r24, 0x02	; 2
    196a:	a0 f0       	brcs	.+40     	; 0x1994 <Avenida_Principal_Sinal_Verde+0x70>
    196c:	80 91 34 05 	lds	r24, 0x0534	; 0x800534 <amb_sec>
    1970:	81 30       	cpi	r24, 0x01	; 1
    1972:	b9 f1       	breq	.+110    	; 0x19e2 <Avenida_Principal_Sinal_Verde+0xbe>
    1974:	88 81       	ld	r24, Y
    1976:	99 81       	ldd	r25, Y+1	; 0x01
    1978:	89 2b       	or	r24, r25
    197a:	11 f0       	breq	.+4      	; 0x1980 <Avenida_Principal_Sinal_Verde+0x5c>
    197c:	ce 01       	movw	r24, r28
    197e:	15 d8       	rcall	.-4054   	; 0x9aa <chVTDoResetI>
    1980:	9e 01       	movw	r18, r28
    1982:	42 e9       	ldi	r20, 0x92	; 146
    1984:	5c e0       	ldi	r21, 0x0C	; 12
    1986:	68 e0       	ldi	r22, 0x08	; 8
    1988:	7d e3       	ldi	r23, 0x3D	; 61
    198a:	ce 01       	movw	r24, r28
    198c:	df 91       	pop	r29
    198e:	cf 91       	pop	r28
    1990:	0c 94 93 04 	jmp	0x926	; 0x926 <chVTDoSetI>
    1994:	10 92 35 05 	sts	0x0535, r1	; 0x800535 <counter>
    1998:	10 92 36 05 	sts	0x0536, r1	; 0x800536 <counter+0x1>
    199c:	10 92 37 05 	sts	0x0537, r1	; 0x800537 <counter+0x2>
    19a0:	10 92 38 05 	sts	0x0538, r1	; 0x800538 <counter+0x3>
    19a4:	28 98       	cbi	0x05, 0	; 5
    19a6:	81 e0       	ldi	r24, 0x01	; 1
    19a8:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <STATE>
    19ac:	80 93 39 05 	sts	0x0539, r24	; 0x800539 <LED_PRINCIPAL>
    19b0:	f8 94       	cli
    19b2:	88 81       	ld	r24, Y
    19b4:	99 81       	ldd	r25, Y+1	; 0x01
    19b6:	89 2b       	or	r24, r25
    19b8:	19 f0       	breq	.+6      	; 0x19c0 <Avenida_Principal_Sinal_Verde+0x9c>
    19ba:	ce 01       	movw	r24, r28
    19bc:	0e 94 d5 04 	call	0x9aa	; 0x9aa <chVTDoResetI>
    19c0:	78 94       	sei
    19c2:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <counter>
    19c6:	90 91 36 05 	lds	r25, 0x0536	; 0x800536 <counter+0x1>
    19ca:	a0 91 37 05 	lds	r26, 0x0537	; 0x800537 <counter+0x2>
    19ce:	b0 91 38 05 	lds	r27, 0x0538	; 0x800538 <counter+0x3>
    19d2:	05 97       	sbiw	r24, 0x05	; 5
    19d4:	a1 05       	cpc	r26, r1
    19d6:	b1 05       	cpc	r27, r1
    19d8:	68 f2       	brcs	.-102    	; 0x1974 <Avenida_Principal_Sinal_Verde+0x50>
    19da:	80 91 34 05 	lds	r24, 0x0534	; 0x800534 <amb_sec>
    19de:	81 30       	cpi	r24, 0x01	; 1
    19e0:	49 f6       	brne	.-110    	; 0x1974 <Avenida_Principal_Sinal_Verde+0x50>
    19e2:	10 92 35 05 	sts	0x0535, r1	; 0x800535 <counter>
    19e6:	10 92 36 05 	sts	0x0536, r1	; 0x800536 <counter+0x1>
    19ea:	10 92 37 05 	sts	0x0537, r1	; 0x800537 <counter+0x2>
    19ee:	10 92 38 05 	sts	0x0538, r1	; 0x800538 <counter+0x3>
    19f2:	28 98       	cbi	0x05, 0	; 5
    19f4:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <STATE>
    19f8:	80 93 39 05 	sts	0x0539, r24	; 0x800539 <LED_PRINCIPAL>
    19fc:	f8 94       	cli
    19fe:	88 81       	ld	r24, Y
    1a00:	99 81       	ldd	r25, Y+1	; 0x01
    1a02:	89 2b       	or	r24, r25
    1a04:	19 f0       	breq	.+6      	; 0x1a0c <Avenida_Principal_Sinal_Verde+0xe8>
    1a06:	ce 01       	movw	r24, r28
    1a08:	0e 94 d5 04 	call	0x9aa	; 0x9aa <chVTDoResetI>
    1a0c:	78 94       	sei
    1a0e:	b2 cf       	rjmp	.-156    	; 0x1974 <Avenida_Principal_Sinal_Verde+0x50>

00001a10 <Avenida_Principal_Sinal_Amarelo>:
    1a10:	cf 93       	push	r28
    1a12:	df 93       	push	r29
    1a14:	ec 01       	movw	r28, r24
    1a16:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <counter>
    1a1a:	90 91 36 05 	lds	r25, 0x0536	; 0x800536 <counter+0x1>
    1a1e:	a0 91 37 05 	lds	r26, 0x0537	; 0x800537 <counter+0x2>
    1a22:	b0 91 38 05 	lds	r27, 0x0538	; 0x800538 <counter+0x3>
    1a26:	01 96       	adiw	r24, 0x01	; 1
    1a28:	a1 1d       	adc	r26, r1
    1a2a:	b1 1d       	adc	r27, r1
    1a2c:	82 30       	cpi	r24, 0x02	; 2
    1a2e:	91 05       	cpc	r25, r1
    1a30:	a1 05       	cpc	r26, r1
    1a32:	b1 05       	cpc	r27, r1
    1a34:	d0 f1       	brcs	.+116    	; 0x1aaa <Avenida_Principal_Sinal_Amarelo+0x9a>
    1a36:	10 92 35 05 	sts	0x0535, r1	; 0x800535 <counter>
    1a3a:	10 92 36 05 	sts	0x0536, r1	; 0x800536 <counter+0x1>
    1a3e:	10 92 37 05 	sts	0x0537, r1	; 0x800537 <counter+0x2>
    1a42:	10 92 38 05 	sts	0x0538, r1	; 0x800538 <counter+0x3>
    1a46:	28 98       	cbi	0x05, 0	; 5
    1a48:	5f 98       	cbi	0x0b, 7	; 11
    1a4a:	5e 9a       	sbi	0x0b, 6	; 11
    1a4c:	80 91 34 05 	lds	r24, 0x0534	; 0x800534 <amb_sec>
    1a50:	81 30       	cpi	r24, 0x01	; 1
    1a52:	51 f0       	breq	.+20     	; 0x1a68 <Avenida_Principal_Sinal_Amarelo+0x58>
    1a54:	80 91 3b 05 	lds	r24, 0x053B	; 0x80053b <EVENT>
    1a58:	84 30       	cpi	r24, 0x04	; 4
    1a5a:	81 f1       	breq	.+96     	; 0x1abc <Avenida_Principal_Sinal_Amarelo+0xac>
    1a5c:	83 30       	cpi	r24, 0x03	; 3
    1a5e:	49 f4       	brne	.+18     	; 0x1a72 <Avenida_Principal_Sinal_Amarelo+0x62>
    1a60:	80 91 3a 05 	lds	r24, 0x053A	; 0x80053a <BACKUP_EVENT>
    1a64:	84 30       	cpi	r24, 0x04	; 4
    1a66:	51 f1       	breq	.+84     	; 0x1abc <Avenida_Principal_Sinal_Amarelo+0xac>
    1a68:	82 e0       	ldi	r24, 0x02	; 2
    1a6a:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <STATE>
    1a6e:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <LED_SECUNDARIA>
    1a72:	10 92 3b 05 	sts	0x053B, r1	; 0x80053b <EVENT>
    1a76:	f8 94       	cli
    1a78:	88 81       	ld	r24, Y
    1a7a:	99 81       	ldd	r25, Y+1	; 0x01
    1a7c:	89 2b       	or	r24, r25
    1a7e:	19 f0       	breq	.+6      	; 0x1a86 <Avenida_Principal_Sinal_Amarelo+0x76>
    1a80:	ce 01       	movw	r24, r28
    1a82:	0e 94 d5 04 	call	0x9aa	; 0x9aa <chVTDoResetI>
    1a86:	78 94       	sei
    1a88:	88 81       	ld	r24, Y
    1a8a:	99 81       	ldd	r25, Y+1	; 0x01
    1a8c:	89 2b       	or	r24, r25
    1a8e:	19 f0       	breq	.+6      	; 0x1a96 <Avenida_Principal_Sinal_Amarelo+0x86>
    1a90:	ce 01       	movw	r24, r28
    1a92:	0e 94 d5 04 	call	0x9aa	; 0x9aa <chVTDoResetI>
    1a96:	9e 01       	movw	r18, r28
    1a98:	48 e0       	ldi	r20, 0x08	; 8
    1a9a:	5d e0       	ldi	r21, 0x0D	; 13
    1a9c:	68 e0       	ldi	r22, 0x08	; 8
    1a9e:	7d e3       	ldi	r23, 0x3D	; 61
    1aa0:	ce 01       	movw	r24, r28
    1aa2:	df 91       	pop	r29
    1aa4:	cf 91       	pop	r28
    1aa6:	0c 94 93 04 	jmp	0x926	; 0x926 <chVTDoSetI>
    1aaa:	80 93 35 05 	sts	0x0535, r24	; 0x800535 <counter>
    1aae:	90 93 36 05 	sts	0x0536, r25	; 0x800536 <counter+0x1>
    1ab2:	a0 93 37 05 	sts	0x0537, r26	; 0x800537 <counter+0x2>
    1ab6:	b0 93 38 05 	sts	0x0538, r27	; 0x800538 <counter+0x3>
    1aba:	e6 cf       	rjmp	.-52     	; 0x1a88 <Avenida_Principal_Sinal_Amarelo+0x78>
    1abc:	80 91 32 05 	lds	r24, 0x0532	; 0x800532 <ped_sec>
    1ac0:	84 60       	ori	r24, 0x04	; 4
    1ac2:	80 93 32 05 	sts	0x0532, r24	; 0x800532 <ped_sec>
    1ac6:	83 e0       	ldi	r24, 0x03	; 3
    1ac8:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <STATE>
    1acc:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__DATA_REGION_ORIGIN__>
    1ad0:	d0 cf       	rjmp	.-96     	; 0x1a72 <Avenida_Principal_Sinal_Amarelo+0x62>

00001ad2 <InitBuffer>:
    1ad2:	80 e5       	ldi	r24, 0x50	; 80
    1ad4:	95 e0       	ldi	r25, 0x05	; 5
    1ad6:	37 db       	rcall	.-2450   	; 0x1146 <chMtxObjectInit>
    1ad8:	8c e4       	ldi	r24, 0x4C	; 76
    1ada:	95 e0       	ldi	r25, 0x05	; 5
    1adc:	ae dc       	rcall	.-1700   	; 0x143a <chCondObjectInit>
    1ade:	88 e4       	ldi	r24, 0x48	; 72
    1ae0:	95 e0       	ldi	r25, 0x05	; 5
    1ae2:	ab dc       	rcall	.-1706   	; 0x143a <chCondObjectInit>
    1ae4:	8e e5       	ldi	r24, 0x5E	; 94
    1ae6:	95 e0       	ldi	r25, 0x05	; 5
    1ae8:	90 93 5b 05 	sts	0x055B, r25	; 0x80055b <wrp+0x1>
    1aec:	80 93 5a 05 	sts	0x055A, r24	; 0x80055a <wrp>
    1af0:	90 93 5d 05 	sts	0x055D, r25	; 0x80055d <rdp+0x1>
    1af4:	80 93 5c 05 	sts	0x055C, r24	; 0x80055c <rdp>
    1af8:	10 92 59 05 	sts	0x0559, r1	; 0x800559 <qsize+0x1>
    1afc:	10 92 58 05 	sts	0x0558, r1	; 0x800558 <qsize>
    1b00:	08 95       	ret

00001b02 <main>:
    1b02:	cf 93       	push	r28
    1b04:	df 93       	push	r29
    1b06:	00 d0       	rcall	.+0      	; 0x1b08 <main+0x6>
    1b08:	1f 92       	push	r1
    1b0a:	cd b7       	in	r28, 0x3d	; 61
    1b0c:	de b7       	in	r29, 0x3e	; 62
    1b0e:	80 e1       	ldi	r24, 0x10	; 16
    1b10:	90 e0       	ldi	r25, 0x00	; 0
    1b12:	9a 83       	std	Y+2, r25	; 0x02
    1b14:	89 83       	std	Y+1, r24	; 0x01
    1b16:	83 e0       	ldi	r24, 0x03	; 3
    1b18:	8b 83       	std	Y+3, r24	; 0x03
    1b1a:	db df       	rcall	.-74     	; 0x1ad2 <InitBuffer>
    1b1c:	10 92 3d 05 	sts	0x053D, r1	; 0x80053d <vt+0x1>
    1b20:	10 92 3c 05 	sts	0x053C, r1	; 0x80053c <vt>
    1b24:	0e 94 63 00 	call	0xc6	; 0xc6 <halInit>
    1b28:	0e 94 7d 04 	call	0x8fa	; 0x8fa <chSysInit>
    1b2c:	be 01       	movw	r22, r28
    1b2e:	6f 5f       	subi	r22, 0xFF	; 255
    1b30:	7f 4f       	sbci	r23, 0xFF	; 255
    1b32:	8e e5       	ldi	r24, 0x5E	; 94
    1b34:	96 e0       	ldi	r25, 0x06	; 6
    1b36:	0e 94 08 03 	call	0x610	; 0x610 <sdStart>
    1b3a:	2d 98       	cbi	0x05, 5	; 5
    1b3c:	43 e0       	ldi	r20, 0x03	; 3
    1b3e:	60 e1       	ldi	r22, 0x10	; 16
    1b40:	83 e2       	ldi	r24, 0x23	; 35
    1b42:	90 e0       	ldi	r25, 0x00	; 0
    1b44:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1b48:	43 e0       	ldi	r20, 0x03	; 3
    1b4a:	68 e0       	ldi	r22, 0x08	; 8
    1b4c:	83 e2       	ldi	r24, 0x23	; 35
    1b4e:	90 e0       	ldi	r25, 0x00	; 0
    1b50:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1b54:	43 e0       	ldi	r20, 0x03	; 3
    1b56:	64 e0       	ldi	r22, 0x04	; 4
    1b58:	83 e2       	ldi	r24, 0x23	; 35
    1b5a:	90 e0       	ldi	r25, 0x00	; 0
    1b5c:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1b60:	43 e0       	ldi	r20, 0x03	; 3
    1b62:	62 e0       	ldi	r22, 0x02	; 2
    1b64:	83 e2       	ldi	r24, 0x23	; 35
    1b66:	90 e0       	ldi	r25, 0x00	; 0
    1b68:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1b6c:	46 e0       	ldi	r20, 0x06	; 6
    1b6e:	61 e0       	ldi	r22, 0x01	; 1
    1b70:	83 e2       	ldi	r24, 0x23	; 35
    1b72:	90 e0       	ldi	r25, 0x00	; 0
    1b74:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1b78:	28 98       	cbi	0x05, 0	; 5
    1b7a:	46 e0       	ldi	r20, 0x06	; 6
    1b7c:	60 e8       	ldi	r22, 0x80	; 128
    1b7e:	89 e2       	ldi	r24, 0x29	; 41
    1b80:	90 e0       	ldi	r25, 0x00	; 0
    1b82:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1b86:	5f 98       	cbi	0x0b, 7	; 11
    1b88:	46 e0       	ldi	r20, 0x06	; 6
    1b8a:	60 e4       	ldi	r22, 0x40	; 64
    1b8c:	89 e2       	ldi	r24, 0x29	; 41
    1b8e:	90 e0       	ldi	r25, 0x00	; 0
    1b90:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1b94:	5e 98       	cbi	0x0b, 6	; 11
    1b96:	46 e0       	ldi	r20, 0x06	; 6
    1b98:	60 e2       	ldi	r22, 0x20	; 32
    1b9a:	89 e2       	ldi	r24, 0x29	; 41
    1b9c:	90 e0       	ldi	r25, 0x00	; 0
    1b9e:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1ba2:	5d 98       	cbi	0x0b, 5	; 11
    1ba4:	46 e0       	ldi	r20, 0x06	; 6
    1ba6:	60 e1       	ldi	r22, 0x10	; 16
    1ba8:	89 e2       	ldi	r24, 0x29	; 41
    1baa:	90 e0       	ldi	r25, 0x00	; 0
    1bac:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1bb0:	5c 98       	cbi	0x0b, 4	; 11
    1bb2:	46 e0       	ldi	r20, 0x06	; 6
    1bb4:	68 e0       	ldi	r22, 0x08	; 8
    1bb6:	89 e2       	ldi	r24, 0x29	; 41
    1bb8:	90 e0       	ldi	r25, 0x00	; 0
    1bba:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1bbe:	5b 9a       	sbi	0x0b, 3	; 11
    1bc0:	46 e0       	ldi	r20, 0x06	; 6
    1bc2:	61 e0       	ldi	r22, 0x01	; 1
    1bc4:	86 e2       	ldi	r24, 0x26	; 38
    1bc6:	90 e0       	ldi	r25, 0x00	; 0
    1bc8:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1bcc:	40 9a       	sbi	0x08, 0	; 8
    1bce:	46 e0       	ldi	r20, 0x06	; 6
    1bd0:	62 e0       	ldi	r22, 0x02	; 2
    1bd2:	86 e2       	ldi	r24, 0x26	; 38
    1bd4:	90 e0       	ldi	r25, 0x00	; 0
    1bd6:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1bda:	41 98       	cbi	0x08, 1	; 8
    1bdc:	10 e0       	ldi	r17, 0x00	; 0
    1bde:	00 e0       	ldi	r16, 0x00	; 0
    1be0:	25 e4       	ldi	r18, 0x45	; 69
    1be2:	3e e0       	ldi	r19, 0x0E	; 14
    1be4:	40 e8       	ldi	r20, 0x80	; 128
    1be6:	63 ee       	ldi	r22, 0xE3	; 227
    1be8:	70 e0       	ldi	r23, 0x00	; 0
    1bea:	8f e4       	ldi	r24, 0x4F	; 79
    1bec:	94 e0       	ldi	r25, 0x04	; 4
    1bee:	f2 d9       	rcall	.-3100   	; 0xfd4 <chThdCreateStatic>
    1bf0:	22 ea       	ldi	r18, 0xA2	; 162
    1bf2:	3e e0       	ldi	r19, 0x0E	; 14
    1bf4:	40 e8       	ldi	r20, 0x80	; 128
    1bf6:	63 ee       	ldi	r22, 0xE3	; 227
    1bf8:	70 e0       	ldi	r23, 0x00	; 0
    1bfa:	8c e6       	ldi	r24, 0x6C	; 108
    1bfc:	93 e0       	ldi	r25, 0x03	; 3
    1bfe:	ea d9       	rcall	.-3116   	; 0xfd4 <chThdCreateStatic>
    1c00:	29 e7       	ldi	r18, 0x79	; 121
    1c02:	3f e0       	ldi	r19, 0x0F	; 15
    1c04:	40 e8       	ldi	r20, 0x80	; 128
    1c06:	63 ee       	ldi	r22, 0xE3	; 227
    1c08:	70 e0       	ldi	r23, 0x00	; 0
    1c0a:	89 e8       	ldi	r24, 0x89	; 137
    1c0c:	92 e0       	ldi	r25, 0x02	; 2
    1c0e:	e2 d9       	rcall	.-3132   	; 0xfd4 <chThdCreateStatic>
    1c10:	80 e1       	ldi	r24, 0x10	; 16
    1c12:	90 e0       	ldi	r25, 0x00	; 0
    1c14:	5c da       	rcall	.-2888   	; 0x10ce <chThdSleep>
    1c16:	fc cf       	rjmp	.-8      	; 0x1c10 <main+0x10e>

00001c18 <PushBUffer>:
    1c18:	cf 93       	push	r28
    1c1a:	df 93       	push	r29
    1c1c:	ec 01       	movw	r28, r24
    1c1e:	80 e5       	ldi	r24, 0x50	; 80
    1c20:	95 e0       	ldi	r25, 0x05	; 5
    1c22:	77 db       	rcall	.-2322   	; 0x1312 <chMtxLock>
    1c24:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <qsize>
    1c28:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <qsize+0x1>
    1c2c:	80 38       	cpi	r24, 0x80	; 128
    1c2e:	91 05       	cpc	r25, r1
    1c30:	50 f0       	brcs	.+20     	; 0x1c46 <PushBUffer+0x2e>
    1c32:	88 e4       	ldi	r24, 0x48	; 72
    1c34:	95 e0       	ldi	r25, 0x05	; 5
    1c36:	5d dc       	rcall	.-1862   	; 0x14f2 <chCondWait>
    1c38:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <qsize>
    1c3c:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <qsize+0x1>
    1c40:	80 38       	cpi	r24, 0x80	; 128
    1c42:	91 05       	cpc	r25, r1
    1c44:	b0 f7       	brcc	.-20     	; 0x1c32 <PushBUffer+0x1a>
    1c46:	e0 91 5a 05 	lds	r30, 0x055A	; 0x80055a <wrp>
    1c4a:	f0 91 5b 05 	lds	r31, 0x055B	; 0x80055b <wrp+0x1>
    1c4e:	c1 93       	st	Z+, r28
    1c50:	d1 93       	st	Z+, r29
    1c52:	26 e0       	ldi	r18, 0x06	; 6
    1c54:	ee 35       	cpi	r30, 0x5E	; 94
    1c56:	f2 07       	cpc	r31, r18
    1c58:	98 f0       	brcs	.+38     	; 0x1c80 <PushBUffer+0x68>
    1c5a:	2e e5       	ldi	r18, 0x5E	; 94
    1c5c:	35 e0       	ldi	r19, 0x05	; 5
    1c5e:	30 93 5b 05 	sts	0x055B, r19	; 0x80055b <wrp+0x1>
    1c62:	20 93 5a 05 	sts	0x055A, r18	; 0x80055a <wrp>
    1c66:	01 96       	adiw	r24, 0x01	; 1
    1c68:	90 93 59 05 	sts	0x0559, r25	; 0x800559 <qsize+0x1>
    1c6c:	80 93 58 05 	sts	0x0558, r24	; 0x800558 <qsize>
    1c70:	8c e4       	ldi	r24, 0x4C	; 76
    1c72:	95 e0       	ldi	r25, 0x05	; 5
    1c74:	e8 db       	rcall	.-2096   	; 0x1446 <chCondSignal>
    1c76:	80 e5       	ldi	r24, 0x50	; 80
    1c78:	95 e0       	ldi	r25, 0x05	; 5
    1c7a:	df 91       	pop	r29
    1c7c:	cf 91       	pop	r28
    1c7e:	4d cb       	rjmp	.-2406   	; 0x131a <chMtxUnlock>
    1c80:	f0 93 5b 05 	sts	0x055B, r31	; 0x80055b <wrp+0x1>
    1c84:	e0 93 5a 05 	sts	0x055A, r30	; 0x80055a <wrp>
    1c88:	ee cf       	rjmp	.-36     	; 0x1c66 <PushBUffer+0x4e>

00001c8a <Write_Save_Event>:
    1c8a:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <ch0+0x5>
    1c8e:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <ch0+0x6>
    1c92:	8d e5       	ldi	r24, 0x5D	; 93
    1c94:	91 e0       	ldi	r25, 0x01	; 1
    1c96:	96 87       	std	Z+14, r25	; 0x0e
    1c98:	85 87       	std	Z+13, r24	; 0x0d
    1c9a:	09 c0       	rjmp	.+18     	; 0x1cae <Write_Save_Event+0x24>
    1c9c:	1b 9b       	sbis	0x03, 3	; 3
    1c9e:	0e c0       	rjmp	.+28     	; 0x1cbc <Write_Save_Event+0x32>
    1ca0:	1a 9b       	sbis	0x03, 2	; 3
    1ca2:	11 c0       	rjmp	.+34     	; 0x1cc6 <Write_Save_Event+0x3c>
    1ca4:	19 9b       	sbis	0x03, 1	; 3
    1ca6:	14 c0       	rjmp	.+40     	; 0x1cd0 <Write_Save_Event+0x46>
    1ca8:	88 e2       	ldi	r24, 0x28	; 40
    1caa:	99 e0       	ldi	r25, 0x09	; 9
    1cac:	10 da       	rcall	.-3040   	; 0x10ce <chThdSleep>
    1cae:	1c 99       	sbic	0x03, 4	; 3
    1cb0:	f5 cf       	rjmp	.-22     	; 0x1c9c <Write_Save_Event+0x12>
    1cb2:	84 e0       	ldi	r24, 0x04	; 4
    1cb4:	90 e0       	ldi	r25, 0x00	; 0
    1cb6:	b0 df       	rcall	.-160    	; 0x1c18 <PushBUffer>
    1cb8:	1b 99       	sbic	0x03, 3	; 3
    1cba:	f2 cf       	rjmp	.-28     	; 0x1ca0 <Write_Save_Event+0x16>
    1cbc:	83 e0       	ldi	r24, 0x03	; 3
    1cbe:	90 e0       	ldi	r25, 0x00	; 0
    1cc0:	ab df       	rcall	.-170    	; 0x1c18 <PushBUffer>
    1cc2:	1a 99       	sbic	0x03, 2	; 3
    1cc4:	ef cf       	rjmp	.-34     	; 0x1ca4 <Write_Save_Event+0x1a>
    1cc6:	82 e0       	ldi	r24, 0x02	; 2
    1cc8:	90 e0       	ldi	r25, 0x00	; 0
    1cca:	a6 df       	rcall	.-180    	; 0x1c18 <PushBUffer>
    1ccc:	19 99       	sbic	0x03, 1	; 3
    1cce:	ec cf       	rjmp	.-40     	; 0x1ca8 <Write_Save_Event+0x1e>
    1cd0:	81 e0       	ldi	r24, 0x01	; 1
    1cd2:	90 e0       	ldi	r25, 0x00	; 0
    1cd4:	a1 df       	rcall	.-190    	; 0x1c18 <PushBUffer>
    1cd6:	e8 cf       	rjmp	.-48     	; 0x1ca8 <Write_Save_Event+0x1e>

00001cd8 <PopBUffer>:
    1cd8:	cf 93       	push	r28
    1cda:	80 e5       	ldi	r24, 0x50	; 80
    1cdc:	95 e0       	ldi	r25, 0x05	; 5
    1cde:	19 db       	rcall	.-2510   	; 0x1312 <chMtxLock>
    1ce0:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <qsize>
    1ce4:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <qsize+0x1>
    1ce8:	00 97       	sbiw	r24, 0x00	; 0
    1cea:	49 f4       	brne	.+18     	; 0x1cfe <PopBUffer+0x26>
    1cec:	8c e4       	ldi	r24, 0x4C	; 76
    1cee:	95 e0       	ldi	r25, 0x05	; 5
    1cf0:	00 dc       	rcall	.-2048   	; 0x14f2 <chCondWait>
    1cf2:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <qsize>
    1cf6:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <qsize+0x1>
    1cfa:	00 97       	sbiw	r24, 0x00	; 0
    1cfc:	b9 f3       	breq	.-18     	; 0x1cec <PopBUffer+0x14>
    1cfe:	e0 91 5c 05 	lds	r30, 0x055C	; 0x80055c <rdp>
    1d02:	f0 91 5d 05 	lds	r31, 0x055D	; 0x80055d <rdp+0x1>
    1d06:	c0 81       	ld	r28, Z
    1d08:	32 96       	adiw	r30, 0x02	; 2
    1d0a:	26 e0       	ldi	r18, 0x06	; 6
    1d0c:	ee 35       	cpi	r30, 0x5E	; 94
    1d0e:	f2 07       	cpc	r31, r18
    1d10:	a0 f0       	brcs	.+40     	; 0x1d3a <PopBUffer+0x62>
    1d12:	2e e5       	ldi	r18, 0x5E	; 94
    1d14:	35 e0       	ldi	r19, 0x05	; 5
    1d16:	30 93 5d 05 	sts	0x055D, r19	; 0x80055d <rdp+0x1>
    1d1a:	20 93 5c 05 	sts	0x055C, r18	; 0x80055c <rdp>
    1d1e:	01 97       	sbiw	r24, 0x01	; 1
    1d20:	90 93 59 05 	sts	0x0559, r25	; 0x800559 <qsize+0x1>
    1d24:	80 93 58 05 	sts	0x0558, r24	; 0x800558 <qsize>
    1d28:	88 e4       	ldi	r24, 0x48	; 72
    1d2a:	95 e0       	ldi	r25, 0x05	; 5
    1d2c:	8c db       	rcall	.-2280   	; 0x1446 <chCondSignal>
    1d2e:	80 e5       	ldi	r24, 0x50	; 80
    1d30:	95 e0       	ldi	r25, 0x05	; 5
    1d32:	f3 da       	rcall	.-2586   	; 0x131a <chMtxUnlock>
    1d34:	8c 2f       	mov	r24, r28
    1d36:	cf 91       	pop	r28
    1d38:	08 95       	ret
    1d3a:	f0 93 5d 05 	sts	0x055D, r31	; 0x80055d <rdp+0x1>
    1d3e:	e0 93 5c 05 	sts	0x055C, r30	; 0x80055c <rdp>
    1d42:	ed cf       	rjmp	.-38     	; 0x1d1e <PopBUffer+0x46>

00001d44 <Read_Collect_Event>:
    1d44:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <ch0+0x5>
    1d48:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <ch0+0x6>
    1d4c:	8e e6       	ldi	r24, 0x6E	; 110
    1d4e:	91 e0       	ldi	r25, 0x01	; 1
    1d50:	96 87       	std	Z+14, r25	; 0x0e
    1d52:	85 87       	std	Z+13, r24	; 0x0d
    1d54:	c0 e2       	ldi	r28, 0x20	; 32
    1d56:	d1 e0       	ldi	r29, 0x01	; 1
    1d58:	03 c0       	rjmp	.+6      	; 0x1d60 <Read_Collect_Event+0x1c>
    1d5a:	80 e1       	ldi	r24, 0x10	; 16
    1d5c:	90 e0       	ldi	r25, 0x00	; 0
    1d5e:	b7 d9       	rcall	.-3218   	; 0x10ce <chThdSleep>
    1d60:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <qsize>
    1d64:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <qsize+0x1>
    1d68:	89 2b       	or	r24, r25
    1d6a:	b9 f3       	breq	.-18     	; 0x1d5a <Read_Collect_Event+0x16>
    1d6c:	85 b1       	in	r24, 0x05	; 5
    1d6e:	8c 27       	eor	r24, r28
    1d70:	85 b9       	out	0x05, r24	; 5
    1d72:	80 91 3b 05 	lds	r24, 0x053B	; 0x80053b <EVENT>
    1d76:	80 93 3a 05 	sts	0x053A, r24	; 0x80053a <BACKUP_EVENT>
    1d7a:	ae df       	rcall	.-164    	; 0x1cd8 <PopBUffer>
    1d7c:	80 93 3b 05 	sts	0x053B, r24	; 0x80053b <EVENT>
    1d80:	82 30       	cpi	r24, 0x02	; 2
    1d82:	41 f0       	breq	.+16     	; 0x1d94 <Read_Collect_Event+0x50>
    1d84:	81 30       	cpi	r24, 0x01	; 1
    1d86:	49 f7       	brne	.-46     	; 0x1d5a <Read_Collect_Event+0x16>
    1d88:	90 91 34 05 	lds	r25, 0x0534	; 0x800534 <amb_sec>
    1d8c:	89 27       	eor	r24, r25
    1d8e:	80 93 34 05 	sts	0x0534, r24	; 0x800534 <amb_sec>
    1d92:	e3 cf       	rjmp	.-58     	; 0x1d5a <Read_Collect_Event+0x16>
    1d94:	80 91 33 05 	lds	r24, 0x0533	; 0x800533 <amb_pri>
    1d98:	8d 27       	eor	r24, r29
    1d9a:	80 93 33 05 	sts	0x0533, r24	; 0x800533 <amb_pri>
    1d9e:	dd cf       	rjmp	.-70     	; 0x1d5a <Read_Collect_Event+0x16>

00001da0 <PrincipalTimer>:

/*====================== Avenida Principal ===============================*/
void PrincipalTimer()
{
  switch (LED_PRINCIPAL)
    1da0:	80 91 39 05 	lds	r24, 0x0539	; 0x800539 <LED_PRINCIPAL>
    1da4:	88 23       	and	r24, r24
    1da6:	e1 f0       	breq	.+56     	; 0x1de0 <PrincipalTimer+0x40>
    1da8:	81 30       	cpi	r24, 0x01	; 1
    1daa:	c9 f4       	brne	.+50     	; 0x1dde <PrincipalTimer+0x3e>
      break;
    }

    case AMARELO:
    {
      palClearPad(IOPORT2, LED_VERDE_PRINCIPAL);
    1dac:	28 98       	cbi	0x05, 0	; 5
      palClearPad(IOPORT4, LED_VERMELHO_PRINCIPAL);
    1dae:	5e 98       	cbi	0x0b, 6	; 11
      palSetPad(IOPORT4, LED_AMARELO_PRINCIPAL);
    1db0:	5f 9a       	sbi	0x0b, 7	; 11
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1db2:	f8 94       	cli
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
    1db4:	80 91 3c 05 	lds	r24, 0x053C	; 0x80053c <vt>
    1db8:	90 91 3d 05 	lds	r25, 0x053D	; 0x80053d <vt+0x1>
    1dbc:	89 2b       	or	r24, r25
    1dbe:	21 f0       	breq	.+8      	; 0x1dc8 <PrincipalTimer+0x28>
    chVTDoResetI(vtp);
    1dc0:	8c e3       	ldi	r24, 0x3C	; 60
    1dc2:	95 e0       	ldi	r25, 0x05	; 5
    1dc4:	0e 94 d5 04 	call	0x9aa	; 0x9aa <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
    1dc8:	2c e3       	ldi	r18, 0x3C	; 60
    1dca:	35 e0       	ldi	r19, 0x05	; 5
    1dcc:	48 e0       	ldi	r20, 0x08	; 8
    1dce:	5d e0       	ldi	r21, 0x0D	; 13
    1dd0:	68 e0       	ldi	r22, 0x08	; 8
    1dd2:	7d e3       	ldi	r23, 0x3D	; 61
    1dd4:	c9 01       	movw	r24, r18
    1dd6:	0e 94 93 04 	call	0x926	; 0x926 <chVTDoSetI>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    1dda:	78 94       	sei
      chVTSet(&vt, TIME_MS2I(1000), Avenida_Principal_Sinal_Amarelo, (void*)&vt);
      break;
    }
  }  
}
    1ddc:	08 95       	ret
    1dde:	08 95       	ret
{
  switch (LED_PRINCIPAL)
  {
    case VERDE:
    {
      palSetPad(IOPORT2, LED_VERDE_PRINCIPAL);
    1de0:	28 9a       	sbi	0x05, 0	; 5
      palClearPad(IOPORT4, LED_AMARELO_PRINCIPAL);
    1de2:	5f 98       	cbi	0x0b, 7	; 11
      palClearPad(IOPORT4, LED_VERMELHO_PRINCIPAL);
    1de4:	5e 98       	cbi	0x0b, 6	; 11
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1de6:	f8 94       	cli
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
    1de8:	80 91 3c 05 	lds	r24, 0x053C	; 0x80053c <vt>
    1dec:	90 91 3d 05 	lds	r25, 0x053D	; 0x80053d <vt+0x1>
    1df0:	89 2b       	or	r24, r25
    1df2:	21 f0       	breq	.+8      	; 0x1dfc <PrincipalTimer+0x5c>
    chVTDoResetI(vtp);
    1df4:	8c e3       	ldi	r24, 0x3C	; 60
    1df6:	95 e0       	ldi	r25, 0x05	; 5
    1df8:	0e 94 d5 04 	call	0x9aa	; 0x9aa <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
    1dfc:	2c e3       	ldi	r18, 0x3C	; 60
    1dfe:	35 e0       	ldi	r19, 0x05	; 5
    1e00:	42 e9       	ldi	r20, 0x92	; 146
    1e02:	5c e0       	ldi	r21, 0x0C	; 12
    1e04:	68 e0       	ldi	r22, 0x08	; 8
    1e06:	7d e3       	ldi	r23, 0x3D	; 61
    1e08:	c9 01       	movw	r24, r18
    1e0a:	0e 94 93 04 	call	0x926	; 0x926 <chVTDoSetI>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    1e0e:	78 94       	sei
    1e10:	08 95       	ret

00001e12 <SecundariaTimer>:
}

/*====================== Avenida Secundaria ===============================*/
void SecundariaTimer()
{
  switch (LED_SECUNDARIA)
    1e12:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <LED_SECUNDARIA>
    1e16:	88 23       	and	r24, r24
    1e18:	e1 f0       	breq	.+56     	; 0x1e52 <SecundariaTimer+0x40>
    1e1a:	81 30       	cpi	r24, 0x01	; 1
    1e1c:	c9 f4       	brne	.+50     	; 0x1e50 <SecundariaTimer+0x3e>
      palClearPad(IOPORT4, LED_VERMELHO_SECUNDARIA);
      chVTSet(&vt, TIME_MS2I(1000), Avenida_Secundaria_Sinal_Verde, (void*)&vt);
      break;
    
    case AMARELO:
      palClearPad(IOPORT4, LED_VERDE_SECUNDARIA);
    1e1e:	5d 98       	cbi	0x0b, 5	; 11
      palSetPad(IOPORT4, LED_AMARELO_SECUNDARIA);
    1e20:	5c 9a       	sbi	0x0b, 4	; 11
      palClearPad(IOPORT4, LED_VERMELHO_SECUNDARIA);
    1e22:	5b 98       	cbi	0x0b, 3	; 11
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1e24:	f8 94       	cli
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
    1e26:	80 91 3c 05 	lds	r24, 0x053C	; 0x80053c <vt>
    1e2a:	90 91 3d 05 	lds	r25, 0x053D	; 0x80053d <vt+0x1>
    1e2e:	89 2b       	or	r24, r25
    1e30:	21 f0       	breq	.+8      	; 0x1e3a <SecundariaTimer+0x28>
    chVTDoResetI(vtp);
    1e32:	8c e3       	ldi	r24, 0x3C	; 60
    1e34:	95 e0       	ldi	r25, 0x05	; 5
    1e36:	0e 94 d5 04 	call	0x9aa	; 0x9aa <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
    1e3a:	2c e3       	ldi	r18, 0x3C	; 60
    1e3c:	35 e0       	ldi	r19, 0x05	; 5
    1e3e:	45 e3       	ldi	r20, 0x35	; 53
    1e40:	5c e0       	ldi	r21, 0x0C	; 12
    1e42:	68 e0       	ldi	r22, 0x08	; 8
    1e44:	7d e3       	ldi	r23, 0x3D	; 61
    1e46:	c9 01       	movw	r24, r18
    1e48:	0e 94 93 04 	call	0x926	; 0x926 <chVTDoSetI>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    1e4c:	78 94       	sei
      chVTSet(&vt, TIME_MS2I(1000), Avenida_Secundaria_Sinal_Amarelo, (void*)&vt);
      break;
  }
}
    1e4e:	08 95       	ret
    1e50:	08 95       	ret
void SecundariaTimer()
{
  switch (LED_SECUNDARIA)
  {
    case VERDE:
      palSetPad(IOPORT4, LED_VERDE_SECUNDARIA);
    1e52:	5d 9a       	sbi	0x0b, 5	; 11
      palClearPad(IOPORT4, LED_AMARELO_SECUNDARIA);
    1e54:	5c 98       	cbi	0x0b, 4	; 11
      palClearPad(IOPORT4, LED_VERMELHO_SECUNDARIA);
    1e56:	5b 98       	cbi	0x0b, 3	; 11
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1e58:	f8 94       	cli
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
    1e5a:	80 91 3c 05 	lds	r24, 0x053C	; 0x80053c <vt>
    1e5e:	90 91 3d 05 	lds	r25, 0x053D	; 0x80053d <vt+0x1>
    1e62:	89 2b       	or	r24, r25
    1e64:	21 f0       	breq	.+8      	; 0x1e6e <SecundariaTimer+0x5c>
    chVTDoResetI(vtp);
    1e66:	8c e3       	ldi	r24, 0x3C	; 60
    1e68:	95 e0       	ldi	r25, 0x05	; 5
    1e6a:	0e 94 d5 04 	call	0x9aa	; 0x9aa <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
    1e6e:	2c e3       	ldi	r18, 0x3C	; 60
    1e70:	35 e0       	ldi	r19, 0x05	; 5
    1e72:	4b e6       	ldi	r20, 0x6B	; 107
    1e74:	5b e0       	ldi	r21, 0x0B	; 11
    1e76:	68 e0       	ldi	r22, 0x08	; 8
    1e78:	7d e3       	ldi	r23, 0x3D	; 61
    1e7a:	c9 01       	movw	r24, r18
    1e7c:	0e 94 93 04 	call	0x926	; 0x926 <chVTDoSetI>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    1e80:	78 94       	sei
    1e82:	08 95       	ret

00001e84 <PedestreTimer>:
}

/*====================== Via de Pedestre ===============================*/
void PedestreTimer()
{
  switch (LED_PEDESTRE)
    1e84:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
    1e88:	88 23       	and	r24, r24
    1e8a:	d9 f0       	breq	.+54     	; 0x1ec2 <PedestreTimer+0x3e>
    1e8c:	81 30       	cpi	r24, 0x01	; 1
    1e8e:	c1 f4       	brne	.+48     	; 0x1ec0 <PedestreTimer+0x3c>
      palClearPad(IOPORT3, LED_VERMELHO_PEDESTRE);
      chVTSet(&vt, TIME_MS2I(1000), Via_Pedestre_Sinal_Verde, (void*)&vt);
      break;
    
    case AMARELO:
      palClearPad(IOPORT3, LED_VERDE_PEDESTRE);
    1e90:	41 98       	cbi	0x08, 1	; 8
      palSetPad(IOPORT3, LED_VERMELHO_PEDESTRE);
    1e92:	40 9a       	sbi	0x08, 0	; 8
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1e94:	f8 94       	cli
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
    1e96:	80 91 3c 05 	lds	r24, 0x053C	; 0x80053c <vt>
    1e9a:	90 91 3d 05 	lds	r25, 0x053D	; 0x80053d <vt+0x1>
    1e9e:	89 2b       	or	r24, r25
    1ea0:	21 f0       	breq	.+8      	; 0x1eaa <PedestreTimer+0x26>
    chVTDoResetI(vtp);
    1ea2:	8c e3       	ldi	r24, 0x3C	; 60
    1ea4:	95 e0       	ldi	r25, 0x05	; 5
    1ea6:	0e 94 d5 04 	call	0x9aa	; 0x9aa <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
    1eaa:	2c e3       	ldi	r18, 0x3C	; 60
    1eac:	35 e0       	ldi	r19, 0x05	; 5
    1eae:	47 ed       	ldi	r20, 0xD7	; 215
    1eb0:	5b e0       	ldi	r21, 0x0B	; 11
    1eb2:	64 e8       	ldi	r22, 0x84	; 132
    1eb4:	7e e1       	ldi	r23, 0x1E	; 30
    1eb6:	c9 01       	movw	r24, r18
    1eb8:	0e 94 93 04 	call	0x926	; 0x926 <chVTDoSetI>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    1ebc:	78 94       	sei
      chVTSet(&vt, TIME_MS2I(1000 / 2), Via_Pedestre_Sinal_Amarelo, (void*)&vt);
      break;
  }
}
    1ebe:	08 95       	ret
    1ec0:	08 95       	ret
void PedestreTimer()
{
  switch (LED_PEDESTRE)
  {
    case VERDE:
      palSetPad(IOPORT3, LED_VERDE_PEDESTRE);
    1ec2:	41 9a       	sbi	0x08, 1	; 8
      palClearPad(IOPORT3, LED_VERMELHO_PEDESTRE);
    1ec4:	40 98       	cbi	0x08, 0	; 8
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1ec6:	f8 94       	cli
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
    1ec8:	80 91 3c 05 	lds	r24, 0x053C	; 0x80053c <vt>
    1ecc:	90 91 3d 05 	lds	r25, 0x053D	; 0x80053d <vt+0x1>
    1ed0:	89 2b       	or	r24, r25
    1ed2:	21 f0       	breq	.+8      	; 0x1edc <PedestreTimer+0x58>
    chVTDoResetI(vtp);
    1ed4:	8c e3       	ldi	r24, 0x3C	; 60
    1ed6:	95 e0       	ldi	r25, 0x05	; 5
    1ed8:	0e 94 d5 04 	call	0x9aa	; 0x9aa <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
    1edc:	2c e3       	ldi	r18, 0x3C	; 60
    1ede:	35 e0       	ldi	r19, 0x05	; 5
    1ee0:	4a e2       	ldi	r20, 0x2A	; 42
    1ee2:	5b e0       	ldi	r21, 0x0B	; 11
    1ee4:	68 e0       	ldi	r22, 0x08	; 8
    1ee6:	7d e3       	ldi	r23, 0x3D	; 61
    1ee8:	c9 01       	movw	r24, r18
    1eea:	0e 94 93 04 	call	0x926	; 0x926 <chVTDoSetI>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    1eee:	78 94       	sei
    1ef0:	08 95       	ret

00001ef2 <ProcessEvent>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
    1ef2:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <ch0+0x5>
    1ef6:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <ch0+0x6>
    1efa:	81 e8       	ldi	r24, 0x81	; 129
    1efc:	91 e0       	ldi	r25, 0x01	; 1
    1efe:	96 87       	std	Z+14, r25	; 0x0e
    1f00:	85 87       	std	Z+13, r24	; 0x0d
    1f02:	0a c0       	rjmp	.+20     	; 0x1f18 <ProcessEvent+0x26>
  state_funcion_t state_funcion[] = {PrincipalTimer, SecundariaTimer, PedestreTimer};

  chRegSetThreadName("Process Event");
  while (1)
  {
    switch (STATE)
    1f04:	83 30       	cpi	r24, 0x03	; 3
    1f06:	81 f0       	breq	.+32     	; 0x1f28 <ProcessEvent+0x36>
    1f08:	81 30       	cpi	r24, 0x01	; 1
    1f0a:	19 f4       	brne	.+6      	; 0x1f12 <ProcessEvent+0x20>
    {
      case IDLE_ST:
        break;
    
      case PRINCIPAL:
        state_funcion[PRINCIPAL - 1]();
    1f0c:	49 df       	rcall	.-366    	; 0x1da0 <PrincipalTimer>
        STATE = IDLE_ST;
    1f0e:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <STATE>
        state_funcion[_PEDESTRE - 1]();
        STATE = IDLE_ST;
        break;
    }

    chThdSleepMilliseconds(1);
    1f12:	80 e1       	ldi	r24, 0x10	; 16
    1f14:	90 e0       	ldi	r25, 0x00	; 0
    1f16:	db d8       	rcall	.-3658   	; 0x10ce <chThdSleep>
  state_funcion_t state_funcion[] = {PrincipalTimer, SecundariaTimer, PedestreTimer};

  chRegSetThreadName("Process Event");
  while (1)
  {
    switch (STATE)
    1f18:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <STATE>
    1f1c:	82 30       	cpi	r24, 0x02	; 2
        state_funcion[PRINCIPAL - 1]();
        STATE = IDLE_ST;
        break;
      
      case SECUNDARIA:
        state_funcion[SECUNDARIA - 1]();
    1f1e:	91 f7       	brne	.-28     	; 0x1f04 <ProcessEvent+0x12>
    1f20:	78 df       	rcall	.-272    	; 0x1e12 <SecundariaTimer>
        STATE = IDLE_ST;
    1f22:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <STATE>
        break;
      
      case _PEDESTRE:
        state_funcion[_PEDESTRE - 1]();
    1f26:	f5 cf       	rjmp	.-22     	; 0x1f12 <ProcessEvent+0x20>
    1f28:	ad df       	rcall	.-166    	; 0x1e84 <PedestreTimer>
        STATE = IDLE_ST;
    1f2a:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <STATE>
        break;
    1f2e:	f1 cf       	rjmp	.-30     	; 0x1f12 <ProcessEvent+0x20>

00001f30 <vfprintf>:
    1f30:	ab e0       	ldi	r26, 0x0B	; 11
    1f32:	b0 e0       	ldi	r27, 0x00	; 0
    1f34:	ed e9       	ldi	r30, 0x9D	; 157
    1f36:	ff e0       	ldi	r31, 0x0F	; 15
    1f38:	c4 c2       	rjmp	.+1416   	; 0x24c2 <__prologue_saves__+0x8>
    1f3a:	6c 01       	movw	r12, r24
    1f3c:	7b 01       	movw	r14, r22
    1f3e:	3a 01       	movw	r6, r20
    1f40:	fc 01       	movw	r30, r24
    1f42:	17 82       	std	Z+7, r1	; 0x07
    1f44:	16 82       	std	Z+6, r1	; 0x06
    1f46:	83 81       	ldd	r24, Z+3	; 0x03
    1f48:	81 ff       	sbrs	r24, 1
    1f4a:	ff c0       	rjmp	.+510    	; 0x214a <vfprintf+0x21a>
    1f4c:	ce 01       	movw	r24, r28
    1f4e:	01 96       	adiw	r24, 0x01	; 1
    1f50:	4c 01       	movw	r8, r24
    1f52:	f6 01       	movw	r30, r12
    1f54:	b3 80       	ldd	r11, Z+3	; 0x03
    1f56:	f7 01       	movw	r30, r14
    1f58:	b3 fc       	sbrc	r11, 3
    1f5a:	05 91       	lpm	r16, Z+
    1f5c:	b3 fe       	sbrs	r11, 3
    1f5e:	01 91       	ld	r16, Z+
    1f60:	7f 01       	movw	r14, r30
    1f62:	00 23       	and	r16, r16
    1f64:	41 f1       	breq	.+80     	; 0x1fb6 <vfprintf+0x86>
    1f66:	05 32       	cpi	r16, 0x25	; 37
    1f68:	39 f4       	brne	.+14     	; 0x1f78 <vfprintf+0x48>
    1f6a:	b3 fc       	sbrc	r11, 3
    1f6c:	05 91       	lpm	r16, Z+
    1f6e:	b3 fe       	sbrs	r11, 3
    1f70:	01 91       	ld	r16, Z+
    1f72:	7f 01       	movw	r14, r30
    1f74:	05 32       	cpi	r16, 0x25	; 37
    1f76:	39 f5       	brne	.+78     	; 0x1fc6 <vfprintf+0x96>
    1f78:	b6 01       	movw	r22, r12
    1f7a:	80 2f       	mov	r24, r16
    1f7c:	90 e0       	ldi	r25, 0x00	; 0
    1f7e:	2c d3       	rcall	.+1624   	; 0x25d8 <fputc>
    1f80:	53 01       	movw	r10, r6
    1f82:	35 01       	movw	r6, r10
    1f84:	e6 cf       	rjmp	.-52     	; 0x1f52 <vfprintf+0x22>
    1f86:	10 68       	ori	r17, 0x80	; 128
    1f88:	f7 01       	movw	r30, r14
    1f8a:	b3 fc       	sbrc	r11, 3
    1f8c:	05 91       	lpm	r16, Z+
    1f8e:	b3 fe       	sbrs	r11, 3
    1f90:	01 91       	ld	r16, Z+
    1f92:	7f 01       	movw	r14, r30
    1f94:	17 fd       	sbrc	r17, 7
    1f96:	0d c0       	rjmp	.+26     	; 0x1fb2 <vfprintf+0x82>
    1f98:	00 23       	and	r16, r16
    1f9a:	69 f0       	breq	.+26     	; 0x1fb6 <vfprintf+0x86>
    1f9c:	60 2f       	mov	r22, r16
    1f9e:	70 e0       	ldi	r23, 0x00	; 0
    1fa0:	8f e6       	ldi	r24, 0x6F	; 111
    1fa2:	90 e0       	ldi	r25, 0x00	; 0
    1fa4:	c9 d2       	rcall	.+1426   	; 0x2538 <strchr_P>
    1fa6:	89 2b       	or	r24, r25
    1fa8:	79 f7       	brne	.-34     	; 0x1f88 <vfprintf+0x58>
    1faa:	03 32       	cpi	r16, 0x23	; 35
    1fac:	51 f0       	breq	.+20     	; 0x1fc2 <vfprintf+0x92>
    1fae:	0c 36       	cpi	r16, 0x6C	; 108
    1fb0:	51 f3       	breq	.-44     	; 0x1f86 <vfprintf+0x56>
    1fb2:	01 11       	cpse	r16, r1
    1fb4:	0a c0       	rjmp	.+20     	; 0x1fca <vfprintf+0x9a>
    1fb6:	f6 01       	movw	r30, r12
    1fb8:	86 81       	ldd	r24, Z+6	; 0x06
    1fba:	97 81       	ldd	r25, Z+7	; 0x07
    1fbc:	2b 96       	adiw	r28, 0x0b	; 11
    1fbe:	ee e0       	ldi	r30, 0x0E	; 14
    1fc0:	9c c2       	rjmp	.+1336   	; 0x24fa <__epilogue_restores__+0x8>
    1fc2:	10 e1       	ldi	r17, 0x10	; 16
    1fc4:	e1 cf       	rjmp	.-62     	; 0x1f88 <vfprintf+0x58>
    1fc6:	10 e0       	ldi	r17, 0x00	; 0
    1fc8:	e5 cf       	rjmp	.-54     	; 0x1f94 <vfprintf+0x64>
    1fca:	60 2f       	mov	r22, r16
    1fcc:	70 e0       	ldi	r23, 0x00	; 0
    1fce:	88 e6       	ldi	r24, 0x68	; 104
    1fd0:	90 e0       	ldi	r25, 0x00	; 0
    1fd2:	b2 d2       	rcall	.+1380   	; 0x2538 <strchr_P>
    1fd4:	89 2b       	or	r24, r25
    1fd6:	49 f0       	breq	.+18     	; 0x1fea <vfprintf+0xba>
    1fd8:	53 01       	movw	r10, r6
    1fda:	f4 e0       	ldi	r31, 0x04	; 4
    1fdc:	af 0e       	add	r10, r31
    1fde:	b1 1c       	adc	r11, r1
    1fe0:	b6 01       	movw	r22, r12
    1fe2:	8f e3       	ldi	r24, 0x3F	; 63
    1fe4:	90 e0       	ldi	r25, 0x00	; 0
    1fe6:	f8 d2       	rcall	.+1520   	; 0x25d8 <fputc>
    1fe8:	cc cf       	rjmp	.-104    	; 0x1f82 <vfprintf+0x52>
    1fea:	03 36       	cpi	r16, 0x63	; 99
    1fec:	09 f4       	brne	.+2      	; 0x1ff0 <vfprintf+0xc0>
    1fee:	52 c0       	rjmp	.+164    	; 0x2094 <vfprintf+0x164>
    1ff0:	03 37       	cpi	r16, 0x73	; 115
    1ff2:	09 f4       	brne	.+2      	; 0x1ff6 <vfprintf+0xc6>
    1ff4:	59 c0       	rjmp	.+178    	; 0x20a8 <vfprintf+0x178>
    1ff6:	03 35       	cpi	r16, 0x53	; 83
    1ff8:	09 f4       	brne	.+2      	; 0x1ffc <vfprintf+0xcc>
    1ffa:	55 c0       	rjmp	.+170    	; 0x20a6 <vfprintf+0x176>
    1ffc:	04 36       	cpi	r16, 0x64	; 100
    1ffe:	19 f0       	breq	.+6      	; 0x2006 <vfprintf+0xd6>
    2000:	09 36       	cpi	r16, 0x69	; 105
    2002:	09 f0       	breq	.+2      	; 0x2006 <vfprintf+0xd6>
    2004:	70 c0       	rjmp	.+224    	; 0x20e6 <vfprintf+0x1b6>
    2006:	53 01       	movw	r10, r6
    2008:	17 ff       	sbrs	r17, 7
    200a:	62 c0       	rjmp	.+196    	; 0x20d0 <vfprintf+0x1a0>
    200c:	f4 e0       	ldi	r31, 0x04	; 4
    200e:	af 0e       	add	r10, r31
    2010:	b1 1c       	adc	r11, r1
    2012:	f3 01       	movw	r30, r6
    2014:	60 81       	ld	r22, Z
    2016:	71 81       	ldd	r23, Z+1	; 0x01
    2018:	82 81       	ldd	r24, Z+2	; 0x02
    201a:	93 81       	ldd	r25, Z+3	; 0x03
    201c:	1f 7e       	andi	r17, 0xEF	; 239
    201e:	97 ff       	sbrs	r25, 7
    2020:	08 c0       	rjmp	.+16     	; 0x2032 <vfprintf+0x102>
    2022:	90 95       	com	r25
    2024:	80 95       	com	r24
    2026:	70 95       	com	r23
    2028:	61 95       	neg	r22
    202a:	7f 4f       	sbci	r23, 0xFF	; 255
    202c:	8f 4f       	sbci	r24, 0xFF	; 255
    202e:	9f 4f       	sbci	r25, 0xFF	; 255
    2030:	10 64       	ori	r17, 0x40	; 64
    2032:	2a e0       	ldi	r18, 0x0A	; 10
    2034:	30 e0       	ldi	r19, 0x00	; 0
    2036:	a4 01       	movw	r20, r8
    2038:	17 d3       	rcall	.+1582   	; 0x2668 <__ultoa_invert>
    203a:	08 2f       	mov	r16, r24
    203c:	08 19       	sub	r16, r8
    203e:	16 ff       	sbrs	r17, 6
    2040:	04 c0       	rjmp	.+8      	; 0x204a <vfprintf+0x11a>
    2042:	b6 01       	movw	r22, r12
    2044:	8d e2       	ldi	r24, 0x2D	; 45
    2046:	90 e0       	ldi	r25, 0x00	; 0
    2048:	c7 d2       	rcall	.+1422   	; 0x25d8 <fputc>
    204a:	14 ff       	sbrs	r17, 4
    204c:	13 c0       	rjmp	.+38     	; 0x2074 <vfprintf+0x144>
    204e:	fe 01       	movw	r30, r28
    2050:	e0 0f       	add	r30, r16
    2052:	f1 1d       	adc	r31, r1
    2054:	80 81       	ld	r24, Z
    2056:	80 33       	cpi	r24, 0x30	; 48
    2058:	69 f0       	breq	.+26     	; 0x2074 <vfprintf+0x144>
    205a:	b6 01       	movw	r22, r12
    205c:	80 e3       	ldi	r24, 0x30	; 48
    205e:	90 e0       	ldi	r25, 0x00	; 0
    2060:	bb d2       	rcall	.+1398   	; 0x25d8 <fputc>
    2062:	12 ff       	sbrs	r17, 2
    2064:	07 c0       	rjmp	.+14     	; 0x2074 <vfprintf+0x144>
    2066:	10 72       	andi	r17, 0x20	; 32
    2068:	81 2f       	mov	r24, r17
    206a:	90 e0       	ldi	r25, 0x00	; 0
    206c:	b6 01       	movw	r22, r12
    206e:	88 5a       	subi	r24, 0xA8	; 168
    2070:	9f 4f       	sbci	r25, 0xFF	; 255
    2072:	b2 d2       	rcall	.+1380   	; 0x25d8 <fputc>
    2074:	01 50       	subi	r16, 0x01	; 1
    2076:	10 e0       	ldi	r17, 0x00	; 0
    2078:	0f 5f       	subi	r16, 0xFF	; 255
    207a:	1f 4f       	sbci	r17, 0xFF	; 255
    207c:	08 0d       	add	r16, r8
    207e:	19 1d       	adc	r17, r9
    2080:	f8 01       	movw	r30, r16
    2082:	82 91       	ld	r24, -Z
    2084:	8f 01       	movw	r16, r30
    2086:	b6 01       	movw	r22, r12
    2088:	90 e0       	ldi	r25, 0x00	; 0
    208a:	a6 d2       	rcall	.+1356   	; 0x25d8 <fputc>
    208c:	08 15       	cp	r16, r8
    208e:	19 05       	cpc	r17, r9
    2090:	b9 f7       	brne	.-18     	; 0x2080 <vfprintf+0x150>
    2092:	77 cf       	rjmp	.-274    	; 0x1f82 <vfprintf+0x52>
    2094:	53 01       	movw	r10, r6
    2096:	82 e0       	ldi	r24, 0x02	; 2
    2098:	a8 0e       	add	r10, r24
    209a:	b1 1c       	adc	r11, r1
    209c:	b6 01       	movw	r22, r12
    209e:	f3 01       	movw	r30, r6
    20a0:	80 81       	ld	r24, Z
    20a2:	91 81       	ldd	r25, Z+1	; 0x01
    20a4:	a0 cf       	rjmp	.-192    	; 0x1fe6 <vfprintf+0xb6>
    20a6:	11 60       	ori	r17, 0x01	; 1
    20a8:	53 01       	movw	r10, r6
    20aa:	f2 e0       	ldi	r31, 0x02	; 2
    20ac:	af 0e       	add	r10, r31
    20ae:	b1 1c       	adc	r11, r1
    20b0:	f3 01       	movw	r30, r6
    20b2:	60 80       	ld	r6, Z
    20b4:	71 80       	ldd	r7, Z+1	; 0x01
    20b6:	f3 01       	movw	r30, r6
    20b8:	10 fd       	sbrc	r17, 0
    20ba:	85 91       	lpm	r24, Z+
    20bc:	10 ff       	sbrs	r17, 0
    20be:	81 91       	ld	r24, Z+
    20c0:	3f 01       	movw	r6, r30
    20c2:	88 23       	and	r24, r24
    20c4:	09 f4       	brne	.+2      	; 0x20c8 <vfprintf+0x198>
    20c6:	5d cf       	rjmp	.-326    	; 0x1f82 <vfprintf+0x52>
    20c8:	b6 01       	movw	r22, r12
    20ca:	90 e0       	ldi	r25, 0x00	; 0
    20cc:	85 d2       	rcall	.+1290   	; 0x25d8 <fputc>
    20ce:	f3 cf       	rjmp	.-26     	; 0x20b6 <vfprintf+0x186>
    20d0:	f2 e0       	ldi	r31, 0x02	; 2
    20d2:	af 0e       	add	r10, r31
    20d4:	b1 1c       	adc	r11, r1
    20d6:	f3 01       	movw	r30, r6
    20d8:	60 81       	ld	r22, Z
    20da:	71 81       	ldd	r23, Z+1	; 0x01
    20dc:	07 2e       	mov	r0, r23
    20de:	00 0c       	add	r0, r0
    20e0:	88 0b       	sbc	r24, r24
    20e2:	99 0b       	sbc	r25, r25
    20e4:	9b cf       	rjmp	.-202    	; 0x201c <vfprintf+0xec>
    20e6:	00 37       	cpi	r16, 0x70	; 112
    20e8:	09 f1       	breq	.+66     	; 0x212c <vfprintf+0x1fc>
    20ea:	40 f4       	brcc	.+16     	; 0x20fc <vfprintf+0x1cc>
    20ec:	08 35       	cpi	r16, 0x58	; 88
    20ee:	01 f1       	breq	.+64     	; 0x2130 <vfprintf+0x200>
    20f0:	0f 36       	cpi	r16, 0x6F	; 111
    20f2:	09 f0       	breq	.+2      	; 0x20f6 <vfprintf+0x1c6>
    20f4:	60 cf       	rjmp	.-320    	; 0x1fb6 <vfprintf+0x86>
    20f6:	28 e0       	ldi	r18, 0x08	; 8
    20f8:	30 e0       	ldi	r19, 0x00	; 0
    20fa:	0c c0       	rjmp	.+24     	; 0x2114 <vfprintf+0x1e4>
    20fc:	05 37       	cpi	r16, 0x75	; 117
    20fe:	39 f0       	breq	.+14     	; 0x210e <vfprintf+0x1de>
    2100:	08 37       	cpi	r16, 0x78	; 120
    2102:	09 f0       	breq	.+2      	; 0x2106 <vfprintf+0x1d6>
    2104:	58 cf       	rjmp	.-336    	; 0x1fb6 <vfprintf+0x86>
    2106:	14 62       	ori	r17, 0x24	; 36
    2108:	20 e1       	ldi	r18, 0x10	; 16
    210a:	30 e0       	ldi	r19, 0x00	; 0
    210c:	03 c0       	rjmp	.+6      	; 0x2114 <vfprintf+0x1e4>
    210e:	1f 7e       	andi	r17, 0xEF	; 239
    2110:	2a e0       	ldi	r18, 0x0A	; 10
    2112:	30 e0       	ldi	r19, 0x00	; 0
    2114:	53 01       	movw	r10, r6
    2116:	17 ff       	sbrs	r17, 7
    2118:	0f c0       	rjmp	.+30     	; 0x2138 <vfprintf+0x208>
    211a:	f4 e0       	ldi	r31, 0x04	; 4
    211c:	af 0e       	add	r10, r31
    211e:	b1 1c       	adc	r11, r1
    2120:	f3 01       	movw	r30, r6
    2122:	60 81       	ld	r22, Z
    2124:	71 81       	ldd	r23, Z+1	; 0x01
    2126:	82 81       	ldd	r24, Z+2	; 0x02
    2128:	93 81       	ldd	r25, Z+3	; 0x03
    212a:	85 cf       	rjmp	.-246    	; 0x2036 <vfprintf+0x106>
    212c:	10 61       	ori	r17, 0x10	; 16
    212e:	eb cf       	rjmp	.-42     	; 0x2106 <vfprintf+0x1d6>
    2130:	14 60       	ori	r17, 0x04	; 4
    2132:	20 e1       	ldi	r18, 0x10	; 16
    2134:	32 e0       	ldi	r19, 0x02	; 2
    2136:	ee cf       	rjmp	.-36     	; 0x2114 <vfprintf+0x1e4>
    2138:	f2 e0       	ldi	r31, 0x02	; 2
    213a:	af 0e       	add	r10, r31
    213c:	b1 1c       	adc	r11, r1
    213e:	f3 01       	movw	r30, r6
    2140:	60 81       	ld	r22, Z
    2142:	71 81       	ldd	r23, Z+1	; 0x01
    2144:	90 e0       	ldi	r25, 0x00	; 0
    2146:	80 e0       	ldi	r24, 0x00	; 0
    2148:	76 cf       	rjmp	.-276    	; 0x2036 <vfprintf+0x106>
    214a:	8f ef       	ldi	r24, 0xFF	; 255
    214c:	9f ef       	ldi	r25, 0xFF	; 255
    214e:	36 cf       	rjmp	.-404    	; 0x1fbc <vfprintf+0x8c>

00002150 <putval>:
    2150:	20 fd       	sbrc	r18, 0
    2152:	09 c0       	rjmp	.+18     	; 0x2166 <putval+0x16>
    2154:	fc 01       	movw	r30, r24
    2156:	23 fd       	sbrc	r18, 3
    2158:	05 c0       	rjmp	.+10     	; 0x2164 <putval+0x14>
    215a:	22 ff       	sbrs	r18, 2
    215c:	02 c0       	rjmp	.+4      	; 0x2162 <putval+0x12>
    215e:	73 83       	std	Z+3, r23	; 0x03
    2160:	62 83       	std	Z+2, r22	; 0x02
    2162:	51 83       	std	Z+1, r21	; 0x01
    2164:	40 83       	st	Z, r20
    2166:	08 95       	ret

00002168 <mulacc>:
    2168:	44 fd       	sbrc	r20, 4
    216a:	17 c0       	rjmp	.+46     	; 0x219a <mulacc+0x32>
    216c:	46 fd       	sbrc	r20, 6
    216e:	1d c0       	rjmp	.+58     	; 0x21aa <mulacc+0x42>
    2170:	db 01       	movw	r26, r22
    2172:	fc 01       	movw	r30, r24
    2174:	aa 0f       	add	r26, r26
    2176:	bb 1f       	adc	r27, r27
    2178:	ee 1f       	adc	r30, r30
    217a:	ff 1f       	adc	r31, r31
    217c:	10 94       	com	r1
    217e:	d1 f7       	brne	.-12     	; 0x2174 <mulacc+0xc>
    2180:	6a 0f       	add	r22, r26
    2182:	7b 1f       	adc	r23, r27
    2184:	8e 1f       	adc	r24, r30
    2186:	9f 1f       	adc	r25, r31
    2188:	66 0f       	add	r22, r22
    218a:	77 1f       	adc	r23, r23
    218c:	88 1f       	adc	r24, r24
    218e:	99 1f       	adc	r25, r25
    2190:	62 0f       	add	r22, r18
    2192:	71 1d       	adc	r23, r1
    2194:	81 1d       	adc	r24, r1
    2196:	91 1d       	adc	r25, r1
    2198:	08 95       	ret
    219a:	33 e0       	ldi	r19, 0x03	; 3
    219c:	66 0f       	add	r22, r22
    219e:	77 1f       	adc	r23, r23
    21a0:	88 1f       	adc	r24, r24
    21a2:	99 1f       	adc	r25, r25
    21a4:	31 50       	subi	r19, 0x01	; 1
    21a6:	d1 f7       	brne	.-12     	; 0x219c <mulacc+0x34>
    21a8:	f3 cf       	rjmp	.-26     	; 0x2190 <mulacc+0x28>
    21aa:	34 e0       	ldi	r19, 0x04	; 4
    21ac:	f7 cf       	rjmp	.-18     	; 0x219c <mulacc+0x34>

000021ae <skip_spaces>:
    21ae:	0f 93       	push	r16
    21b0:	1f 93       	push	r17
    21b2:	cf 93       	push	r28
    21b4:	df 93       	push	r29
    21b6:	8c 01       	movw	r16, r24
    21b8:	c8 01       	movw	r24, r16
    21ba:	d2 d1       	rcall	.+932    	; 0x2560 <fgetc>
    21bc:	ec 01       	movw	r28, r24
    21be:	97 fd       	sbrc	r25, 7
    21c0:	06 c0       	rjmp	.+12     	; 0x21ce <skip_spaces+0x20>
    21c2:	b2 d1       	rcall	.+868    	; 0x2528 <isspace>
    21c4:	89 2b       	or	r24, r25
    21c6:	c1 f7       	brne	.-16     	; 0x21b8 <skip_spaces+0xa>
    21c8:	b8 01       	movw	r22, r16
    21ca:	ce 01       	movw	r24, r28
    21cc:	35 d2       	rcall	.+1130   	; 0x2638 <ungetc>
    21ce:	ce 01       	movw	r24, r28
    21d0:	df 91       	pop	r29
    21d2:	cf 91       	pop	r28
    21d4:	1f 91       	pop	r17
    21d6:	0f 91       	pop	r16
    21d8:	08 95       	ret

000021da <conv_int>:
    21da:	8f 92       	push	r8
    21dc:	9f 92       	push	r9
    21de:	af 92       	push	r10
    21e0:	bf 92       	push	r11
    21e2:	ef 92       	push	r14
    21e4:	ff 92       	push	r15
    21e6:	0f 93       	push	r16
    21e8:	1f 93       	push	r17
    21ea:	cf 93       	push	r28
    21ec:	df 93       	push	r29
    21ee:	8c 01       	movw	r16, r24
    21f0:	d6 2f       	mov	r29, r22
    21f2:	7a 01       	movw	r14, r20
    21f4:	b2 2e       	mov	r11, r18
    21f6:	b4 d1       	rcall	.+872    	; 0x2560 <fgetc>
    21f8:	9c 01       	movw	r18, r24
    21fa:	33 27       	eor	r19, r19
    21fc:	2b 32       	cpi	r18, 0x2B	; 43
    21fe:	31 05       	cpc	r19, r1
    2200:	29 f0       	breq	.+10     	; 0x220c <conv_int+0x32>
    2202:	2d 32       	cpi	r18, 0x2D	; 45
    2204:	31 05       	cpc	r19, r1
    2206:	a1 f4       	brne	.+40     	; 0x2230 <conv_int+0x56>
    2208:	68 94       	set
    220a:	b7 f8       	bld	r11, 7
    220c:	d1 50       	subi	r29, 0x01	; 1
    220e:	61 f4       	brne	.+24     	; 0x2228 <conv_int+0x4e>
    2210:	80 e0       	ldi	r24, 0x00	; 0
    2212:	df 91       	pop	r29
    2214:	cf 91       	pop	r28
    2216:	1f 91       	pop	r17
    2218:	0f 91       	pop	r16
    221a:	ff 90       	pop	r15
    221c:	ef 90       	pop	r14
    221e:	bf 90       	pop	r11
    2220:	af 90       	pop	r10
    2222:	9f 90       	pop	r9
    2224:	8f 90       	pop	r8
    2226:	08 95       	ret
    2228:	c8 01       	movw	r24, r16
    222a:	9a d1       	rcall	.+820    	; 0x2560 <fgetc>
    222c:	97 fd       	sbrc	r25, 7
    222e:	f0 cf       	rjmp	.-32     	; 0x2210 <conv_int+0x36>
    2230:	cb 2d       	mov	r28, r11
    2232:	cd 7f       	andi	r28, 0xFD	; 253
    2234:	2b 2d       	mov	r18, r11
    2236:	20 73       	andi	r18, 0x30	; 48
    2238:	e9 f4       	brne	.+58     	; 0x2274 <conv_int+0x9a>
    223a:	80 33       	cpi	r24, 0x30	; 48
    223c:	d9 f4       	brne	.+54     	; 0x2274 <conv_int+0x9a>
    223e:	aa 24       	eor	r10, r10
    2240:	aa 94       	dec	r10
    2242:	ad 0e       	add	r10, r29
    2244:	79 f0       	breq	.+30     	; 0x2264 <conv_int+0x8a>
    2246:	c8 01       	movw	r24, r16
    2248:	8b d1       	rcall	.+790    	; 0x2560 <fgetc>
    224a:	97 fd       	sbrc	r25, 7
    224c:	0b c0       	rjmp	.+22     	; 0x2264 <conv_int+0x8a>
    224e:	28 2f       	mov	r18, r24
    2250:	2f 7d       	andi	r18, 0xDF	; 223
    2252:	28 35       	cpi	r18, 0x58	; 88
    2254:	59 f4       	brne	.+22     	; 0x226c <conv_int+0x92>
    2256:	c2 64       	ori	r28, 0x42	; 66
    2258:	d2 50       	subi	r29, 0x02	; 2
    225a:	21 f0       	breq	.+8      	; 0x2264 <conv_int+0x8a>
    225c:	c8 01       	movw	r24, r16
    225e:	80 d1       	rcall	.+768    	; 0x2560 <fgetc>
    2260:	97 ff       	sbrs	r25, 7
    2262:	08 c0       	rjmp	.+16     	; 0x2274 <conv_int+0x9a>
    2264:	81 2c       	mov	r8, r1
    2266:	91 2c       	mov	r9, r1
    2268:	54 01       	movw	r10, r8
    226a:	1a c0       	rjmp	.+52     	; 0x22a0 <conv_int+0xc6>
    226c:	b6 fe       	sbrs	r11, 6
    226e:	29 c0       	rjmp	.+82     	; 0x22c2 <conv_int+0xe8>
    2270:	c2 60       	ori	r28, 0x02	; 2
    2272:	da 2d       	mov	r29, r10
    2274:	81 2c       	mov	r8, r1
    2276:	91 2c       	mov	r9, r1
    2278:	54 01       	movw	r10, r8
    227a:	20 ed       	ldi	r18, 0xD0	; 208
    227c:	28 0f       	add	r18, r24
    227e:	28 30       	cpi	r18, 0x08	; 8
    2280:	18 f1       	brcs	.+70     	; 0x22c8 <conv_int+0xee>
    2282:	c4 fd       	sbrc	r28, 4
    2284:	09 c0       	rjmp	.+18     	; 0x2298 <conv_int+0xbe>
    2286:	2a 30       	cpi	r18, 0x0A	; 10
    2288:	f8 f0       	brcs	.+62     	; 0x22c8 <conv_int+0xee>
    228a:	c6 ff       	sbrs	r28, 6
    228c:	05 c0       	rjmp	.+10     	; 0x2298 <conv_int+0xbe>
    228e:	2f 7d       	andi	r18, 0xDF	; 223
    2290:	3f ee       	ldi	r19, 0xEF	; 239
    2292:	32 0f       	add	r19, r18
    2294:	36 30       	cpi	r19, 0x06	; 6
    2296:	b8 f0       	brcs	.+46     	; 0x22c6 <conv_int+0xec>
    2298:	b8 01       	movw	r22, r16
    229a:	ce d1       	rcall	.+924    	; 0x2638 <ungetc>
    229c:	c1 ff       	sbrs	r28, 1
    229e:	b8 cf       	rjmp	.-144    	; 0x2210 <conv_int+0x36>
    22a0:	c7 ff       	sbrs	r28, 7
    22a2:	08 c0       	rjmp	.+16     	; 0x22b4 <conv_int+0xda>
    22a4:	b0 94       	com	r11
    22a6:	a0 94       	com	r10
    22a8:	90 94       	com	r9
    22aa:	80 94       	com	r8
    22ac:	81 1c       	adc	r8, r1
    22ae:	91 1c       	adc	r9, r1
    22b0:	a1 1c       	adc	r10, r1
    22b2:	b1 1c       	adc	r11, r1
    22b4:	2c 2f       	mov	r18, r28
    22b6:	b5 01       	movw	r22, r10
    22b8:	a4 01       	movw	r20, r8
    22ba:	c7 01       	movw	r24, r14
    22bc:	49 df       	rcall	.-366    	; 0x2150 <putval>
    22be:	81 e0       	ldi	r24, 0x01	; 1
    22c0:	a8 cf       	rjmp	.-176    	; 0x2212 <conv_int+0x38>
    22c2:	c2 61       	ori	r28, 0x12	; 18
    22c4:	d6 cf       	rjmp	.-84     	; 0x2272 <conv_int+0x98>
    22c6:	27 50       	subi	r18, 0x07	; 7
    22c8:	4c 2f       	mov	r20, r28
    22ca:	c5 01       	movw	r24, r10
    22cc:	b4 01       	movw	r22, r8
    22ce:	4c df       	rcall	.-360    	; 0x2168 <mulacc>
    22d0:	4b 01       	movw	r8, r22
    22d2:	5c 01       	movw	r10, r24
    22d4:	c2 60       	ori	r28, 0x02	; 2
    22d6:	d1 50       	subi	r29, 0x01	; 1
    22d8:	19 f3       	breq	.-58     	; 0x22a0 <conv_int+0xc6>
    22da:	c8 01       	movw	r24, r16
    22dc:	41 d1       	rcall	.+642    	; 0x2560 <fgetc>
    22de:	97 ff       	sbrs	r25, 7
    22e0:	cc cf       	rjmp	.-104    	; 0x227a <conv_int+0xa0>
    22e2:	dc cf       	rjmp	.-72     	; 0x229c <conv_int+0xc2>

000022e4 <vfscanf>:
    22e4:	b0 e0       	ldi	r27, 0x00	; 0
    22e6:	a0 e0       	ldi	r26, 0x00	; 0
    22e8:	e7 e7       	ldi	r30, 0x77	; 119
    22ea:	f1 e1       	ldi	r31, 0x11	; 17
    22ec:	e9 c0       	rjmp	.+466    	; 0x24c0 <__prologue_saves__+0x6>
    22ee:	6c 01       	movw	r12, r24
    22f0:	eb 01       	movw	r28, r22
    22f2:	5a 01       	movw	r10, r20
    22f4:	fc 01       	movw	r30, r24
    22f6:	17 82       	std	Z+7, r1	; 0x07
    22f8:	16 82       	std	Z+6, r1	; 0x06
    22fa:	51 2c       	mov	r5, r1
    22fc:	f6 01       	movw	r30, r12
    22fe:	f3 80       	ldd	r15, Z+3	; 0x03
    2300:	fe 01       	movw	r30, r28
    2302:	f3 fc       	sbrc	r15, 3
    2304:	85 91       	lpm	r24, Z+
    2306:	f3 fe       	sbrs	r15, 3
    2308:	81 91       	ld	r24, Z+
    230a:	18 2f       	mov	r17, r24
    230c:	ef 01       	movw	r28, r30
    230e:	88 23       	and	r24, r24
    2310:	c9 f0       	breq	.+50     	; 0x2344 <vfscanf+0x60>
    2312:	90 e0       	ldi	r25, 0x00	; 0
    2314:	09 d1       	rcall	.+530    	; 0x2528 <isspace>
    2316:	89 2b       	or	r24, r25
    2318:	19 f0       	breq	.+6      	; 0x2320 <vfscanf+0x3c>
    231a:	c6 01       	movw	r24, r12
    231c:	48 df       	rcall	.-368    	; 0x21ae <skip_spaces>
    231e:	ee cf       	rjmp	.-36     	; 0x22fc <vfscanf+0x18>
    2320:	15 32       	cpi	r17, 0x25	; 37
    2322:	41 f4       	brne	.+16     	; 0x2334 <vfscanf+0x50>
    2324:	fe 01       	movw	r30, r28
    2326:	f3 fc       	sbrc	r15, 3
    2328:	15 91       	lpm	r17, Z+
    232a:	f3 fe       	sbrs	r15, 3
    232c:	11 91       	ld	r17, Z+
    232e:	ef 01       	movw	r28, r30
    2330:	15 32       	cpi	r17, 0x25	; 37
    2332:	59 f4       	brne	.+22     	; 0x234a <vfscanf+0x66>
    2334:	c6 01       	movw	r24, r12
    2336:	14 d1       	rcall	.+552    	; 0x2560 <fgetc>
    2338:	97 fd       	sbrc	r25, 7
    233a:	98 c0       	rjmp	.+304    	; 0x246c <vfscanf+0x188>
    233c:	18 17       	cp	r17, r24
    233e:	f1 f2       	breq	.-68     	; 0x22fc <vfscanf+0x18>
    2340:	b6 01       	movw	r22, r12
    2342:	7a d1       	rcall	.+756    	; 0x2638 <ungetc>
    2344:	85 2d       	mov	r24, r5
    2346:	90 e0       	ldi	r25, 0x00	; 0
    2348:	95 c0       	rjmp	.+298    	; 0x2474 <vfscanf+0x190>
    234a:	00 e0       	ldi	r16, 0x00	; 0
    234c:	1a 32       	cpi	r17, 0x2A	; 42
    234e:	31 f4       	brne	.+12     	; 0x235c <vfscanf+0x78>
    2350:	f3 fc       	sbrc	r15, 3
    2352:	15 91       	lpm	r17, Z+
    2354:	f3 fe       	sbrs	r15, 3
    2356:	11 91       	ld	r17, Z+
    2358:	ef 01       	movw	r28, r30
    235a:	01 e0       	ldi	r16, 0x01	; 1
    235c:	e1 2c       	mov	r14, r1
    235e:	20 ed       	ldi	r18, 0xD0	; 208
    2360:	21 0f       	add	r18, r17
    2362:	2a 30       	cpi	r18, 0x0A	; 10
    2364:	38 f1       	brcs	.+78     	; 0x23b4 <vfscanf+0xd0>
    2366:	01 ff       	sbrs	r16, 1
    2368:	34 c0       	rjmp	.+104    	; 0x23d2 <vfscanf+0xee>
    236a:	ee 20       	and	r14, r14
    236c:	59 f3       	breq	.-42     	; 0x2344 <vfscanf+0x60>
    236e:	18 36       	cpi	r17, 0x68	; 104
    2370:	99 f1       	breq	.+102    	; 0x23d8 <vfscanf+0xf4>
    2372:	1c 36       	cpi	r17, 0x6C	; 108
    2374:	09 f4       	brne	.+2      	; 0x2378 <vfscanf+0x94>
    2376:	3a c0       	rjmp	.+116    	; 0x23ec <vfscanf+0x108>
    2378:	11 23       	and	r17, r17
    237a:	21 f3       	breq	.-56     	; 0x2344 <vfscanf+0x60>
    237c:	61 2f       	mov	r22, r17
    237e:	70 e0       	ldi	r23, 0x00	; 0
    2380:	8f e7       	ldi	r24, 0x7F	; 127
    2382:	90 e0       	ldi	r25, 0x00	; 0
    2384:	d9 d0       	rcall	.+434    	; 0x2538 <strchr_P>
    2386:	89 2b       	or	r24, r25
    2388:	e9 f2       	breq	.-70     	; 0x2344 <vfscanf+0x60>
    238a:	91 2c       	mov	r9, r1
    238c:	81 2c       	mov	r8, r1
    238e:	00 fd       	sbrc	r16, 0
    2390:	06 c0       	rjmp	.+12     	; 0x239e <vfscanf+0xba>
    2392:	f5 01       	movw	r30, r10
    2394:	80 80       	ld	r8, Z
    2396:	91 80       	ldd	r9, Z+1	; 0x01
    2398:	c5 01       	movw	r24, r10
    239a:	02 96       	adiw	r24, 0x02	; 2
    239c:	5c 01       	movw	r10, r24
    239e:	1e 36       	cpi	r17, 0x6E	; 110
    23a0:	69 f5       	brne	.+90     	; 0x23fc <vfscanf+0x118>
    23a2:	f6 01       	movw	r30, r12
    23a4:	46 81       	ldd	r20, Z+6	; 0x06
    23a6:	57 81       	ldd	r21, Z+7	; 0x07
    23a8:	70 e0       	ldi	r23, 0x00	; 0
    23aa:	60 e0       	ldi	r22, 0x00	; 0
    23ac:	20 2f       	mov	r18, r16
    23ae:	c4 01       	movw	r24, r8
    23b0:	cf de       	rcall	.-610    	; 0x2150 <putval>
    23b2:	a4 cf       	rjmp	.-184    	; 0x22fc <vfscanf+0x18>
    23b4:	02 60       	ori	r16, 0x02	; 2
    23b6:	6e 2d       	mov	r22, r14
    23b8:	70 e0       	ldi	r23, 0x00	; 0
    23ba:	90 e0       	ldi	r25, 0x00	; 0
    23bc:	80 e0       	ldi	r24, 0x00	; 0
    23be:	40 e2       	ldi	r20, 0x20	; 32
    23c0:	d3 de       	rcall	.-602    	; 0x2168 <mulacc>
    23c2:	e6 2e       	mov	r14, r22
    23c4:	fe 01       	movw	r30, r28
    23c6:	f3 fc       	sbrc	r15, 3
    23c8:	15 91       	lpm	r17, Z+
    23ca:	f3 fe       	sbrs	r15, 3
    23cc:	11 91       	ld	r17, Z+
    23ce:	ef 01       	movw	r28, r30
    23d0:	c6 cf       	rjmp	.-116    	; 0x235e <vfscanf+0x7a>
    23d2:	ee 24       	eor	r14, r14
    23d4:	ea 94       	dec	r14
    23d6:	cb cf       	rjmp	.-106    	; 0x236e <vfscanf+0x8a>
    23d8:	fe 01       	movw	r30, r28
    23da:	f3 fc       	sbrc	r15, 3
    23dc:	15 91       	lpm	r17, Z+
    23de:	f3 fe       	sbrs	r15, 3
    23e0:	11 91       	ld	r17, Z+
    23e2:	ef 01       	movw	r28, r30
    23e4:	18 36       	cpi	r17, 0x68	; 104
    23e6:	09 f0       	breq	.+2      	; 0x23ea <vfscanf+0x106>
    23e8:	c7 cf       	rjmp	.-114    	; 0x2378 <vfscanf+0x94>
    23ea:	08 60       	ori	r16, 0x08	; 8
    23ec:	04 60       	ori	r16, 0x04	; 4
    23ee:	fe 01       	movw	r30, r28
    23f0:	f3 fc       	sbrc	r15, 3
    23f2:	15 91       	lpm	r17, Z+
    23f4:	f3 fe       	sbrs	r15, 3
    23f6:	11 91       	ld	r17, Z+
    23f8:	ef 01       	movw	r28, r30
    23fa:	be cf       	rjmp	.-132    	; 0x2378 <vfscanf+0x94>
    23fc:	13 36       	cpi	r17, 0x63	; 99
    23fe:	b9 f4       	brne	.+46     	; 0x242e <vfscanf+0x14a>
    2400:	01 fd       	sbrc	r16, 1
    2402:	02 c0       	rjmp	.+4      	; 0x2408 <vfscanf+0x124>
    2404:	ee 24       	eor	r14, r14
    2406:	e3 94       	inc	r14
    2408:	c6 01       	movw	r24, r12
    240a:	aa d0       	rcall	.+340    	; 0x2560 <fgetc>
    240c:	97 fd       	sbrc	r25, 7
    240e:	2e c0       	rjmp	.+92     	; 0x246c <vfscanf+0x188>
    2410:	81 14       	cp	r8, r1
    2412:	91 04       	cpc	r9, r1
    2414:	29 f0       	breq	.+10     	; 0x2420 <vfscanf+0x13c>
    2416:	f4 01       	movw	r30, r8
    2418:	80 83       	st	Z, r24
    241a:	c4 01       	movw	r24, r8
    241c:	01 96       	adiw	r24, 0x01	; 1
    241e:	4c 01       	movw	r8, r24
    2420:	ea 94       	dec	r14
    2422:	e1 10       	cpse	r14, r1
    2424:	f1 cf       	rjmp	.-30     	; 0x2408 <vfscanf+0x124>
    2426:	00 fd       	sbrc	r16, 0
    2428:	69 cf       	rjmp	.-302    	; 0x22fc <vfscanf+0x18>
    242a:	53 94       	inc	r5
    242c:	67 cf       	rjmp	.-306    	; 0x22fc <vfscanf+0x18>
    242e:	c6 01       	movw	r24, r12
    2430:	be de       	rcall	.-644    	; 0x21ae <skip_spaces>
    2432:	97 fd       	sbrc	r25, 7
    2434:	1b c0       	rjmp	.+54     	; 0x246c <vfscanf+0x188>
    2436:	1f 36       	cpi	r17, 0x6F	; 111
    2438:	09 f4       	brne	.+2      	; 0x243c <vfscanf+0x158>
    243a:	3d c0       	rjmp	.+122    	; 0x24b6 <vfscanf+0x1d2>
    243c:	30 f4       	brcc	.+12     	; 0x244a <vfscanf+0x166>
    243e:	14 36       	cpi	r17, 0x64	; 100
    2440:	41 f0       	breq	.+16     	; 0x2452 <vfscanf+0x16e>
    2442:	19 36       	cpi	r17, 0x69	; 105
    2444:	39 f0       	breq	.+14     	; 0x2454 <vfscanf+0x170>
    2446:	00 64       	ori	r16, 0x40	; 64
    2448:	05 c0       	rjmp	.+10     	; 0x2454 <vfscanf+0x170>
    244a:	13 37       	cpi	r17, 0x73	; 115
    244c:	11 f1       	breq	.+68     	; 0x2492 <vfscanf+0x1ae>
    244e:	15 37       	cpi	r17, 0x75	; 117
    2450:	d1 f7       	brne	.-12     	; 0x2446 <vfscanf+0x162>
    2452:	00 62       	ori	r16, 0x20	; 32
    2454:	20 2f       	mov	r18, r16
    2456:	a4 01       	movw	r20, r8
    2458:	6e 2d       	mov	r22, r14
    245a:	c6 01       	movw	r24, r12
    245c:	be de       	rcall	.-644    	; 0x21da <conv_int>
    245e:	81 11       	cpse	r24, r1
    2460:	e2 cf       	rjmp	.-60     	; 0x2426 <vfscanf+0x142>
    2462:	f6 01       	movw	r30, r12
    2464:	83 81       	ldd	r24, Z+3	; 0x03
    2466:	80 73       	andi	r24, 0x30	; 48
    2468:	09 f4       	brne	.+2      	; 0x246c <vfscanf+0x188>
    246a:	6c cf       	rjmp	.-296    	; 0x2344 <vfscanf+0x60>
    246c:	8f ef       	ldi	r24, 0xFF	; 255
    246e:	9f ef       	ldi	r25, 0xFF	; 255
    2470:	51 10       	cpse	r5, r1
    2472:	68 cf       	rjmp	.-304    	; 0x2344 <vfscanf+0x60>
    2474:	cd b7       	in	r28, 0x3d	; 61
    2476:	de b7       	in	r29, 0x3e	; 62
    2478:	ef e0       	ldi	r30, 0x0F	; 15
    247a:	3e c0       	rjmp	.+124    	; 0x24f8 <__epilogue_restores__+0x6>
    247c:	81 14       	cp	r8, r1
    247e:	91 04       	cpc	r9, r1
    2480:	29 f0       	breq	.+10     	; 0x248c <vfscanf+0x1a8>
    2482:	f4 01       	movw	r30, r8
    2484:	60 82       	st	Z, r6
    2486:	c4 01       	movw	r24, r8
    2488:	01 96       	adiw	r24, 0x01	; 1
    248a:	4c 01       	movw	r8, r24
    248c:	ea 94       	dec	r14
    248e:	ee 20       	and	r14, r14
    2490:	59 f0       	breq	.+22     	; 0x24a8 <vfscanf+0x1c4>
    2492:	c6 01       	movw	r24, r12
    2494:	65 d0       	rcall	.+202    	; 0x2560 <fgetc>
    2496:	3c 01       	movw	r6, r24
    2498:	97 fd       	sbrc	r25, 7
    249a:	06 c0       	rjmp	.+12     	; 0x24a8 <vfscanf+0x1c4>
    249c:	45 d0       	rcall	.+138    	; 0x2528 <isspace>
    249e:	89 2b       	or	r24, r25
    24a0:	69 f3       	breq	.-38     	; 0x247c <vfscanf+0x198>
    24a2:	b6 01       	movw	r22, r12
    24a4:	c3 01       	movw	r24, r6
    24a6:	c8 d0       	rcall	.+400    	; 0x2638 <ungetc>
    24a8:	81 14       	cp	r8, r1
    24aa:	91 04       	cpc	r9, r1
    24ac:	09 f4       	brne	.+2      	; 0x24b0 <vfscanf+0x1cc>
    24ae:	bb cf       	rjmp	.-138    	; 0x2426 <vfscanf+0x142>
    24b0:	f4 01       	movw	r30, r8
    24b2:	10 82       	st	Z, r1
    24b4:	b8 cf       	rjmp	.-144    	; 0x2426 <vfscanf+0x142>
    24b6:	00 61       	ori	r16, 0x10	; 16
    24b8:	cd cf       	rjmp	.-102    	; 0x2454 <vfscanf+0x170>

000024ba <__prologue_saves__>:
    24ba:	2f 92       	push	r2
    24bc:	3f 92       	push	r3
    24be:	4f 92       	push	r4
    24c0:	5f 92       	push	r5
    24c2:	6f 92       	push	r6
    24c4:	7f 92       	push	r7
    24c6:	8f 92       	push	r8
    24c8:	9f 92       	push	r9
    24ca:	af 92       	push	r10
    24cc:	bf 92       	push	r11
    24ce:	cf 92       	push	r12
    24d0:	df 92       	push	r13
    24d2:	ef 92       	push	r14
    24d4:	ff 92       	push	r15
    24d6:	0f 93       	push	r16
    24d8:	1f 93       	push	r17
    24da:	cf 93       	push	r28
    24dc:	df 93       	push	r29
    24de:	cd b7       	in	r28, 0x3d	; 61
    24e0:	de b7       	in	r29, 0x3e	; 62
    24e2:	ca 1b       	sub	r28, r26
    24e4:	db 0b       	sbc	r29, r27
    24e6:	0f b6       	in	r0, 0x3f	; 63
    24e8:	f8 94       	cli
    24ea:	de bf       	out	0x3e, r29	; 62
    24ec:	0f be       	out	0x3f, r0	; 63
    24ee:	cd bf       	out	0x3d, r28	; 61
    24f0:	09 94       	ijmp

000024f2 <__epilogue_restores__>:
    24f2:	2a 88       	ldd	r2, Y+18	; 0x12
    24f4:	39 88       	ldd	r3, Y+17	; 0x11
    24f6:	48 88       	ldd	r4, Y+16	; 0x10
    24f8:	5f 84       	ldd	r5, Y+15	; 0x0f
    24fa:	6e 84       	ldd	r6, Y+14	; 0x0e
    24fc:	7d 84       	ldd	r7, Y+13	; 0x0d
    24fe:	8c 84       	ldd	r8, Y+12	; 0x0c
    2500:	9b 84       	ldd	r9, Y+11	; 0x0b
    2502:	aa 84       	ldd	r10, Y+10	; 0x0a
    2504:	b9 84       	ldd	r11, Y+9	; 0x09
    2506:	c8 84       	ldd	r12, Y+8	; 0x08
    2508:	df 80       	ldd	r13, Y+7	; 0x07
    250a:	ee 80       	ldd	r14, Y+6	; 0x06
    250c:	fd 80       	ldd	r15, Y+5	; 0x05
    250e:	0c 81       	ldd	r16, Y+4	; 0x04
    2510:	1b 81       	ldd	r17, Y+3	; 0x03
    2512:	aa 81       	ldd	r26, Y+2	; 0x02
    2514:	b9 81       	ldd	r27, Y+1	; 0x01
    2516:	ce 0f       	add	r28, r30
    2518:	d1 1d       	adc	r29, r1
    251a:	0f b6       	in	r0, 0x3f	; 63
    251c:	f8 94       	cli
    251e:	de bf       	out	0x3e, r29	; 62
    2520:	0f be       	out	0x3f, r0	; 63
    2522:	cd bf       	out	0x3d, r28	; 61
    2524:	ed 01       	movw	r28, r26
    2526:	08 95       	ret

00002528 <isspace>:
    2528:	91 11       	cpse	r25, r1
    252a:	fc c0       	rjmp	.+504    	; 0x2724 <__ctype_isfalse>
    252c:	80 32       	cpi	r24, 0x20	; 32
    252e:	19 f0       	breq	.+6      	; 0x2536 <isspace+0xe>
    2530:	89 50       	subi	r24, 0x09	; 9
    2532:	85 50       	subi	r24, 0x05	; 5
    2534:	d0 f7       	brcc	.-12     	; 0x252a <isspace+0x2>
    2536:	08 95       	ret

00002538 <strchr_P>:
    2538:	fc 01       	movw	r30, r24
    253a:	05 90       	lpm	r0, Z+
    253c:	06 16       	cp	r0, r22
    253e:	21 f0       	breq	.+8      	; 0x2548 <strchr_P+0x10>
    2540:	00 20       	and	r0, r0
    2542:	d9 f7       	brne	.-10     	; 0x253a <strchr_P+0x2>
    2544:	c0 01       	movw	r24, r0
    2546:	08 95       	ret
    2548:	31 97       	sbiw	r30, 0x01	; 1
    254a:	cf 01       	movw	r24, r30
    254c:	08 95       	ret

0000254e <memcpy>:
    254e:	fb 01       	movw	r30, r22
    2550:	dc 01       	movw	r26, r24
    2552:	02 c0       	rjmp	.+4      	; 0x2558 <memcpy+0xa>
    2554:	01 90       	ld	r0, Z+
    2556:	0d 92       	st	X+, r0
    2558:	41 50       	subi	r20, 0x01	; 1
    255a:	50 40       	sbci	r21, 0x00	; 0
    255c:	d8 f7       	brcc	.-10     	; 0x2554 <memcpy+0x6>
    255e:	08 95       	ret

00002560 <fgetc>:
    2560:	cf 93       	push	r28
    2562:	df 93       	push	r29
    2564:	ec 01       	movw	r28, r24
    2566:	2b 81       	ldd	r18, Y+3	; 0x03
    2568:	20 ff       	sbrs	r18, 0
    256a:	1a c0       	rjmp	.+52     	; 0x25a0 <fgetc+0x40>
    256c:	26 ff       	sbrs	r18, 6
    256e:	0c c0       	rjmp	.+24     	; 0x2588 <fgetc+0x28>
    2570:	2f 7b       	andi	r18, 0xBF	; 191
    2572:	2b 83       	std	Y+3, r18	; 0x03
    2574:	8e 81       	ldd	r24, Y+6	; 0x06
    2576:	9f 81       	ldd	r25, Y+7	; 0x07
    2578:	01 96       	adiw	r24, 0x01	; 1
    257a:	9f 83       	std	Y+7, r25	; 0x07
    257c:	8e 83       	std	Y+6, r24	; 0x06
    257e:	8a 81       	ldd	r24, Y+2	; 0x02
    2580:	90 e0       	ldi	r25, 0x00	; 0
    2582:	df 91       	pop	r29
    2584:	cf 91       	pop	r28
    2586:	08 95       	ret
    2588:	22 ff       	sbrs	r18, 2
    258a:	18 c0       	rjmp	.+48     	; 0x25bc <fgetc+0x5c>
    258c:	e8 81       	ld	r30, Y
    258e:	f9 81       	ldd	r31, Y+1	; 0x01
    2590:	80 81       	ld	r24, Z
    2592:	08 2e       	mov	r0, r24
    2594:	00 0c       	add	r0, r0
    2596:	99 0b       	sbc	r25, r25
    2598:	00 97       	sbiw	r24, 0x00	; 0
    259a:	29 f4       	brne	.+10     	; 0x25a6 <fgetc+0x46>
    259c:	20 62       	ori	r18, 0x20	; 32
    259e:	2b 83       	std	Y+3, r18	; 0x03
    25a0:	8f ef       	ldi	r24, 0xFF	; 255
    25a2:	9f ef       	ldi	r25, 0xFF	; 255
    25a4:	ee cf       	rjmp	.-36     	; 0x2582 <fgetc+0x22>
    25a6:	31 96       	adiw	r30, 0x01	; 1
    25a8:	f9 83       	std	Y+1, r31	; 0x01
    25aa:	e8 83       	st	Y, r30
    25ac:	2e 81       	ldd	r18, Y+6	; 0x06
    25ae:	3f 81       	ldd	r19, Y+7	; 0x07
    25b0:	2f 5f       	subi	r18, 0xFF	; 255
    25b2:	3f 4f       	sbci	r19, 0xFF	; 255
    25b4:	3f 83       	std	Y+7, r19	; 0x07
    25b6:	2e 83       	std	Y+6, r18	; 0x06
    25b8:	99 27       	eor	r25, r25
    25ba:	e3 cf       	rjmp	.-58     	; 0x2582 <fgetc+0x22>
    25bc:	ea 85       	ldd	r30, Y+10	; 0x0a
    25be:	fb 85       	ldd	r31, Y+11	; 0x0b
    25c0:	09 95       	icall
    25c2:	97 ff       	sbrs	r25, 7
    25c4:	f3 cf       	rjmp	.-26     	; 0x25ac <fgetc+0x4c>
    25c6:	2b 81       	ldd	r18, Y+3	; 0x03
    25c8:	01 96       	adiw	r24, 0x01	; 1
    25ca:	21 f0       	breq	.+8      	; 0x25d4 <fgetc+0x74>
    25cc:	80 e2       	ldi	r24, 0x20	; 32
    25ce:	82 2b       	or	r24, r18
    25d0:	8b 83       	std	Y+3, r24	; 0x03
    25d2:	e6 cf       	rjmp	.-52     	; 0x25a0 <fgetc+0x40>
    25d4:	80 e1       	ldi	r24, 0x10	; 16
    25d6:	fb cf       	rjmp	.-10     	; 0x25ce <fgetc+0x6e>

000025d8 <fputc>:
    25d8:	0f 93       	push	r16
    25da:	1f 93       	push	r17
    25dc:	cf 93       	push	r28
    25de:	df 93       	push	r29
    25e0:	18 2f       	mov	r17, r24
    25e2:	09 2f       	mov	r16, r25
    25e4:	eb 01       	movw	r28, r22
    25e6:	8b 81       	ldd	r24, Y+3	; 0x03
    25e8:	81 fd       	sbrc	r24, 1
    25ea:	09 c0       	rjmp	.+18     	; 0x25fe <fputc+0x26>
    25ec:	1f ef       	ldi	r17, 0xFF	; 255
    25ee:	0f ef       	ldi	r16, 0xFF	; 255
    25f0:	81 2f       	mov	r24, r17
    25f2:	90 2f       	mov	r25, r16
    25f4:	df 91       	pop	r29
    25f6:	cf 91       	pop	r28
    25f8:	1f 91       	pop	r17
    25fa:	0f 91       	pop	r16
    25fc:	08 95       	ret
    25fe:	82 ff       	sbrs	r24, 2
    2600:	14 c0       	rjmp	.+40     	; 0x262a <fputc+0x52>
    2602:	2e 81       	ldd	r18, Y+6	; 0x06
    2604:	3f 81       	ldd	r19, Y+7	; 0x07
    2606:	8c 81       	ldd	r24, Y+4	; 0x04
    2608:	9d 81       	ldd	r25, Y+5	; 0x05
    260a:	28 17       	cp	r18, r24
    260c:	39 07       	cpc	r19, r25
    260e:	3c f4       	brge	.+14     	; 0x261e <fputc+0x46>
    2610:	e8 81       	ld	r30, Y
    2612:	f9 81       	ldd	r31, Y+1	; 0x01
    2614:	cf 01       	movw	r24, r30
    2616:	01 96       	adiw	r24, 0x01	; 1
    2618:	99 83       	std	Y+1, r25	; 0x01
    261a:	88 83       	st	Y, r24
    261c:	10 83       	st	Z, r17
    261e:	8e 81       	ldd	r24, Y+6	; 0x06
    2620:	9f 81       	ldd	r25, Y+7	; 0x07
    2622:	01 96       	adiw	r24, 0x01	; 1
    2624:	9f 83       	std	Y+7, r25	; 0x07
    2626:	8e 83       	std	Y+6, r24	; 0x06
    2628:	e3 cf       	rjmp	.-58     	; 0x25f0 <fputc+0x18>
    262a:	e8 85       	ldd	r30, Y+8	; 0x08
    262c:	f9 85       	ldd	r31, Y+9	; 0x09
    262e:	81 2f       	mov	r24, r17
    2630:	09 95       	icall
    2632:	89 2b       	or	r24, r25
    2634:	a1 f3       	breq	.-24     	; 0x261e <fputc+0x46>
    2636:	da cf       	rjmp	.-76     	; 0x25ec <fputc+0x14>

00002638 <ungetc>:
    2638:	fb 01       	movw	r30, r22
    263a:	23 81       	ldd	r18, Z+3	; 0x03
    263c:	20 ff       	sbrs	r18, 0
    263e:	11 c0       	rjmp	.+34     	; 0x2662 <ungetc+0x2a>
    2640:	26 fd       	sbrc	r18, 6
    2642:	0f c0       	rjmp	.+30     	; 0x2662 <ungetc+0x2a>
    2644:	8f 3f       	cpi	r24, 0xFF	; 255
    2646:	98 07       	cpc	r25, r24
    2648:	71 f0       	breq	.+28     	; 0x2666 <ungetc+0x2e>
    264a:	82 83       	std	Z+2, r24	; 0x02
    264c:	2f 7d       	andi	r18, 0xDF	; 223
    264e:	20 64       	ori	r18, 0x40	; 64
    2650:	23 83       	std	Z+3, r18	; 0x03
    2652:	26 81       	ldd	r18, Z+6	; 0x06
    2654:	37 81       	ldd	r19, Z+7	; 0x07
    2656:	21 50       	subi	r18, 0x01	; 1
    2658:	31 09       	sbc	r19, r1
    265a:	37 83       	std	Z+7, r19	; 0x07
    265c:	26 83       	std	Z+6, r18	; 0x06
    265e:	99 27       	eor	r25, r25
    2660:	08 95       	ret
    2662:	8f ef       	ldi	r24, 0xFF	; 255
    2664:	9f ef       	ldi	r25, 0xFF	; 255
    2666:	08 95       	ret

00002668 <__ultoa_invert>:
    2668:	fa 01       	movw	r30, r20
    266a:	aa 27       	eor	r26, r26
    266c:	28 30       	cpi	r18, 0x08	; 8
    266e:	51 f1       	breq	.+84     	; 0x26c4 <__ultoa_invert+0x5c>
    2670:	20 31       	cpi	r18, 0x10	; 16
    2672:	81 f1       	breq	.+96     	; 0x26d4 <__ultoa_invert+0x6c>
    2674:	e8 94       	clt
    2676:	6f 93       	push	r22
    2678:	6e 7f       	andi	r22, 0xFE	; 254
    267a:	6e 5f       	subi	r22, 0xFE	; 254
    267c:	7f 4f       	sbci	r23, 0xFF	; 255
    267e:	8f 4f       	sbci	r24, 0xFF	; 255
    2680:	9f 4f       	sbci	r25, 0xFF	; 255
    2682:	af 4f       	sbci	r26, 0xFF	; 255
    2684:	b1 e0       	ldi	r27, 0x01	; 1
    2686:	3e d0       	rcall	.+124    	; 0x2704 <__ultoa_invert+0x9c>
    2688:	b4 e0       	ldi	r27, 0x04	; 4
    268a:	3c d0       	rcall	.+120    	; 0x2704 <__ultoa_invert+0x9c>
    268c:	67 0f       	add	r22, r23
    268e:	78 1f       	adc	r23, r24
    2690:	89 1f       	adc	r24, r25
    2692:	9a 1f       	adc	r25, r26
    2694:	a1 1d       	adc	r26, r1
    2696:	68 0f       	add	r22, r24
    2698:	79 1f       	adc	r23, r25
    269a:	8a 1f       	adc	r24, r26
    269c:	91 1d       	adc	r25, r1
    269e:	a1 1d       	adc	r26, r1
    26a0:	6a 0f       	add	r22, r26
    26a2:	71 1d       	adc	r23, r1
    26a4:	81 1d       	adc	r24, r1
    26a6:	91 1d       	adc	r25, r1
    26a8:	a1 1d       	adc	r26, r1
    26aa:	20 d0       	rcall	.+64     	; 0x26ec <__ultoa_invert+0x84>
    26ac:	09 f4       	brne	.+2      	; 0x26b0 <__ultoa_invert+0x48>
    26ae:	68 94       	set
    26b0:	3f 91       	pop	r19
    26b2:	2a e0       	ldi	r18, 0x0A	; 10
    26b4:	26 9f       	mul	r18, r22
    26b6:	11 24       	eor	r1, r1
    26b8:	30 19       	sub	r19, r0
    26ba:	30 5d       	subi	r19, 0xD0	; 208
    26bc:	31 93       	st	Z+, r19
    26be:	de f6       	brtc	.-74     	; 0x2676 <__ultoa_invert+0xe>
    26c0:	cf 01       	movw	r24, r30
    26c2:	08 95       	ret
    26c4:	46 2f       	mov	r20, r22
    26c6:	47 70       	andi	r20, 0x07	; 7
    26c8:	40 5d       	subi	r20, 0xD0	; 208
    26ca:	41 93       	st	Z+, r20
    26cc:	b3 e0       	ldi	r27, 0x03	; 3
    26ce:	0f d0       	rcall	.+30     	; 0x26ee <__ultoa_invert+0x86>
    26d0:	c9 f7       	brne	.-14     	; 0x26c4 <__ultoa_invert+0x5c>
    26d2:	f6 cf       	rjmp	.-20     	; 0x26c0 <__ultoa_invert+0x58>
    26d4:	46 2f       	mov	r20, r22
    26d6:	4f 70       	andi	r20, 0x0F	; 15
    26d8:	40 5d       	subi	r20, 0xD0	; 208
    26da:	4a 33       	cpi	r20, 0x3A	; 58
    26dc:	18 f0       	brcs	.+6      	; 0x26e4 <__ultoa_invert+0x7c>
    26de:	49 5d       	subi	r20, 0xD9	; 217
    26e0:	31 fd       	sbrc	r19, 1
    26e2:	40 52       	subi	r20, 0x20	; 32
    26e4:	41 93       	st	Z+, r20
    26e6:	02 d0       	rcall	.+4      	; 0x26ec <__ultoa_invert+0x84>
    26e8:	a9 f7       	brne	.-22     	; 0x26d4 <__ultoa_invert+0x6c>
    26ea:	ea cf       	rjmp	.-44     	; 0x26c0 <__ultoa_invert+0x58>
    26ec:	b4 e0       	ldi	r27, 0x04	; 4
    26ee:	a6 95       	lsr	r26
    26f0:	97 95       	ror	r25
    26f2:	87 95       	ror	r24
    26f4:	77 95       	ror	r23
    26f6:	67 95       	ror	r22
    26f8:	ba 95       	dec	r27
    26fa:	c9 f7       	brne	.-14     	; 0x26ee <__ultoa_invert+0x86>
    26fc:	00 97       	sbiw	r24, 0x00	; 0
    26fe:	61 05       	cpc	r22, r1
    2700:	71 05       	cpc	r23, r1
    2702:	08 95       	ret
    2704:	9b 01       	movw	r18, r22
    2706:	ac 01       	movw	r20, r24
    2708:	0a 2e       	mov	r0, r26
    270a:	06 94       	lsr	r0
    270c:	57 95       	ror	r21
    270e:	47 95       	ror	r20
    2710:	37 95       	ror	r19
    2712:	27 95       	ror	r18
    2714:	ba 95       	dec	r27
    2716:	c9 f7       	brne	.-14     	; 0x270a <__ultoa_invert+0xa2>
    2718:	62 0f       	add	r22, r18
    271a:	73 1f       	adc	r23, r19
    271c:	84 1f       	adc	r24, r20
    271e:	95 1f       	adc	r25, r21
    2720:	a0 1d       	adc	r26, r0
    2722:	08 95       	ret

00002724 <__ctype_isfalse>:
    2724:	99 27       	eor	r25, r25
    2726:	88 27       	eor	r24, r24

00002728 <__ctype_istrue>:
    2728:	08 95       	ret

0000272a <_exit>:
    272a:	f8 94       	cli

0000272c <__stop_program>:
    272c:	ff cf       	rjmp	.-2      	; 0x272c <__stop_program>

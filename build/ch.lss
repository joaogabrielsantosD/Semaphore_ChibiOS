
build/ch.elf: formato do arquivo elf32-avr

Seções:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000084  00800100  00002108  0000219c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002108  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000046a  00800184  00800184  00002220  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00002220  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002234  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000740  00000000  00000000  00002274  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001a5dd  00000000  00000000  000029b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004afe  00000000  00000000  0001cf91  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00008003  00000000  00000000  00021a8f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001470  00000000  00000000  00029a94  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000023c1  00000000  00000000  0002af04  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006921  00000000  00000000  0002d2c5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000a30  00000000  00000000  00033be6  2**0
                  CONTENTS, READONLY, DEBUGGING

Desmontagem da seção .text:

00000000 <__vectors>:
       0:	44 c0       	rjmp	.+136    	; 0x8a <__ctors_end>
       2:	00 00       	nop
       4:	5f c0       	rjmp	.+190    	; 0xc4 <__bad_interrupt>
       6:	00 00       	nop
       8:	5d c0       	rjmp	.+186    	; 0xc4 <__bad_interrupt>
       a:	00 00       	nop
       c:	5b c0       	rjmp	.+182    	; 0xc4 <__bad_interrupt>
       e:	00 00       	nop
      10:	59 c0       	rjmp	.+178    	; 0xc4 <__bad_interrupt>
      12:	00 00       	nop
      14:	57 c0       	rjmp	.+174    	; 0xc4 <__bad_interrupt>
      16:	00 00       	nop
      18:	55 c0       	rjmp	.+170    	; 0xc4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	53 c0       	rjmp	.+166    	; 0xc4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	51 c0       	rjmp	.+162    	; 0xc4 <__bad_interrupt>
      22:	00 00       	nop
      24:	4f c0       	rjmp	.+158    	; 0xc4 <__bad_interrupt>
      26:	00 00       	nop
      28:	4d c0       	rjmp	.+154    	; 0xc4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4b c0       	rjmp	.+150    	; 0xc4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	49 c0       	rjmp	.+146    	; 0xc4 <__bad_interrupt>
      32:	00 00       	nop
      34:	47 c0       	rjmp	.+142    	; 0xc4 <__bad_interrupt>
      36:	00 00       	nop
      38:	6d c3       	rjmp	.+1754   	; 0x714 <__vector_14>
      3a:	00 00       	nop
      3c:	43 c0       	rjmp	.+134    	; 0xc4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	41 c0       	rjmp	.+130    	; 0xc4 <__bad_interrupt>
      42:	00 00       	nop
      44:	3f c0       	rjmp	.+126    	; 0xc4 <__bad_interrupt>
      46:	00 00       	nop
      48:	a0 c3       	rjmp	.+1856   	; 0x78a <__vector_18>
      4a:	00 00       	nop
      4c:	dc c3       	rjmp	.+1976   	; 0x806 <__vector_19>
      4e:	00 00       	nop
      50:	39 c0       	rjmp	.+114    	; 0xc4 <__bad_interrupt>
      52:	00 00       	nop
      54:	37 c0       	rjmp	.+110    	; 0xc4 <__bad_interrupt>
      56:	00 00       	nop
      58:	35 c0       	rjmp	.+106    	; 0xc4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	33 c0       	rjmp	.+102    	; 0xc4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	31 c0       	rjmp	.+98     	; 0xc4 <__bad_interrupt>
      62:	00 00       	nop
      64:	2f c0       	rjmp	.+94     	; 0xc4 <__bad_interrupt>
	...

00000068 <__trampolines_end>:
      68:	45 46       	sbci	r20, 0x65	; 101
      6a:	47 65       	ori	r20, 0x57	; 87
      6c:	66 67       	ori	r22, 0x76	; 118
	...

0000006f <__c.2210>:
      6f:	20 2b 2d 2e 30 31 32 33 34 35 36 37 38 39 68 00      +-.0123456789h.

0000007f <__c.2345>:
      7f:	63 64 69 6e 6f 70 73 75 78 58 00                    cdinopsuxX.

0000008a <__ctors_end>:
      8a:	11 24       	eor	r1, r1
      8c:	1f be       	out	0x3f, r1	; 63
      8e:	cf ef       	ldi	r28, 0xFF	; 255
      90:	d8 e0       	ldi	r29, 0x08	; 8
      92:	de bf       	out	0x3e, r29	; 62
      94:	cd bf       	out	0x3d, r28	; 61

00000096 <__do_copy_data>:
      96:	11 e0       	ldi	r17, 0x01	; 1
      98:	a0 e0       	ldi	r26, 0x00	; 0
      9a:	b1 e0       	ldi	r27, 0x01	; 1
      9c:	e8 e0       	ldi	r30, 0x08	; 8
      9e:	f1 e2       	ldi	r31, 0x21	; 33
      a0:	02 c0       	rjmp	.+4      	; 0xa6 <__do_copy_data+0x10>
      a2:	05 90       	lpm	r0, Z+
      a4:	0d 92       	st	X+, r0
      a6:	a4 38       	cpi	r26, 0x84	; 132
      a8:	b1 07       	cpc	r27, r17
      aa:	d9 f7       	brne	.-10     	; 0xa2 <__do_copy_data+0xc>

000000ac <__do_clear_bss>:
      ac:	25 e0       	ldi	r18, 0x05	; 5
      ae:	a4 e8       	ldi	r26, 0x84	; 132
      b0:	b1 e0       	ldi	r27, 0x01	; 1
      b2:	01 c0       	rjmp	.+2      	; 0xb6 <.do_clear_bss_start>

000000b4 <.do_clear_bss_loop>:
      b4:	1d 92       	st	X+, r1

000000b6 <.do_clear_bss_start>:
      b6:	ae 3e       	cpi	r26, 0xEE	; 238
      b8:	b2 07       	cpc	r27, r18
      ba:	e1 f7       	brne	.-8      	; 0xb4 <.do_clear_bss_loop>
      bc:	0e 94 42 0b 	call	0x1684	; 0x1684 <main>
      c0:	0c 94 82 10 	jmp	0x2104	; 0x2104 <_exit>

000000c4 <__bad_interrupt>:
      c4:	9d cf       	rjmp	.-198    	; 0x0 <__vectors>

000000c6 <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
      c6:	f3 d2       	rcall	.+1510   	; 0x6ae <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
#else
  palInit(&pal_default_config);
      c8:	84 e1       	ldi	r24, 0x14	; 20
      ca:	91 e0       	ldi	r25, 0x01	; 1
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
      cc:	f1 d2       	rcall	.+1506   	; 0x6b0 <_pal_lld_init>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
      ce:	74 d2       	rcall	.+1256   	; 0x5b8 <sdInit>
      d0:	ea d2       	rcall	.+1492   	; 0x6a6 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
      d2:	00 c0       	rjmp	.+0      	; 0xd4 <stInit>

000000d4 <stInit>:

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
      d4:	4a c3       	rjmp	.+1684   	; 0x76a <st_lld_init>

000000d6 <iq_read>:
  if ((wr > (size_t)0) && (nfy != NULL)) {
    nfy(oqp);
  }

  return wr;
}
      d6:	af 92       	push	r10
      d8:	bf 92       	push	r11
      da:	cf 92       	push	r12
      dc:	df 92       	push	r13
      de:	ef 92       	push	r14
      e0:	ff 92       	push	r15
      e2:	0f 93       	push	r16
      e4:	1f 93       	push	r17
      e6:	cf 93       	push	r28
      e8:	df 93       	push	r29
      ea:	ec 01       	movw	r28, r24
      ec:	6b 01       	movw	r12, r22
      ee:	8a 01       	movw	r16, r20
      f0:	8c 81       	ldd	r24, Y+4	; 0x04
      f2:	9d 81       	ldd	r25, Y+5	; 0x05
      f4:	84 17       	cp	r24, r20
      f6:	95 07       	cpc	r25, r21
      f8:	10 f4       	brcc	.+4      	; 0xfe <iq_read+0x28>
      fa:	0c 81       	ldd	r16, Y+4	; 0x04
      fc:	1d 81       	ldd	r17, Y+5	; 0x05
      fe:	6c 85       	ldd	r22, Y+12	; 0x0c
     100:	7d 85       	ldd	r23, Y+13	; 0x0d
     102:	e8 84       	ldd	r14, Y+8	; 0x08
     104:	f9 84       	ldd	r15, Y+9	; 0x09
     106:	e6 1a       	sub	r14, r22
     108:	f7 0a       	sbc	r15, r23
     10a:	0e 15       	cp	r16, r14
     10c:	1f 05       	cpc	r17, r15
     10e:	98 f1       	brcs	.+102    	; 0x176 <iq_read+0xa0>
     110:	e0 16       	cp	r14, r16
     112:	f1 06       	cpc	r15, r17
     114:	d0 f0       	brcs	.+52     	; 0x14a <iq_read+0x74>
     116:	a8 01       	movw	r20, r16
     118:	c6 01       	movw	r24, r12
     11a:	0e 94 67 0f 	call	0x1ece	; 0x1ece <memcpy>
     11e:	8e 81       	ldd	r24, Y+6	; 0x06
     120:	9f 81       	ldd	r25, Y+7	; 0x07
     122:	9d 87       	std	Y+13, r25	; 0x0d
     124:	8c 87       	std	Y+12, r24	; 0x0c
     126:	8c 81       	ldd	r24, Y+4	; 0x04
     128:	9d 81       	ldd	r25, Y+5	; 0x05
     12a:	80 1b       	sub	r24, r16
     12c:	91 0b       	sbc	r25, r17
     12e:	9d 83       	std	Y+5, r25	; 0x05
     130:	8c 83       	std	Y+4, r24	; 0x04
     132:	c8 01       	movw	r24, r16
     134:	df 91       	pop	r29
     136:	cf 91       	pop	r28
     138:	1f 91       	pop	r17
     13a:	0f 91       	pop	r16
     13c:	ff 90       	pop	r15
     13e:	ef 90       	pop	r14
     140:	df 90       	pop	r13
     142:	cf 90       	pop	r12
     144:	bf 90       	pop	r11
     146:	af 90       	pop	r10
     148:	08 95       	ret
     14a:	a7 01       	movw	r20, r14
     14c:	c6 01       	movw	r24, r12
     14e:	0e 94 67 0f 	call	0x1ece	; 0x1ece <memcpy>
     152:	58 01       	movw	r10, r16
     154:	ae 18       	sub	r10, r14
     156:	bf 08       	sbc	r11, r15
     158:	6e 81       	ldd	r22, Y+6	; 0x06
     15a:	7f 81       	ldd	r23, Y+7	; 0x07
     15c:	a5 01       	movw	r20, r10
     15e:	c6 01       	movw	r24, r12
     160:	8e 0d       	add	r24, r14
     162:	9f 1d       	adc	r25, r15
     164:	0e 94 67 0f 	call	0x1ece	; 0x1ece <memcpy>
     168:	4e 81       	ldd	r20, Y+6	; 0x06
     16a:	5f 81       	ldd	r21, Y+7	; 0x07
     16c:	4a 0d       	add	r20, r10
     16e:	5b 1d       	adc	r21, r11
     170:	5d 87       	std	Y+13, r21	; 0x0d
     172:	4c 87       	std	Y+12, r20	; 0x0c
     174:	d8 cf       	rjmp	.-80     	; 0x126 <iq_read+0x50>
     176:	a8 01       	movw	r20, r16
     178:	c6 01       	movw	r24, r12
     17a:	0e 94 67 0f 	call	0x1ece	; 0x1ece <memcpy>
     17e:	8c 85       	ldd	r24, Y+12	; 0x0c
     180:	9d 85       	ldd	r25, Y+13	; 0x0d
     182:	80 0f       	add	r24, r16
     184:	91 1f       	adc	r25, r17
     186:	9d 87       	std	Y+13, r25	; 0x0d
     188:	8c 87       	std	Y+12, r24	; 0x0c
     18a:	cd cf       	rjmp	.-102    	; 0x126 <iq_read+0x50>

0000018c <oq_write>:
     18c:	af 92       	push	r10
     18e:	bf 92       	push	r11
     190:	cf 92       	push	r12
     192:	df 92       	push	r13
     194:	ef 92       	push	r14
     196:	ff 92       	push	r15
     198:	0f 93       	push	r16
     19a:	1f 93       	push	r17
     19c:	cf 93       	push	r28
     19e:	df 93       	push	r29
     1a0:	ec 01       	movw	r28, r24
     1a2:	6b 01       	movw	r12, r22
     1a4:	8a 01       	movw	r16, r20
     1a6:	8c 81       	ldd	r24, Y+4	; 0x04
     1a8:	9d 81       	ldd	r25, Y+5	; 0x05
     1aa:	84 17       	cp	r24, r20
     1ac:	95 07       	cpc	r25, r21
     1ae:	10 f4       	brcc	.+4      	; 0x1b4 <oq_write+0x28>
     1b0:	0c 81       	ldd	r16, Y+4	; 0x04
     1b2:	1d 81       	ldd	r17, Y+5	; 0x05
     1b4:	8a 85       	ldd	r24, Y+10	; 0x0a
     1b6:	9b 85       	ldd	r25, Y+11	; 0x0b
     1b8:	e8 84       	ldd	r14, Y+8	; 0x08
     1ba:	f9 84       	ldd	r15, Y+9	; 0x09
     1bc:	e8 1a       	sub	r14, r24
     1be:	f9 0a       	sbc	r15, r25
     1c0:	0e 15       	cp	r16, r14
     1c2:	1f 05       	cpc	r17, r15
     1c4:	98 f1       	brcs	.+102    	; 0x22c <oq_write+0xa0>
     1c6:	e0 16       	cp	r14, r16
     1c8:	f1 06       	cpc	r15, r17
     1ca:	d0 f0       	brcs	.+52     	; 0x200 <oq_write+0x74>
     1cc:	a8 01       	movw	r20, r16
     1ce:	b6 01       	movw	r22, r12
     1d0:	0e 94 67 0f 	call	0x1ece	; 0x1ece <memcpy>
     1d4:	8e 81       	ldd	r24, Y+6	; 0x06
     1d6:	9f 81       	ldd	r25, Y+7	; 0x07
     1d8:	9b 87       	std	Y+11, r25	; 0x0b
     1da:	8a 87       	std	Y+10, r24	; 0x0a
     1dc:	8c 81       	ldd	r24, Y+4	; 0x04
     1de:	9d 81       	ldd	r25, Y+5	; 0x05
     1e0:	80 1b       	sub	r24, r16
     1e2:	91 0b       	sbc	r25, r17
     1e4:	9d 83       	std	Y+5, r25	; 0x05
     1e6:	8c 83       	std	Y+4, r24	; 0x04
     1e8:	c8 01       	movw	r24, r16
     1ea:	df 91       	pop	r29
     1ec:	cf 91       	pop	r28
     1ee:	1f 91       	pop	r17
     1f0:	0f 91       	pop	r16
     1f2:	ff 90       	pop	r15
     1f4:	ef 90       	pop	r14
     1f6:	df 90       	pop	r13
     1f8:	cf 90       	pop	r12
     1fa:	bf 90       	pop	r11
     1fc:	af 90       	pop	r10
     1fe:	08 95       	ret
     200:	a7 01       	movw	r20, r14
     202:	b6 01       	movw	r22, r12
     204:	0e 94 67 0f 	call	0x1ece	; 0x1ece <memcpy>
     208:	58 01       	movw	r10, r16
     20a:	ae 18       	sub	r10, r14
     20c:	bf 08       	sbc	r11, r15
     20e:	b6 01       	movw	r22, r12
     210:	6e 0d       	add	r22, r14
     212:	7f 1d       	adc	r23, r15
     214:	a5 01       	movw	r20, r10
     216:	8e 81       	ldd	r24, Y+6	; 0x06
     218:	9f 81       	ldd	r25, Y+7	; 0x07
     21a:	0e 94 67 0f 	call	0x1ece	; 0x1ece <memcpy>
     21e:	4e 81       	ldd	r20, Y+6	; 0x06
     220:	5f 81       	ldd	r21, Y+7	; 0x07
     222:	4a 0d       	add	r20, r10
     224:	5b 1d       	adc	r21, r11
     226:	5b 87       	std	Y+11, r21	; 0x0b
     228:	4a 87       	std	Y+10, r20	; 0x0a
     22a:	d8 cf       	rjmp	.-80     	; 0x1dc <oq_write+0x50>
     22c:	a8 01       	movw	r20, r16
     22e:	b6 01       	movw	r22, r12
     230:	0e 94 67 0f 	call	0x1ece	; 0x1ece <memcpy>
     234:	8a 85       	ldd	r24, Y+10	; 0x0a
     236:	9b 85       	ldd	r25, Y+11	; 0x0b
     238:	80 0f       	add	r24, r16
     23a:	91 1f       	adc	r25, r17
     23c:	9b 87       	std	Y+11, r25	; 0x0b
     23e:	8a 87       	std	Y+10, r24	; 0x0a
     240:	cd cf       	rjmp	.-102    	; 0x1dc <oq_write+0x50>

00000242 <iqObjectInit>:
     242:	0f 93       	push	r16
     244:	1f 93       	push	r17
     246:	fc 01       	movw	r30, r24
     248:	91 83       	std	Z+1, r25	; 0x01
     24a:	80 83       	st	Z, r24
     24c:	93 83       	std	Z+3, r25	; 0x03
     24e:	82 83       	std	Z+2, r24	; 0x02
     250:	15 82       	std	Z+5, r1	; 0x05
     252:	14 82       	std	Z+4, r1	; 0x04
     254:	77 83       	std	Z+7, r23	; 0x07
     256:	66 83       	std	Z+6, r22	; 0x06
     258:	75 87       	std	Z+13, r23	; 0x0d
     25a:	64 87       	std	Z+12, r22	; 0x0c
     25c:	73 87       	std	Z+11, r23	; 0x0b
     25e:	62 87       	std	Z+10, r22	; 0x0a
     260:	64 0f       	add	r22, r20
     262:	75 1f       	adc	r23, r21
     264:	71 87       	std	Z+9, r23	; 0x09
     266:	60 87       	std	Z+8, r22	; 0x08
     268:	37 87       	std	Z+15, r19	; 0x0f
     26a:	26 87       	std	Z+14, r18	; 0x0e
     26c:	11 8b       	std	Z+17, r17	; 0x11
     26e:	00 8b       	std	Z+16, r16	; 0x10
     270:	1f 91       	pop	r17
     272:	0f 91       	pop	r16
     274:	08 95       	ret

00000276 <iqPutI>:
     276:	fc 01       	movw	r30, r24
     278:	a2 85       	ldd	r26, Z+10	; 0x0a
     27a:	b3 85       	ldd	r27, Z+11	; 0x0b
     27c:	84 85       	ldd	r24, Z+12	; 0x0c
     27e:	95 85       	ldd	r25, Z+13	; 0x0d
     280:	a8 17       	cp	r26, r24
     282:	b9 07       	cpc	r27, r25
     284:	e1 f0       	breq	.+56     	; 0x2be <iqPutI+0x48>
     286:	84 81       	ldd	r24, Z+4	; 0x04
     288:	95 81       	ldd	r25, Z+5	; 0x05
     28a:	01 96       	adiw	r24, 0x01	; 1
     28c:	95 83       	std	Z+5, r25	; 0x05
     28e:	84 83       	std	Z+4, r24	; 0x04
     290:	cd 01       	movw	r24, r26
     292:	01 96       	adiw	r24, 0x01	; 1
     294:	93 87       	std	Z+11, r25	; 0x0b
     296:	82 87       	std	Z+10, r24	; 0x0a
     298:	6c 93       	st	X, r22
     29a:	22 85       	ldd	r18, Z+10	; 0x0a
     29c:	33 85       	ldd	r19, Z+11	; 0x0b
     29e:	80 85       	ldd	r24, Z+8	; 0x08
     2a0:	91 85       	ldd	r25, Z+9	; 0x09
     2a2:	28 17       	cp	r18, r24
     2a4:	39 07       	cpc	r19, r25
     2a6:	20 f0       	brcs	.+8      	; 0x2b0 <iqPutI+0x3a>
     2a8:	86 81       	ldd	r24, Z+6	; 0x06
     2aa:	97 81       	ldd	r25, Z+7	; 0x07
     2ac:	93 87       	std	Z+11, r25	; 0x0b
     2ae:	82 87       	std	Z+10, r24	; 0x0a
     2b0:	cf 01       	movw	r24, r30
     2b2:	70 e0       	ldi	r23, 0x00	; 0
     2b4:	60 e0       	ldi	r22, 0x00	; 0
     2b6:	2e d7       	rcall	.+3676   	; 0x1114 <chThdDequeueNextI>
     2b8:	90 e0       	ldi	r25, 0x00	; 0
     2ba:	80 e0       	ldi	r24, 0x00	; 0
     2bc:	08 95       	ret
     2be:	84 81       	ldd	r24, Z+4	; 0x04
     2c0:	95 81       	ldd	r25, Z+5	; 0x05
     2c2:	89 2b       	or	r24, r25
     2c4:	01 f3       	breq	.-64     	; 0x286 <iqPutI+0x10>
     2c6:	8f ef       	ldi	r24, 0xFF	; 255
     2c8:	9f ef       	ldi	r25, 0xFF	; 255
     2ca:	08 95       	ret

000002cc <iqGetTimeout>:
     2cc:	0f 93       	push	r16
     2ce:	1f 93       	push	r17
     2d0:	cf 93       	push	r28
     2d2:	df 93       	push	r29
     2d4:	ec 01       	movw	r28, r24
     2d6:	8b 01       	movw	r16, r22
     2d8:	f8 94       	cli
     2da:	05 c0       	rjmp	.+10     	; 0x2e6 <iqGetTimeout+0x1a>
     2dc:	b8 01       	movw	r22, r16
     2de:	ce 01       	movw	r24, r28
     2e0:	fc d6       	rcall	.+3576   	; 0x10da <chThdEnqueueTimeoutS>
     2e2:	97 fd       	sbrc	r25, 7
     2e4:	27 c0       	rjmp	.+78     	; 0x334 <iqGetTimeout+0x68>
     2e6:	8c 81       	ldd	r24, Y+4	; 0x04
     2e8:	9d 81       	ldd	r25, Y+5	; 0x05
     2ea:	89 2b       	or	r24, r25
     2ec:	b9 f3       	breq	.-18     	; 0x2dc <iqGetTimeout+0x10>
     2ee:	8c 81       	ldd	r24, Y+4	; 0x04
     2f0:	9d 81       	ldd	r25, Y+5	; 0x05
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	9d 83       	std	Y+5, r25	; 0x05
     2f6:	8c 83       	std	Y+4, r24	; 0x04
     2f8:	ec 85       	ldd	r30, Y+12	; 0x0c
     2fa:	fd 85       	ldd	r31, Y+13	; 0x0d
     2fc:	cf 01       	movw	r24, r30
     2fe:	01 96       	adiw	r24, 0x01	; 1
     300:	9d 87       	std	Y+13, r25	; 0x0d
     302:	8c 87       	std	Y+12, r24	; 0x0c
     304:	10 81       	ld	r17, Z
     306:	28 85       	ldd	r18, Y+8	; 0x08
     308:	39 85       	ldd	r19, Y+9	; 0x09
     30a:	82 17       	cp	r24, r18
     30c:	93 07       	cpc	r25, r19
     30e:	20 f0       	brcs	.+8      	; 0x318 <iqGetTimeout+0x4c>
     310:	8e 81       	ldd	r24, Y+6	; 0x06
     312:	9f 81       	ldd	r25, Y+7	; 0x07
     314:	9d 87       	std	Y+13, r25	; 0x0d
     316:	8c 87       	std	Y+12, r24	; 0x0c
     318:	ee 85       	ldd	r30, Y+14	; 0x0e
     31a:	ff 85       	ldd	r31, Y+15	; 0x0f
     31c:	30 97       	sbiw	r30, 0x00	; 0
     31e:	11 f0       	breq	.+4      	; 0x324 <iqGetTimeout+0x58>
     320:	ce 01       	movw	r24, r28
     322:	09 95       	icall
     324:	78 94       	sei
     326:	81 2f       	mov	r24, r17
     328:	90 e0       	ldi	r25, 0x00	; 0
     32a:	df 91       	pop	r29
     32c:	cf 91       	pop	r28
     32e:	1f 91       	pop	r17
     330:	0f 91       	pop	r16
     332:	08 95       	ret
     334:	78 94       	sei
     336:	df 91       	pop	r29
     338:	cf 91       	pop	r28
     33a:	1f 91       	pop	r17
     33c:	0f 91       	pop	r16
     33e:	08 95       	ret

00000340 <iqReadTimeout>:
     340:	6f 92       	push	r6
     342:	7f 92       	push	r7
     344:	8f 92       	push	r8
     346:	9f 92       	push	r9
     348:	af 92       	push	r10
     34a:	bf 92       	push	r11
     34c:	cf 92       	push	r12
     34e:	df 92       	push	r13
     350:	ef 92       	push	r14
     352:	ff 92       	push	r15
     354:	0f 93       	push	r16
     356:	1f 93       	push	r17
     358:	cf 93       	push	r28
     35a:	df 93       	push	r29
     35c:	6c 01       	movw	r12, r24
     35e:	7b 01       	movw	r14, r22
     360:	4a 01       	movw	r8, r20
     362:	39 01       	movw	r6, r18
     364:	fc 01       	movw	r30, r24
     366:	a6 84       	ldd	r10, Z+14	; 0x0e
     368:	b7 84       	ldd	r11, Z+15	; 0x0f
     36a:	f8 94       	cli
     36c:	41 15       	cp	r20, r1
     36e:	51 05       	cpc	r21, r1
     370:	b9 f0       	breq	.+46     	; 0x3a0 <iqReadTimeout+0x60>
     372:	8a 01       	movw	r16, r20
     374:	a8 01       	movw	r20, r16
     376:	b7 01       	movw	r22, r14
     378:	c6 01       	movw	r24, r12
     37a:	ad de       	rcall	.-678    	; 0xd6 <iq_read>
     37c:	ec 01       	movw	r28, r24
     37e:	89 2b       	or	r24, r25
     380:	01 f1       	breq	.+64     	; 0x3c2 <iqReadTimeout+0x82>
     382:	a1 14       	cp	r10, r1
     384:	b1 04       	cpc	r11, r1
     386:	19 f0       	breq	.+6      	; 0x38e <iqReadTimeout+0x4e>
     388:	c6 01       	movw	r24, r12
     38a:	f5 01       	movw	r30, r10
     38c:	09 95       	icall
     38e:	78 94       	sei
     390:	0c 1b       	sub	r16, r28
     392:	1d 0b       	sbc	r17, r29
     394:	ec 0e       	add	r14, r28
     396:	fd 1e       	adc	r15, r29
     398:	f8 94       	cli
     39a:	01 15       	cp	r16, r1
     39c:	11 05       	cpc	r17, r1
     39e:	51 f7       	brne	.-44     	; 0x374 <iqReadTimeout+0x34>
     3a0:	c4 01       	movw	r24, r8
     3a2:	78 94       	sei
     3a4:	df 91       	pop	r29
     3a6:	cf 91       	pop	r28
     3a8:	1f 91       	pop	r17
     3aa:	0f 91       	pop	r16
     3ac:	ff 90       	pop	r15
     3ae:	ef 90       	pop	r14
     3b0:	df 90       	pop	r13
     3b2:	cf 90       	pop	r12
     3b4:	bf 90       	pop	r11
     3b6:	af 90       	pop	r10
     3b8:	9f 90       	pop	r9
     3ba:	8f 90       	pop	r8
     3bc:	7f 90       	pop	r7
     3be:	6f 90       	pop	r6
     3c0:	08 95       	ret
     3c2:	b3 01       	movw	r22, r6
     3c4:	c6 01       	movw	r24, r12
     3c6:	89 d6       	rcall	.+3346   	; 0x10da <chThdEnqueueTimeoutS>
     3c8:	89 2b       	or	r24, r25
     3ca:	a1 f2       	breq	.-88     	; 0x374 <iqReadTimeout+0x34>
     3cc:	c4 01       	movw	r24, r8
     3ce:	80 1b       	sub	r24, r16
     3d0:	91 0b       	sbc	r25, r17
     3d2:	e7 cf       	rjmp	.-50     	; 0x3a2 <iqReadTimeout+0x62>

000003d4 <oqObjectInit>:
     3d4:	0f 93       	push	r16
     3d6:	1f 93       	push	r17
     3d8:	fc 01       	movw	r30, r24
     3da:	91 83       	std	Z+1, r25	; 0x01
     3dc:	80 83       	st	Z, r24
     3de:	93 83       	std	Z+3, r25	; 0x03
     3e0:	82 83       	std	Z+2, r24	; 0x02
     3e2:	55 83       	std	Z+5, r21	; 0x05
     3e4:	44 83       	std	Z+4, r20	; 0x04
     3e6:	77 83       	std	Z+7, r23	; 0x07
     3e8:	66 83       	std	Z+6, r22	; 0x06
     3ea:	75 87       	std	Z+13, r23	; 0x0d
     3ec:	64 87       	std	Z+12, r22	; 0x0c
     3ee:	73 87       	std	Z+11, r23	; 0x0b
     3f0:	62 87       	std	Z+10, r22	; 0x0a
     3f2:	64 0f       	add	r22, r20
     3f4:	75 1f       	adc	r23, r21
     3f6:	71 87       	std	Z+9, r23	; 0x09
     3f8:	60 87       	std	Z+8, r22	; 0x08
     3fa:	37 87       	std	Z+15, r19	; 0x0f
     3fc:	26 87       	std	Z+14, r18	; 0x0e
     3fe:	11 8b       	std	Z+17, r17	; 0x11
     400:	00 8b       	std	Z+16, r16	; 0x10
     402:	1f 91       	pop	r17
     404:	0f 91       	pop	r16
     406:	08 95       	ret

00000408 <oqPutTimeout>:
     408:	ff 92       	push	r15
     40a:	0f 93       	push	r16
     40c:	1f 93       	push	r17
     40e:	cf 93       	push	r28
     410:	df 93       	push	r29
     412:	ec 01       	movw	r28, r24
     414:	f6 2e       	mov	r15, r22
     416:	8a 01       	movw	r16, r20
     418:	f8 94       	cli
     41a:	05 c0       	rjmp	.+10     	; 0x426 <oqPutTimeout+0x1e>
     41c:	b8 01       	movw	r22, r16
     41e:	ce 01       	movw	r24, r28
     420:	5c d6       	rcall	.+3256   	; 0x10da <chThdEnqueueTimeoutS>
     422:	97 fd       	sbrc	r25, 7
     424:	2a c0       	rjmp	.+84     	; 0x47a <oqPutTimeout+0x72>
     426:	8c 81       	ldd	r24, Y+4	; 0x04
     428:	9d 81       	ldd	r25, Y+5	; 0x05
     42a:	89 2b       	or	r24, r25
     42c:	b9 f3       	breq	.-18     	; 0x41c <oqPutTimeout+0x14>
     42e:	8c 81       	ldd	r24, Y+4	; 0x04
     430:	9d 81       	ldd	r25, Y+5	; 0x05
     432:	01 97       	sbiw	r24, 0x01	; 1
     434:	9d 83       	std	Y+5, r25	; 0x05
     436:	8c 83       	std	Y+4, r24	; 0x04
     438:	ea 85       	ldd	r30, Y+10	; 0x0a
     43a:	fb 85       	ldd	r31, Y+11	; 0x0b
     43c:	cf 01       	movw	r24, r30
     43e:	01 96       	adiw	r24, 0x01	; 1
     440:	9b 87       	std	Y+11, r25	; 0x0b
     442:	8a 87       	std	Y+10, r24	; 0x0a
     444:	f0 82       	st	Z, r15
     446:	2a 85       	ldd	r18, Y+10	; 0x0a
     448:	3b 85       	ldd	r19, Y+11	; 0x0b
     44a:	88 85       	ldd	r24, Y+8	; 0x08
     44c:	99 85       	ldd	r25, Y+9	; 0x09
     44e:	28 17       	cp	r18, r24
     450:	39 07       	cpc	r19, r25
     452:	20 f0       	brcs	.+8      	; 0x45c <oqPutTimeout+0x54>
     454:	8e 81       	ldd	r24, Y+6	; 0x06
     456:	9f 81       	ldd	r25, Y+7	; 0x07
     458:	9b 87       	std	Y+11, r25	; 0x0b
     45a:	8a 87       	std	Y+10, r24	; 0x0a
     45c:	ee 85       	ldd	r30, Y+14	; 0x0e
     45e:	ff 85       	ldd	r31, Y+15	; 0x0f
     460:	30 97       	sbiw	r30, 0x00	; 0
     462:	11 f0       	breq	.+4      	; 0x468 <oqPutTimeout+0x60>
     464:	ce 01       	movw	r24, r28
     466:	09 95       	icall
     468:	78 94       	sei
     46a:	90 e0       	ldi	r25, 0x00	; 0
     46c:	80 e0       	ldi	r24, 0x00	; 0
     46e:	df 91       	pop	r29
     470:	cf 91       	pop	r28
     472:	1f 91       	pop	r17
     474:	0f 91       	pop	r16
     476:	ff 90       	pop	r15
     478:	08 95       	ret
     47a:	78 94       	sei
     47c:	df 91       	pop	r29
     47e:	cf 91       	pop	r28
     480:	1f 91       	pop	r17
     482:	0f 91       	pop	r16
     484:	ff 90       	pop	r15
     486:	08 95       	ret

00000488 <oqGetI>:
     488:	cf 93       	push	r28
     48a:	fc 01       	movw	r30, r24
     48c:	a4 85       	ldd	r26, Z+12	; 0x0c
     48e:	b5 85       	ldd	r27, Z+13	; 0x0d
     490:	82 85       	ldd	r24, Z+10	; 0x0a
     492:	93 85       	ldd	r25, Z+11	; 0x0b
     494:	8a 17       	cp	r24, r26
     496:	9b 07       	cpc	r25, r27
     498:	e1 f0       	breq	.+56     	; 0x4d2 <oqGetI+0x4a>
     49a:	84 81       	ldd	r24, Z+4	; 0x04
     49c:	95 81       	ldd	r25, Z+5	; 0x05
     49e:	01 96       	adiw	r24, 0x01	; 1
     4a0:	95 83       	std	Z+5, r25	; 0x05
     4a2:	84 83       	std	Z+4, r24	; 0x04
     4a4:	cd 01       	movw	r24, r26
     4a6:	01 96       	adiw	r24, 0x01	; 1
     4a8:	95 87       	std	Z+13, r25	; 0x0d
     4aa:	84 87       	std	Z+12, r24	; 0x0c
     4ac:	cc 91       	ld	r28, X
     4ae:	20 85       	ldd	r18, Z+8	; 0x08
     4b0:	31 85       	ldd	r19, Z+9	; 0x09
     4b2:	82 17       	cp	r24, r18
     4b4:	93 07       	cpc	r25, r19
     4b6:	40 f4       	brcc	.+16     	; 0x4c8 <oqGetI+0x40>
     4b8:	cf 01       	movw	r24, r30
     4ba:	70 e0       	ldi	r23, 0x00	; 0
     4bc:	60 e0       	ldi	r22, 0x00	; 0
     4be:	2a d6       	rcall	.+3156   	; 0x1114 <chThdDequeueNextI>
     4c0:	8c 2f       	mov	r24, r28
     4c2:	90 e0       	ldi	r25, 0x00	; 0
     4c4:	cf 91       	pop	r28
     4c6:	08 95       	ret
     4c8:	86 81       	ldd	r24, Z+6	; 0x06
     4ca:	97 81       	ldd	r25, Z+7	; 0x07
     4cc:	95 87       	std	Z+13, r25	; 0x0d
     4ce:	84 87       	std	Z+12, r24	; 0x0c
     4d0:	f3 cf       	rjmp	.-26     	; 0x4b8 <oqGetI+0x30>
     4d2:	84 81       	ldd	r24, Z+4	; 0x04
     4d4:	95 81       	ldd	r25, Z+5	; 0x05
     4d6:	89 2b       	or	r24, r25
     4d8:	01 f3       	breq	.-64     	; 0x49a <oqGetI+0x12>
     4da:	8f ef       	ldi	r24, 0xFF	; 255
     4dc:	9f ef       	ldi	r25, 0xFF	; 255
     4de:	cf 91       	pop	r28
     4e0:	08 95       	ret

000004e2 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
     4e2:	6f 92       	push	r6
     4e4:	7f 92       	push	r7
     4e6:	8f 92       	push	r8
     4e8:	9f 92       	push	r9
     4ea:	af 92       	push	r10
     4ec:	bf 92       	push	r11
     4ee:	cf 92       	push	r12
     4f0:	df 92       	push	r13
     4f2:	ef 92       	push	r14
     4f4:	ff 92       	push	r15
     4f6:	0f 93       	push	r16
     4f8:	1f 93       	push	r17
     4fa:	cf 93       	push	r28
     4fc:	df 93       	push	r29
     4fe:	6c 01       	movw	r12, r24
     500:	7b 01       	movw	r14, r22
     502:	4a 01       	movw	r8, r20
     504:	39 01       	movw	r6, r18
  qnotify_t nfy = oqp->q_notify;
     506:	fc 01       	movw	r30, r24
     508:	a6 84       	ldd	r10, Z+14	; 0x0e
     50a:	b7 84       	ldd	r11, Z+15	; 0x0f
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
     50c:	f8 94       	cli

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
     50e:	41 15       	cp	r20, r1
     510:	51 05       	cpc	r21, r1
     512:	b9 f0       	breq	.+46     	; 0x542 <oqWriteTimeout+0x60>
     514:	8a 01       	movw	r16, r20
    size_t done;

    done = oq_write(oqp, bp, n);
     516:	a8 01       	movw	r20, r16
     518:	b7 01       	movw	r22, r14
     51a:	c6 01       	movw	r24, r12
     51c:	37 de       	rcall	.-914    	; 0x18c <oq_write>
     51e:	ec 01       	movw	r28, r24
    if (done == (size_t)0) {
     520:	89 2b       	or	r24, r25
     522:	01 f1       	breq	.+64     	; 0x564 <oqWriteTimeout+0x82>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
     524:	a1 14       	cp	r10, r1
     526:	b1 04       	cpc	r11, r1
     528:	19 f0       	breq	.+6      	; 0x530 <oqWriteTimeout+0x4e>
        nfy(oqp);
     52a:	c6 01       	movw	r24, r12
     52c:	f5 01       	movw	r30, r10
     52e:	09 95       	icall
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
     530:	78 94       	sei
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
     532:	0c 1b       	sub	r16, r28
     534:	1d 0b       	sbc	r17, r29
      bp += done;
     536:	ec 0e       	add	r14, r28
     538:	fd 1e       	adc	r15, r29
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
     53a:	f8 94       	cli

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
     53c:	01 15       	cp	r16, r1
     53e:	11 05       	cpc	r17, r1
     540:	51 f7       	brne	.-44     	; 0x516 <oqWriteTimeout+0x34>
     542:	c4 01       	movw	r24, r8
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
     544:	78 94       	sei
    }
  }

  osalSysUnlock();
  return max - n;
}
     546:	df 91       	pop	r29
     548:	cf 91       	pop	r28
     54a:	1f 91       	pop	r17
     54c:	0f 91       	pop	r16
     54e:	ff 90       	pop	r15
     550:	ef 90       	pop	r14
     552:	df 90       	pop	r13
     554:	cf 90       	pop	r12
     556:	bf 90       	pop	r11
     558:	af 90       	pop	r10
     55a:	9f 90       	pop	r9
     55c:	8f 90       	pop	r8
     55e:	7f 90       	pop	r7
     560:	6f 90       	pop	r6
     562:	08 95       	ret
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {

  return chThdEnqueueTimeoutS(tqp, timeout);
     564:	b3 01       	movw	r22, r6
     566:	c6 01       	movw	r24, r12
     568:	b8 d5       	rcall	.+2928   	; 0x10da <chThdEnqueueTimeoutS>
    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
     56a:	89 2b       	or	r24, r25
     56c:	a1 f2       	breq	.-88     	; 0x516 <oqWriteTimeout+0x34>
     56e:	c4 01       	movw	r24, r8
     570:	80 1b       	sub	r24, r16
     572:	91 0b       	sbc	r25, r17
     574:	e7 cf       	rjmp	.-50     	; 0x544 <oqWriteTimeout+0x62>

00000576 <_readt>:
  oqResetI(&sdp->oqueue);
  iqResetI(&sdp->iqueue);
  osalOsRescheduleS();

  osalSysUnlock();
}
     576:	05 96       	adiw	r24, 0x05	; 5
     578:	e3 ce       	rjmp	.-570    	; 0x340 <iqReadTimeout>

0000057a <_read>:
     57a:	2f ef       	ldi	r18, 0xFF	; 255
     57c:	3f ef       	ldi	r19, 0xFF	; 255
     57e:	05 96       	adiw	r24, 0x05	; 5
     580:	df ce       	rjmp	.-578    	; 0x340 <iqReadTimeout>

00000582 <_writet>:
     582:	47 96       	adiw	r24, 0x17	; 23
     584:	ae cf       	rjmp	.-164    	; 0x4e2 <oqWriteTimeout>

00000586 <_write>:
     586:	2f ef       	ldi	r18, 0xFF	; 255
     588:	3f ef       	ldi	r19, 0xFF	; 255
     58a:	47 96       	adiw	r24, 0x17	; 23
     58c:	aa cf       	rjmp	.-172    	; 0x4e2 <oqWriteTimeout>

0000058e <_gett>:
     58e:	05 96       	adiw	r24, 0x05	; 5
     590:	9d ce       	rjmp	.-710    	; 0x2cc <iqGetTimeout>

00000592 <_get>:
     592:	6f ef       	ldi	r22, 0xFF	; 255
     594:	7f ef       	ldi	r23, 0xFF	; 255
     596:	05 96       	adiw	r24, 0x05	; 5
     598:	99 ce       	rjmp	.-718    	; 0x2cc <iqGetTimeout>

0000059a <_putt>:
     59a:	47 96       	adiw	r24, 0x17	; 23
     59c:	35 cf       	rjmp	.-406    	; 0x408 <oqPutTimeout>

0000059e <_put>:
     59e:	4f ef       	ldi	r20, 0xFF	; 255
     5a0:	5f ef       	ldi	r21, 0xFF	; 255
     5a2:	47 96       	adiw	r24, 0x17	; 23
     5a4:	31 cf       	rjmp	.-414    	; 0x408 <oqPutTimeout>

000005a6 <_ctl>:
     5a6:	61 30       	cpi	r22, 0x01	; 1
     5a8:	71 05       	cpc	r23, r1
     5aa:	19 f0       	breq	.+6      	; 0x5b2 <_ctl+0xc>
     5ac:	8c ee       	ldi	r24, 0xEC	; 236
     5ae:	9f ef       	ldi	r25, 0xFF	; 255
     5b0:	08 95       	ret
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	80 e0       	ldi	r24, 0x00	; 0
     5b6:	08 95       	ret

000005b8 <sdInit>:
     5b8:	5d c1       	rjmp	.+698    	; 0x874 <sd_lld_init>

000005ba <sdObjectInit>:
     5ba:	ef 92       	push	r14
     5bc:	ff 92       	push	r15
     5be:	0f 93       	push	r16
     5c0:	1f 93       	push	r17
     5c2:	cf 93       	push	r28
     5c4:	df 93       	push	r29
     5c6:	ec 01       	movw	r28, r24
     5c8:	9b 01       	movw	r18, r22
     5ca:	7a 01       	movw	r14, r20
     5cc:	fc 01       	movw	r30, r24
     5ce:	80 e0       	ldi	r24, 0x00	; 0
     5d0:	91 e0       	ldi	r25, 0x01	; 1
     5d2:	81 93       	st	Z+, r24
     5d4:	91 93       	st	Z+, r25
     5d6:	fb 83       	std	Y+3, r31	; 0x03
     5d8:	ea 83       	std	Y+2, r30	; 0x02
     5da:	81 e0       	ldi	r24, 0x01	; 1
     5dc:	8c 83       	std	Y+4, r24	; 0x04
     5de:	be 01       	movw	r22, r28
     5e0:	67 5d       	subi	r22, 0xD7	; 215
     5e2:	7f 4f       	sbci	r23, 0xFF	; 255
     5e4:	8e 01       	movw	r16, r28
     5e6:	40 e1       	ldi	r20, 0x10	; 16
     5e8:	50 e0       	ldi	r21, 0x00	; 0
     5ea:	ce 01       	movw	r24, r28
     5ec:	05 96       	adiw	r24, 0x05	; 5
     5ee:	29 de       	rcall	.-942    	; 0x242 <iqObjectInit>
     5f0:	be 01       	movw	r22, r28
     5f2:	67 5c       	subi	r22, 0xC7	; 199
     5f4:	7f 4f       	sbci	r23, 0xFF	; 255
     5f6:	97 01       	movw	r18, r14
     5f8:	40 e1       	ldi	r20, 0x10	; 16
     5fa:	50 e0       	ldi	r21, 0x00	; 0
     5fc:	ce 01       	movw	r24, r28
     5fe:	47 96       	adiw	r24, 0x17	; 23
     600:	e9 de       	rcall	.-558    	; 0x3d4 <oqObjectInit>
     602:	df 91       	pop	r29
     604:	cf 91       	pop	r28
     606:	1f 91       	pop	r17
     608:	0f 91       	pop	r16
     60a:	ff 90       	pop	r15
     60c:	ef 90       	pop	r14
     60e:	08 95       	ret

00000610 <sdStart>:
     610:	cf 93       	push	r28
     612:	df 93       	push	r29
     614:	ec 01       	movw	r28, r24
     616:	f8 94       	cli
     618:	34 d1       	rcall	.+616    	; 0x882 <sd_lld_start>
     61a:	82 e0       	ldi	r24, 0x02	; 2
     61c:	8c 83       	std	Y+4, r24	; 0x04
     61e:	78 94       	sei
     620:	90 e0       	ldi	r25, 0x00	; 0
     622:	80 e0       	ldi	r24, 0x00	; 0
     624:	df 91       	pop	r29
     626:	cf 91       	pop	r28
     628:	08 95       	ret

0000062a <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
     62a:	1f 93       	push	r17
     62c:	cf 93       	push	r28
     62e:	df 93       	push	r29
     630:	ec 01       	movw	r28, r24
     632:	16 2f       	mov	r17, r22

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
     634:	89 85       	ldd	r24, Y+9	; 0x09
     636:	9a 85       	ldd	r25, Y+10	; 0x0a
     638:	89 2b       	or	r24, r25
     63a:	51 f0       	breq	.+20     	; 0x650 <sdIncomingDataI+0x26>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
     63c:	61 2f       	mov	r22, r17
     63e:	ce 01       	movw	r24, r28
     640:	05 96       	adiw	r24, 0x05	; 5
     642:	19 de       	rcall	.-974    	; 0x276 <iqPutI>
     644:	97 fd       	sbrc	r25, 7
     646:	0e c0       	rjmp	.+28     	; 0x664 <sdIncomingDataI+0x3a>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
     648:	df 91       	pop	r29
     64a:	cf 91       	pop	r28
     64c:	1f 91       	pop	r17
     64e:	08 95       	ret
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
     650:	64 e0       	ldi	r22, 0x04	; 4
     652:	ce 01       	movw	r24, r28
     654:	02 96       	adiw	r24, 0x02	; 2
     656:	67 d7       	rcall	.+3790   	; 0x1526 <chEvtBroadcastFlagsI>
  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
     658:	61 2f       	mov	r22, r17
     65a:	ce 01       	movw	r24, r28
     65c:	05 96       	adiw	r24, 0x05	; 5
     65e:	0b de       	rcall	.-1002   	; 0x276 <iqPutI>
     660:	97 ff       	sbrs	r25, 7
     662:	f2 cf       	rjmp	.-28     	; 0x648 <sdIncomingDataI+0x1e>
     664:	60 e0       	ldi	r22, 0x00	; 0
     666:	ce 01       	movw	r24, r28
     668:	02 96       	adiw	r24, 0x02	; 2
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
     66a:	df 91       	pop	r29
     66c:	cf 91       	pop	r28
     66e:	1f 91       	pop	r17
     670:	5a c7       	rjmp	.+3764   	; 0x1526 <chEvtBroadcastFlagsI>

00000672 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
     672:	0f 93       	push	r16
     674:	1f 93       	push	r17
     676:	cf 93       	push	r28
     678:	df 93       	push	r29
     67a:	8c 01       	movw	r16, r24
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
     67c:	47 96       	adiw	r24, 0x17	; 23
     67e:	04 df       	rcall	.-504    	; 0x488 <oqGetI>
     680:	ec 01       	movw	r28, r24
  if (b < MSG_OK)
     682:	97 fd       	sbrc	r25, 7
     684:	06 c0       	rjmp	.+12     	; 0x692 <sdRequestDataI+0x20>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
  return b;
}
     686:	ce 01       	movw	r24, r28
     688:	df 91       	pop	r29
     68a:	cf 91       	pop	r28
     68c:	1f 91       	pop	r17
     68e:	0f 91       	pop	r16
     690:	08 95       	ret
     692:	68 e0       	ldi	r22, 0x08	; 8
     694:	c8 01       	movw	r24, r16
     696:	02 96       	adiw	r24, 0x02	; 2
     698:	46 d7       	rcall	.+3724   	; 0x1526 <chEvtBroadcastFlagsI>
     69a:	ce 01       	movw	r24, r28
     69c:	df 91       	pop	r29
     69e:	cf 91       	pop	r28
     6a0:	1f 91       	pop	r17
     6a2:	0f 91       	pop	r16
     6a4:	08 95       	ret

000006a6 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  EICRA  = 0x00;
     6a6:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <__TEXT_REGION_LENGTH__+0x7f8069>
  EIMSK  = 0x00;
     6aa:	1d ba       	out	0x1d, r1	; 29

}
     6ac:	08 95       	ret

000006ae <hal_lld_init>:
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
}
     6ae:	08 95       	ret

000006b0 <_pal_lld_init>:
 *
 * @param[in] config    the AVR ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
     6b0:	fc 01       	movw	r30, r24
  PORTA = config->porta.out;
  DDRA = config->porta.dir;
#endif

#if defined(PORTB) || defined(__DOXYGEN__)
  PORTB = config->portb.out;
     6b2:	80 81       	ld	r24, Z
     6b4:	85 b9       	out	0x05, r24	; 5
  DDRB = config->portb.dir;
     6b6:	81 81       	ldd	r24, Z+1	; 0x01
     6b8:	84 b9       	out	0x04, r24	; 4
#endif

#if defined(PORTC) || defined(__DOXYGEN__)
  PORTC = config->portc.out;
     6ba:	82 81       	ldd	r24, Z+2	; 0x02
     6bc:	88 b9       	out	0x08, r24	; 8
  DDRC = config->portc.dir;
     6be:	83 81       	ldd	r24, Z+3	; 0x03
     6c0:	87 b9       	out	0x07, r24	; 7
#endif

#if defined(PORTD) || defined(__DOXYGEN__)
  PORTD = config->portd.out;
     6c2:	84 81       	ldd	r24, Z+4	; 0x04
     6c4:	8b b9       	out	0x0b, r24	; 11
  DDRD = config->portd.dir;
     6c6:	85 81       	ldd	r24, Z+5	; 0x05
     6c8:	8a b9       	out	0x0a, r24	; 10

#if defined(PORTL) || defined(__DOXYGEN__)
  PORTL = config->portl.out;
  DDRL = config->portl.dir;
#endif
}
     6ca:	08 95       	ret

000006cc <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
     6cc:	fc 01       	movw	r30, r24

  switch (mode) {
     6ce:	42 30       	cpi	r20, 0x02	; 2
     6d0:	c9 f0       	breq	.+50     	; 0x704 <_pal_lld_setgroupmode+0x38>
     6d2:	98 f0       	brcs	.+38     	; 0x6fa <_pal_lld_setgroupmode+0x2e>
     6d4:	45 30       	cpi	r20, 0x05	; 5
     6d6:	b1 f0       	breq	.+44     	; 0x704 <_pal_lld_setgroupmode+0x38>
     6d8:	46 30       	cpi	r20, 0x06	; 6
     6da:	21 f4       	brne	.+8      	; 0x6e4 <_pal_lld_setgroupmode+0x18>
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
    port->out |= mask;
    break;
  case PAL_MODE_OUTPUT_PUSHPULL:
    port->dir |= mask;
     6dc:	81 81       	ldd	r24, Z+1	; 0x01
     6de:	68 2b       	or	r22, r24
     6e0:	61 83       	std	Z+1, r22	; 0x01
    break;
  }
}
     6e2:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
     6e4:	43 30       	cpi	r20, 0x03	; 3
     6e6:	e9 f7       	brne	.-6      	; 0x6e2 <_pal_lld_setgroupmode+0x16>
    port->dir &= ~mask;
    port->out &= ~mask;
    break;
  case PAL_MODE_UNCONNECTED:
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
     6e8:	91 81       	ldd	r25, Z+1	; 0x01
     6ea:	86 2f       	mov	r24, r22
     6ec:	80 95       	com	r24
     6ee:	89 23       	and	r24, r25
     6f0:	81 83       	std	Z+1, r24	; 0x01
    port->out |= mask;
     6f2:	82 81       	ldd	r24, Z+2	; 0x02
     6f4:	68 2b       	or	r22, r24
     6f6:	62 83       	std	Z+2, r22	; 0x02
    break;
     6f8:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
     6fa:	44 23       	and	r20, r20
     6fc:	19 f0       	breq	.+6      	; 0x704 <_pal_lld_setgroupmode+0x38>
     6fe:	41 30       	cpi	r20, 0x01	; 1
     700:	99 f3       	breq	.-26     	; 0x6e8 <_pal_lld_setgroupmode+0x1c>
     702:	08 95       	ret
  case PAL_MODE_RESET:
  case PAL_MODE_INPUT:
  case PAL_MODE_INPUT_ANALOG:
    port->dir &= ~mask;
     704:	81 81       	ldd	r24, Z+1	; 0x01
     706:	60 95       	com	r22
     708:	86 23       	and	r24, r22
     70a:	81 83       	std	Z+1, r24	; 0x01
    port->out &= ~mask;
     70c:	82 81       	ldd	r24, Z+2	; 0x02
     70e:	68 23       	and	r22, r24
     710:	62 83       	std	Z+2, r22	; 0x02
    break;
     712:	08 95       	ret

00000714 <__vector_14>:
#if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined(__DOXYGEN__)

/**
 * @brief Timer handler for periodic mode.
 */
OSAL_IRQ_HANDLER(AVR_TIMER_VECT) {
     714:	1f 92       	push	r1
     716:	0f 92       	push	r0
     718:	0f b6       	in	r0, 0x3f	; 63
     71a:	0f 92       	push	r0
     71c:	11 24       	eor	r1, r1
     71e:	2f 93       	push	r18
     720:	3f 93       	push	r19
     722:	4f 93       	push	r20
     724:	5f 93       	push	r21
     726:	6f 93       	push	r22
     728:	7f 93       	push	r23
     72a:	8f 93       	push	r24
     72c:	9f 93       	push	r25
     72e:	af 93       	push	r26
     730:	bf 93       	push	r27
     732:	ef 93       	push	r30
     734:	ff 93       	push	r31

  OSAL_IRQ_PROLOGUE();
     736:	81 e0       	ldi	r24, 0x01	; 1
     738:	80 93 ed 05 	sts	0x05ED, r24	; 0x8005ed <__avr_in_isr>
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
     73c:	f3 d0       	rcall	.+486    	; 0x924 <chSysTimerHandlerI>

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
     73e:	10 92 ed 05 	sts	0x05ED, r1	; 0x8005ed <__avr_in_isr>
     742:	de d2       	rcall	.+1468   	; 0xd00 <chSchIsPreemptionRequired>
     744:	81 11       	cpse	r24, r1
     746:	ec d2       	rcall	.+1496   	; 0xd20 <chSchDoPreemption>
}
     748:	ff 91       	pop	r31
     74a:	ef 91       	pop	r30
     74c:	bf 91       	pop	r27
     74e:	af 91       	pop	r26
     750:	9f 91       	pop	r25
     752:	8f 91       	pop	r24
     754:	7f 91       	pop	r23
     756:	6f 91       	pop	r22
     758:	5f 91       	pop	r21
     75a:	4f 91       	pop	r20
     75c:	3f 91       	pop	r19
     75e:	2f 91       	pop	r18
     760:	0f 90       	pop	r0
     762:	0f be       	out	0x3f, r0	; 63
     764:	0f 90       	pop	r0
     766:	1f 90       	pop	r1
     768:	18 95       	reti

0000076a <st_lld_init>:

  /*
   * Periodic mode uses Timer 0 (8 bit).
   */
#if defined(TCCR0B) /* Timer has multiple output comparators.               */
  TCCR0A  = (1 << WGM01) | (0 << WGM00) |                /* CTC mode.       */
     76a:	82 e0       	ldi	r24, 0x02	; 2
     76c:	84 bd       	out	0x24, r24	; 36
            (0 << COM0A1) | (0 << COM0A0) |              /* OC0A disabled.  */
            (0 << COM0B1) | (0 << COM0B0);               /* OC0B disabled.  */
  TCCR0B  = (0 << WGM02) | AVR_TIMER_PRESCALER_BITS;     /* CTC mode.       */
     76e:	85 bd       	out	0x25, r24	; 37
  OCR0A   = AVR_TIMER_COUNTER - 1;
     770:	9f e7       	ldi	r25, 0x7F	; 127
     772:	97 bd       	out	0x27, r25	; 39
  TCNT0   = 0;                                           /* Reset counter.  */
     774:	16 bc       	out	0x26, r1	; 38
  TIFR0   = (1 << OCF0A);                                /* Reset pending.  */
     776:	85 bb       	out	0x15, r24	; 21
  TIMSK0  = (1 << OCIE0A);                               /* IRQ on compare. */
     778:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7f806e>
#else
  #error "Neither TCCR0A nor TCCR0 registers are defined"
#endif

#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
     77c:	08 95       	ret

0000077e <notify1>:

#if AVR_SERIAL_USE_USART0 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  UCSR0B |= (1 << UDRIE0);
     77e:	e1 ec       	ldi	r30, 0xC1	; 193
     780:	f0 e0       	ldi	r31, 0x00	; 0
     782:	80 81       	ld	r24, Z
     784:	80 62       	ori	r24, 0x20	; 32
     786:	80 83       	st	Z, r24
}
     788:	08 95       	ret

0000078a <__vector_18>:
/**
 * @brief   USART0 RX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_RX_VECT) {
     78a:	1f 92       	push	r1
     78c:	0f 92       	push	r0
     78e:	0f b6       	in	r0, 0x3f	; 63
     790:	0f 92       	push	r0
     792:	11 24       	eor	r1, r1
     794:	2f 93       	push	r18
     796:	3f 93       	push	r19
     798:	4f 93       	push	r20
     79a:	5f 93       	push	r21
     79c:	6f 93       	push	r22
     79e:	7f 93       	push	r23
     7a0:	8f 93       	push	r24
     7a2:	9f 93       	push	r25
     7a4:	af 93       	push	r26
     7a6:	bf 93       	push	r27
     7a8:	ef 93       	push	r30
     7aa:	ff 93       	push	r31
  uint8_t sra;

  OSAL_IRQ_PROLOGUE();
     7ac:	81 e0       	ldi	r24, 0x01	; 1
     7ae:	80 93 ed 05 	sts	0x05ED, r24	; 0x8005ed <__avr_in_isr>

  sra = UCSR0A;
     7b2:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
     7b6:	98 2f       	mov	r25, r24
     7b8:	9c 71       	andi	r25, 0x1C	; 28
     7ba:	41 f0       	breq	.+16     	; 0x7cc <__vector_18+0x42>
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    sts |= SD_PARITY_ERROR;
     7bc:	60 e2       	ldi	r22, 0x20	; 32
  }
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
     7be:	82 ff       	sbrs	r24, 2
     7c0:	60 e0       	ldi	r22, 0x00	; 0
    sts |= SD_PARITY_ERROR;
  if (sra & fe)
     7c2:	84 fd       	sbrc	r24, 4
     7c4:	1e c0       	rjmp	.+60     	; 0x802 <__DATA_REGION_LENGTH__+0x2>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
     7c6:	8c e5       	ldi	r24, 0x5C	; 92
     7c8:	95 e0       	ldi	r25, 0x05	; 5
     7ca:	ad d6       	rcall	.+3418   	; 0x1526 <chEvtBroadcastFlagsI>

  sra = UCSR0A;
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
    set_error(sra, &SD1);
  osalSysLockFromISR();
  sdIncomingDataI(&SD1, UDR0);
     7cc:	60 91 c6 00 	lds	r22, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
     7d0:	8a e5       	ldi	r24, 0x5A	; 90
     7d2:	95 e0       	ldi	r25, 0x05	; 5
     7d4:	2a df       	rcall	.-428    	; 0x62a <sdIncomingDataI>
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
     7d6:	10 92 ed 05 	sts	0x05ED, r1	; 0x8005ed <__avr_in_isr>
     7da:	92 d2       	rcall	.+1316   	; 0xd00 <chSchIsPreemptionRequired>
     7dc:	81 11       	cpse	r24, r1
     7de:	a0 d2       	rcall	.+1344   	; 0xd20 <chSchDoPreemption>
}
     7e0:	ff 91       	pop	r31
     7e2:	ef 91       	pop	r30
     7e4:	bf 91       	pop	r27
     7e6:	af 91       	pop	r26
     7e8:	9f 91       	pop	r25
     7ea:	8f 91       	pop	r24
     7ec:	7f 91       	pop	r23
     7ee:	6f 91       	pop	r22
     7f0:	5f 91       	pop	r21
     7f2:	4f 91       	pop	r20
     7f4:	3f 91       	pop	r19
     7f6:	2f 91       	pop	r18
     7f8:	0f 90       	pop	r0
     7fa:	0f be       	out	0x3f, r0	; 63
     7fc:	0f 90       	pop	r0
     7fe:	1f 90       	pop	r1
     800:	18 95       	reti
  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    sts |= SD_PARITY_ERROR;
  if (sra & fe)
    sts |= SD_FRAMING_ERROR;
     802:	60 64       	ori	r22, 0x40	; 64
     804:	e0 cf       	rjmp	.-64     	; 0x7c6 <__vector_18+0x3c>

00000806 <__vector_19>:
/**
 * @brief   USART0 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_TX_VECT) {
     806:	1f 92       	push	r1
     808:	0f 92       	push	r0
     80a:	0f b6       	in	r0, 0x3f	; 63
     80c:	0f 92       	push	r0
     80e:	11 24       	eor	r1, r1
     810:	2f 93       	push	r18
     812:	3f 93       	push	r19
     814:	4f 93       	push	r20
     816:	5f 93       	push	r21
     818:	6f 93       	push	r22
     81a:	7f 93       	push	r23
     81c:	8f 93       	push	r24
     81e:	9f 93       	push	r25
     820:	af 93       	push	r26
     822:	bf 93       	push	r27
     824:	ef 93       	push	r30
     826:	ff 93       	push	r31
  msg_t b;

  OSAL_IRQ_PROLOGUE();
     828:	81 e0       	ldi	r24, 0x01	; 1
     82a:	80 93 ed 05 	sts	0x05ED, r24	; 0x8005ed <__avr_in_isr>

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
     82e:	8a e5       	ldi	r24, 0x5A	; 90
     830:	95 e0       	ldi	r25, 0x05	; 5
     832:	1f df       	rcall	.-450    	; 0x672 <sdRequestDataI>
  osalSysUnlockFromISR();
  if (b < MSG_OK)
     834:	97 fd       	sbrc	r25, 7
     836:	18 c0       	rjmp	.+48     	; 0x868 <__vector_19+0x62>
    UCSR0B &= ~(1 << UDRIE0);
  else
    UDR0 = b;
     838:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>

  OSAL_IRQ_EPILOGUE();
     83c:	10 92 ed 05 	sts	0x05ED, r1	; 0x8005ed <__avr_in_isr>
     840:	5f d2       	rcall	.+1214   	; 0xd00 <chSchIsPreemptionRequired>
     842:	81 11       	cpse	r24, r1
     844:	6d d2       	rcall	.+1242   	; 0xd20 <chSchDoPreemption>
}
     846:	ff 91       	pop	r31
     848:	ef 91       	pop	r30
     84a:	bf 91       	pop	r27
     84c:	af 91       	pop	r26
     84e:	9f 91       	pop	r25
     850:	8f 91       	pop	r24
     852:	7f 91       	pop	r23
     854:	6f 91       	pop	r22
     856:	5f 91       	pop	r21
     858:	4f 91       	pop	r20
     85a:	3f 91       	pop	r19
     85c:	2f 91       	pop	r18
     85e:	0f 90       	pop	r0
     860:	0f be       	out	0x3f, r0	; 63
     862:	0f 90       	pop	r0
     864:	1f 90       	pop	r1
     866:	18 95       	reti

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
  osalSysUnlockFromISR();
  if (b < MSG_OK)
    UCSR0B &= ~(1 << UDRIE0);
     868:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     86c:	8f 7d       	andi	r24, 0xDF	; 223
     86e:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     872:	e4 cf       	rjmp	.-56     	; 0x83c <__vector_19+0x36>

00000874 <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if AVR_SERIAL_USE_USART0
  sdObjectInit(&SD1, NULL, notify1);
     874:	4f eb       	ldi	r20, 0xBF	; 191
     876:	53 e0       	ldi	r21, 0x03	; 3
     878:	70 e0       	ldi	r23, 0x00	; 0
     87a:	60 e0       	ldi	r22, 0x00	; 0
     87c:	8a e5       	ldi	r24, 0x5A	; 90
     87e:	95 e0       	ldi	r25, 0x05	; 5
     880:	9c ce       	rjmp	.-712    	; 0x5ba <sdObjectInit>

00000882 <sd_lld_start>:
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
     882:	61 15       	cp	r22, r1
     884:	71 05       	cpc	r23, r1
     886:	21 f0       	breq	.+8      	; 0x890 <sd_lld_start+0xe>
    config = &default_config;

#if AVR_SERIAL_USE_USART0
  if (&SD1 == sdp) {
     888:	8a 55       	subi	r24, 0x5A	; 90
     88a:	95 40       	sbci	r25, 0x05	; 5
     88c:	89 f0       	breq	.+34     	; 0x8b0 <sd_lld_start+0x2e>
  if (&SD2 == sdp) {
    usart1_init(config);
    return;
  }
#endif
}
     88e:	08 95       	ret

  if (config == NULL)
    config = &default_config;

#if AVR_SERIAL_USE_USART0
  if (&SD1 == sdp) {
     890:	8a 55       	subi	r24, 0x5A	; 90
     892:	95 40       	sbci	r25, 0x05	; 5
     894:	e1 f7       	brne	.-8      	; 0x88e <sd_lld_start+0xc>
 */
static void usart0_init(const SerialConfig *config) {

  uint8_t ucsr0c;

  UBRR0L = config->sc_brr;
     896:	83 e3       	ldi	r24, 0x33	; 51
     898:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
  UBRR0H = (config->sc_brr >> 8) & 0x0f;
     89c:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
  UCSR0A = (1 << U2X0);
     8a0:	82 e0       	ldi	r24, 0x02	; 2
     8a2:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
     8a6:	88 e9       	ldi	r24, 0x98	; 152
     8a8:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
    UCSR0B |= (1 << UCSZ02);
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_8:
  default:
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
     8ac:	86 e0       	ldi	r24, 0x06	; 6
     8ae:	1c c0       	rjmp	.+56     	; 0x8e8 <sd_lld_start+0x66>
 */
static void usart0_init(const SerialConfig *config) {

  uint8_t ucsr0c;

  UBRR0L = config->sc_brr;
     8b0:	fb 01       	movw	r30, r22
     8b2:	80 81       	ld	r24, Z
     8b4:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
  UBRR0H = (config->sc_brr >> 8) & 0x0f;
     8b8:	81 81       	ldd	r24, Z+1	; 0x01
     8ba:	8f 70       	andi	r24, 0x0F	; 15
     8bc:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
  UCSR0A = (1 << U2X0);
     8c0:	82 e0       	ldi	r24, 0x02	; 2
     8c2:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
     8c6:	88 e9       	ldi	r24, 0x98	; 152
     8c8:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
  switch (config->sc_bits_per_char) {
     8cc:	82 81       	ldd	r24, Z+2	; 0x02
     8ce:	81 30       	cpi	r24, 0x01	; 1
     8d0:	91 f0       	breq	.+36     	; 0x8f6 <sd_lld_start+0x74>
     8d2:	78 f0       	brcs	.+30     	; 0x8f2 <sd_lld_start+0x70>
     8d4:	82 30       	cpi	r24, 0x02	; 2
     8d6:	59 f0       	breq	.+22     	; 0x8ee <sd_lld_start+0x6c>
     8d8:	84 30       	cpi	r24, 0x04	; 4
     8da:	41 f7       	brne	.-48     	; 0x8ac <sd_lld_start+0x2a>
    break;
  case USART_CHAR_SIZE_7:
    ucsr0c = (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_9:
    UCSR0B |= (1 << UCSZ02);
     8dc:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     8e0:	84 60       	ori	r24, 0x04	; 4
     8e2:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
     8e6:	86 e0       	ldi	r24, 0x06	; 6
  }

#if defined(__AVR_ATmega162__)
  UCSR0C = (1 << URSEL0) | ucsr0c;
#else
  UCSR0C = ucsr0c;
     8e8:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
     8ec:	08 95       	ret
    break;
  case USART_CHAR_SIZE_6:
    ucsr0c = (1 << UCSZ00);
    break;
  case USART_CHAR_SIZE_7:
    ucsr0c = (1 << UCSZ01);
     8ee:	84 e0       	ldi	r24, 0x04	; 4
     8f0:	fb cf       	rjmp	.-10     	; 0x8e8 <sd_lld_start+0x66>
  UBRR0H = (config->sc_brr >> 8) & 0x0f;
  UCSR0A = (1 << U2X0);
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
  switch (config->sc_bits_per_char) {
  case USART_CHAR_SIZE_5:
    ucsr0c = 0;
     8f2:	80 e0       	ldi	r24, 0x00	; 0
     8f4:	f9 cf       	rjmp	.-14     	; 0x8e8 <sd_lld_start+0x66>
    break;
  case USART_CHAR_SIZE_6:
    ucsr0c = (1 << UCSZ00);
     8f6:	82 e0       	ldi	r24, 0x02	; 2
     8f8:	f7 cf       	rjmp	.-18     	; 0x8e8 <sd_lld_start+0x66>

000008fa <chSysInit>:
  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    ch_delta_list_t *dlp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
     8fa:	cf 93       	push	r28
     8fc:	df 93       	push	r29
     8fe:	c3 ea       	ldi	r28, 0xA3	; 163
     900:	d5 e0       	ldi	r29, 0x05	; 5
     902:	81 e0       	ldi	r24, 0x01	; 1
     904:	88 83       	st	Y, r24
     906:	1a 82       	std	Y+2, r1	; 0x02
     908:	19 82       	std	Y+1, r1	; 0x01
     90a:	32 d6       	rcall	.+3172   	; 0x1570 <__core_init>
     90c:	61 d6       	rcall	.+3266   	; 0x15d0 <__heap_init>
     90e:	6d e1       	ldi	r22, 0x1D	; 29
     910:	71 e0       	ldi	r23, 0x01	; 1
     912:	86 ea       	ldi	r24, 0xA6	; 166
     914:	95 e0       	ldi	r25, 0x05	; 5
     916:	53 d2       	rcall	.+1190   	; 0xdbe <chInstanceObjectInit>
     918:	82 e0       	ldi	r24, 0x02	; 2
     91a:	88 83       	st	Y, r24
     91c:	78 94       	sei
     91e:	df 91       	pop	r29
     920:	cf 91       	pop	r28
     922:	08 95       	ret

00000924 <chSysTimerHandlerI>:
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
     924:	68 c0       	rjmp	.+208    	; 0x9f6 <chVTDoTickI>

00000926 <chVTDoSetI>:
  } while (dlp != &vtlp->dlist);

  chDbgAssert(false, "timer not in list");

  return (sysinterval_t)-1;
}
     926:	cf 93       	push	r28
     928:	df 93       	push	r29
     92a:	dc 01       	movw	r26, r24
     92c:	19 96       	adiw	r26, 0x09	; 9
     92e:	3c 93       	st	X, r19
     930:	2e 93       	st	-X, r18
     932:	18 97       	sbiw	r26, 0x08	; 8
     934:	17 96       	adiw	r26, 0x07	; 7
     936:	5c 93       	st	X, r21
     938:	4e 93       	st	-X, r20
     93a:	16 97       	sbiw	r26, 0x06	; 6
     93c:	1b 96       	adiw	r26, 0x0b	; 11
     93e:	1c 92       	st	X, r1
     940:	1e 92       	st	-X, r1
     942:	1a 97       	sbiw	r26, 0x0a	; 10
     944:	e0 91 ad 05 	lds	r30, 0x05AD	; 0x8005ad <ch0+0x7>
     948:	f0 91 ae 05 	lds	r31, 0x05AE	; 0x8005ae <ch0+0x8>
     94c:	24 81       	ldd	r18, Z+4	; 0x04
     94e:	35 81       	ldd	r19, Z+5	; 0x05
     950:	26 17       	cp	r18, r22
     952:	37 07       	cpc	r19, r23
     954:	50 f4       	brcc	.+20     	; 0x96a <chVTDoSetI+0x44>
     956:	62 1b       	sub	r22, r18
     958:	73 0b       	sbc	r23, r19
     95a:	01 90       	ld	r0, Z+
     95c:	f0 81       	ld	r31, Z
     95e:	e0 2d       	mov	r30, r0
     960:	24 81       	ldd	r18, Z+4	; 0x04
     962:	35 81       	ldd	r19, Z+5	; 0x05
     964:	26 17       	cp	r18, r22
     966:	37 07       	cpc	r19, r23
     968:	b0 f3       	brcs	.-20     	; 0x956 <chVTDoSetI+0x30>
     96a:	15 96       	adiw	r26, 0x05	; 5
     96c:	7c 93       	st	X, r23
     96e:	6e 93       	st	-X, r22
     970:	14 97       	sbiw	r26, 0x04	; 4
     972:	11 96       	adiw	r26, 0x01	; 1
     974:	fc 93       	st	X, r31
     976:	ee 93       	st	-X, r30
     978:	c2 81       	ldd	r28, Z+2	; 0x02
     97a:	d3 81       	ldd	r29, Z+3	; 0x03
     97c:	13 96       	adiw	r26, 0x03	; 3
     97e:	dc 93       	st	X, r29
     980:	ce 93       	st	-X, r28
     982:	12 97       	sbiw	r26, 0x02	; 2
     984:	b9 83       	std	Y+1, r27	; 0x01
     986:	a8 83       	st	Y, r26
     988:	b3 83       	std	Z+3, r27	; 0x03
     98a:	a2 83       	std	Z+2, r26	; 0x02
     98c:	84 81       	ldd	r24, Z+4	; 0x04
     98e:	95 81       	ldd	r25, Z+5	; 0x05
     990:	86 1b       	sub	r24, r22
     992:	97 0b       	sbc	r25, r23
     994:	95 83       	std	Z+5, r25	; 0x05
     996:	84 83       	std	Z+4, r24	; 0x04
     998:	8f ef       	ldi	r24, 0xFF	; 255
     99a:	9f ef       	ldi	r25, 0xFF	; 255
     99c:	90 93 b2 05 	sts	0x05B2, r25	; 0x8005b2 <ch0+0xc>
     9a0:	80 93 b1 05 	sts	0x05B1, r24	; 0x8005b1 <ch0+0xb>
     9a4:	df 91       	pop	r29
     9a6:	cf 91       	pop	r28
     9a8:	08 95       	ret

000009aa <chVTDoResetI>:
     9aa:	cf 93       	push	r28
     9ac:	df 93       	push	r29
     9ae:	fc 01       	movw	r30, r24
     9b0:	a0 81       	ld	r26, Z
     9b2:	b1 81       	ldd	r27, Z+1	; 0x01
     9b4:	14 96       	adiw	r26, 0x04	; 4
     9b6:	8d 91       	ld	r24, X+
     9b8:	9c 91       	ld	r25, X
     9ba:	15 97       	sbiw	r26, 0x05	; 5
     9bc:	24 81       	ldd	r18, Z+4	; 0x04
     9be:	35 81       	ldd	r19, Z+5	; 0x05
     9c0:	82 0f       	add	r24, r18
     9c2:	93 1f       	adc	r25, r19
     9c4:	15 96       	adiw	r26, 0x05	; 5
     9c6:	9c 93       	st	X, r25
     9c8:	8e 93       	st	-X, r24
     9ca:	14 97       	sbiw	r26, 0x04	; 4
     9cc:	c2 81       	ldd	r28, Z+2	; 0x02
     9ce:	d3 81       	ldd	r29, Z+3	; 0x03
     9d0:	b9 83       	std	Y+1, r27	; 0x01
     9d2:	a8 83       	st	Y, r26
     9d4:	a0 81       	ld	r26, Z
     9d6:	b1 81       	ldd	r27, Z+1	; 0x01
     9d8:	13 96       	adiw	r26, 0x03	; 3
     9da:	dc 93       	st	X, r29
     9dc:	ce 93       	st	-X, r28
     9de:	12 97       	sbiw	r26, 0x02	; 2
     9e0:	11 82       	std	Z+1, r1	; 0x01
     9e2:	10 82       	st	Z, r1
     9e4:	8f ef       	ldi	r24, 0xFF	; 255
     9e6:	9f ef       	ldi	r25, 0xFF	; 255
     9e8:	90 93 b2 05 	sts	0x05B2, r25	; 0x8005b2 <ch0+0xc>
     9ec:	80 93 b1 05 	sts	0x05B1, r24	; 0x8005b1 <ch0+0xb>
     9f0:	df 91       	pop	r29
     9f2:	cf 91       	pop	r28
     9f4:	08 95       	ret

000009f6 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
     9f6:	0f 93       	push	r16
     9f8:	1f 93       	push	r17
     9fa:	cf 93       	push	r28
     9fc:	df 93       	push	r29
  virtual_timers_list_t *vtlp = &currcore->vtlist;

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime++;
     9fe:	80 91 b3 05 	lds	r24, 0x05B3	; 0x8005b3 <ch0+0xd>
     a02:	90 91 b4 05 	lds	r25, 0x05B4	; 0x8005b4 <ch0+0xe>
     a06:	01 96       	adiw	r24, 0x01	; 1
     a08:	90 93 b4 05 	sts	0x05B4, r25	; 0x8005b4 <ch0+0xe>
     a0c:	80 93 b3 05 	sts	0x05B3, r24	; 0x8005b3 <ch0+0xd>
 *
 * @notapi
 */
static inline bool ch_dlist_notempty(ch_delta_list_t *dlhp) {

  return (bool)(dlhp != dlhp->next);
     a10:	c0 91 ad 05 	lds	r28, 0x05AD	; 0x8005ad <ch0+0x7>
     a14:	d0 91 ae 05 	lds	r29, 0x05AE	; 0x8005ae <ch0+0x8>
  if (ch_dlist_notempty(&vtlp->dlist)) {
     a18:	85 e0       	ldi	r24, 0x05	; 5
     a1a:	cd 3a       	cpi	r28, 0xAD	; 173
     a1c:	d8 07       	cpc	r29, r24
     a1e:	41 f1       	breq	.+80     	; 0xa70 <chVTDoTickI+0x7a>
    /* The list is not empty, processing elements on top.*/
    --vtlp->dlist.next->delta;
     a20:	8c 81       	ldd	r24, Y+4	; 0x04
     a22:	9d 81       	ldd	r25, Y+5	; 0x05
     a24:	01 97       	sbiw	r24, 0x01	; 1
     a26:	9d 83       	std	Y+5, r25	; 0x05
     a28:	8c 83       	std	Y+4, r24	; 0x04
  dlp->delta -= delta;

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
     a2a:	0f ef       	ldi	r16, 0xFF	; 255
     a2c:	1f ef       	ldi	r17, 0xFF	; 255
    while (vtlp->dlist.next->delta == (sysinterval_t)0) {
     a2e:	1e c0       	rjmp	.+60     	; 0xa6c <chVTDoTickI+0x76>
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {

  dlp->prev->next = dlp->next;
     a30:	ea 81       	ldd	r30, Y+2	; 0x02
     a32:	fb 81       	ldd	r31, Y+3	; 0x03
     a34:	88 81       	ld	r24, Y
     a36:	99 81       	ldd	r25, Y+1	; 0x01
     a38:	91 83       	std	Z+1, r25	; 0x01
     a3a:	80 83       	st	Z, r24
  dlp->next->prev = dlp->prev;
     a3c:	a8 81       	ld	r26, Y
     a3e:	b9 81       	ldd	r27, Y+1	; 0x01
     a40:	13 96       	adiw	r26, 0x03	; 3
     a42:	fc 93       	st	X, r31
     a44:	ee 93       	st	-X, r30
     a46:	12 97       	sbiw	r26, 0x02	; 2
      /* Triggered timer.*/
      vtp = (virtual_timer_t *)vtlp->dlist.next;

      /* Removing the element from the delta list, marking it as not armed.*/
      (void) ch_dlist_dequeue(&vtp->dlist);
      vtp->dlist.next = NULL;
     a48:	19 82       	std	Y+1, r1	; 0x01
     a4a:	18 82       	st	Y, r1

      chSysUnlockFromISR();
      vtp->func(vtp, vtp->par);
     a4c:	68 85       	ldd	r22, Y+8	; 0x08
     a4e:	79 85       	ldd	r23, Y+9	; 0x09
     a50:	ee 81       	ldd	r30, Y+6	; 0x06
     a52:	ff 81       	ldd	r31, Y+7	; 0x07
     a54:	ce 01       	movw	r24, r28
     a56:	09 95       	icall
      chSysLockFromISR();

      /* If a reload is defined the timer needs to be restarted.*/
      if (vtp->reload > (sysinterval_t)0) {
     a58:	8a 85       	ldd	r24, Y+10	; 0x0a
     a5a:	9b 85       	ldd	r25, Y+11	; 0x0b
     a5c:	00 97       	sbiw	r24, 0x00	; 0
     a5e:	69 f4       	brne	.+26     	; 0xa7a <chVTDoTickI+0x84>
     a60:	c0 91 ad 05 	lds	r28, 0x05AD	; 0x8005ad <ch0+0x7>
     a64:	d0 91 ae 05 	lds	r29, 0x05AE	; 0x8005ae <ch0+0x8>
     a68:	8c 81       	ldd	r24, Y+4	; 0x04
     a6a:	9d 81       	ldd	r25, Y+5	; 0x05
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime++;
  if (ch_dlist_notempty(&vtlp->dlist)) {
    /* The list is not empty, processing elements on top.*/
    --vtlp->dlist.next->delta;
    while (vtlp->dlist.next->delta == (sysinterval_t)0) {
     a6c:	89 2b       	or	r24, r25
     a6e:	01 f3       	breq	.-64     	; 0xa30 <chVTDoTickI+0x3a>
  vtp->dlist.delta -= nowdelta;

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     a70:	df 91       	pop	r29
     a72:	cf 91       	pop	r28
     a74:	1f 91       	pop	r17
     a76:	0f 91       	pop	r16
     a78:	08 95       	ret
     a7a:	e0 91 ad 05 	lds	r30, 0x05AD	; 0x8005ad <ch0+0x7>
     a7e:	f0 91 ae 05 	lds	r31, 0x05AE	; 0x8005ae <ch0+0x8>
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
     a82:	24 81       	ldd	r18, Z+4	; 0x04
     a84:	35 81       	ldd	r19, Z+5	; 0x05
     a86:	28 17       	cp	r18, r24
     a88:	39 07       	cpc	r19, r25
     a8a:	50 f4       	brcc	.+20     	; 0xaa0 <chVTDoTickI+0xaa>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
     a8c:	82 1b       	sub	r24, r18
     a8e:	93 0b       	sbc	r25, r19
    dlp = dlp->next;
     a90:	01 90       	ld	r0, Z+
     a92:	f0 81       	ld	r31, Z
     a94:	e0 2d       	mov	r30, r0
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
     a96:	24 81       	ldd	r18, Z+4	; 0x04
     a98:	35 81       	ldd	r19, Z+5	; 0x05
     a9a:	28 17       	cp	r18, r24
     a9c:	39 07       	cpc	r19, r25
     a9e:	b0 f3       	brcs	.-20     	; 0xa8c <chVTDoTickI+0x96>
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {

  dlp->delta      = delta;
     aa0:	9d 83       	std	Y+5, r25	; 0x05
     aa2:	8c 83       	std	Y+4, r24	; 0x04
  dlp->next       = dlhp;
     aa4:	f9 83       	std	Y+1, r31	; 0x01
     aa6:	e8 83       	st	Y, r30
  dlp->prev       = dlp->next->prev;
     aa8:	a2 81       	ldd	r26, Z+2	; 0x02
     aaa:	b3 81       	ldd	r27, Z+3	; 0x03
     aac:	bb 83       	std	Y+3, r27	; 0x03
     aae:	aa 83       	std	Y+2, r26	; 0x02
  dlp->prev->next = dlp;
     ab0:	cd 93       	st	X+, r28
     ab2:	dc 93       	st	X, r29
  dlhp->prev      = dlp;
     ab4:	d3 83       	std	Z+3, r29	; 0x03
     ab6:	c2 83       	std	Z+2, r28	; 0x02

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
     ab8:	24 81       	ldd	r18, Z+4	; 0x04
     aba:	35 81       	ldd	r19, Z+5	; 0x05
     abc:	28 1b       	sub	r18, r24
     abe:	39 0b       	sbc	r19, r25
     ac0:	35 83       	std	Z+5, r19	; 0x05
     ac2:	24 83       	std	Z+4, r18	; 0x04

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
     ac4:	10 93 b2 05 	sts	0x05B2, r17	; 0x8005b2 <ch0+0xc>
     ac8:	00 93 b1 05 	sts	0x05B1, r16	; 0x8005b1 <ch0+0xb>
     acc:	c9 cf       	rjmp	.-110    	; 0xa60 <chVTDoTickI+0x6a>

00000ace <__sch_wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
     ace:	cf 93       	push	r28
     ad0:	df 93       	push	r29
     ad2:	db 01       	movw	r26, r22
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
     ad4:	1f 96       	adiw	r26, 0x0f	; 15
     ad6:	8c 91       	ld	r24, X
     ad8:	1f 97       	sbiw	r26, 0x0f	; 15
     ada:	84 30       	cpi	r24, 0x04	; 4
     adc:	f1 f1       	breq	.+124    	; 0xb5a <__sch_wakeup+0x8c>
     ade:	80 f5       	brcc	.+96     	; 0xb40 <__sch_wakeup+0x72>
     ae0:	88 23       	and	r24, r24
     ae2:	59 f1       	breq	.+86     	; 0xb3a <__sch_wakeup+0x6c>
     ae4:	83 30       	cpi	r24, 0x03	; 3
     ae6:	31 f4       	brne	.+12     	; 0xaf4 <__sch_wakeup+0x26>
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
     ae8:	52 96       	adiw	r26, 0x12	; 18
     aea:	ed 91       	ld	r30, X+
     aec:	fc 91       	ld	r31, X
     aee:	53 97       	sbiw	r26, 0x13	; 19
     af0:	11 82       	std	Z+1, r1	; 0x01
     af2:	10 82       	st	Z, r1
    /* Any other state, nothing to do.*/
    break;
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
     af4:	8f ef       	ldi	r24, 0xFF	; 255
     af6:	9f ef       	ldi	r25, 0xFF	; 255
     af8:	53 96       	adiw	r26, 0x13	; 19
     afa:	9c 93       	st	X, r25
     afc:	8e 93       	st	-X, r24
     afe:	52 97       	sbiw	r26, 0x12	; 18

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     b00:	1f 96       	adiw	r26, 0x0f	; 15
     b02:	1c 92       	st	X, r1
     b04:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     b06:	1b 96       	adiw	r26, 0x0b	; 11
     b08:	ed 91       	ld	r30, X+
     b0a:	fc 91       	ld	r31, X
     b0c:	1c 97       	sbiw	r26, 0x0c	; 12
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio >= p->prio));
     b0e:	14 96       	adiw	r26, 0x04	; 4
     b10:	9c 91       	ld	r25, X
     b12:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     b14:	01 90       	ld	r0, Z+
     b16:	f0 81       	ld	r31, Z
     b18:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     b1a:	84 81       	ldd	r24, Z+4	; 0x04
     b1c:	89 17       	cp	r24, r25
     b1e:	d0 f7       	brcc	.-12     	; 0xb14 <__sch_wakeup+0x46>

  /* Insertion on prev.*/
  p->next       = pqp;
     b20:	11 96       	adiw	r26, 0x01	; 1
     b22:	fc 93       	st	X, r31
     b24:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     b26:	c2 81       	ldd	r28, Z+2	; 0x02
     b28:	d3 81       	ldd	r29, Z+3	; 0x03
     b2a:	13 96       	adiw	r26, 0x03	; 3
     b2c:	dc 93       	st	X, r29
     b2e:	ce 93       	st	-X, r28
     b30:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     b32:	b9 83       	std	Y+1, r27	; 0x01
     b34:	a8 83       	st	Y, r26
  pqp->prev     = p;
     b36:	b3 83       	std	Z+3, r27	; 0x03
     b38:	a2 83       	std	Z+2, r26	; 0x02
  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
  chSysUnlockFromISR();

  return;
}
     b3a:	df 91       	pop	r29
     b3c:	cf 91       	pop	r28
     b3e:	08 95       	ret
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
     b40:	87 30       	cpi	r24, 0x07	; 7
     b42:	59 f0       	breq	.+22     	; 0xb5a <__sch_wakeup+0x8c>
     b44:	8c 30       	cpi	r24, 0x0C	; 12
     b46:	49 f0       	breq	.+18     	; 0xb5a <__sch_wakeup+0x8c>
     b48:	85 30       	cpi	r24, 0x05	; 5
     b4a:	a1 f6       	brne	.-88     	; 0xaf4 <__sch_wakeup+0x26>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
     b4c:	52 96       	adiw	r26, 0x12	; 18
     b4e:	ed 91       	ld	r30, X+
     b50:	fc 91       	ld	r31, X
     b52:	53 97       	sbiw	r26, 0x13	; 19
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
     b54:	84 81       	ldd	r24, Z+4	; 0x04
     b56:	8f 5f       	subi	r24, 0xFF	; 255
     b58:	84 83       	std	Z+4, r24	; 0x04
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {

  p->prev->next = p->next;
     b5a:	12 96       	adiw	r26, 0x02	; 2
     b5c:	ed 91       	ld	r30, X+
     b5e:	fc 91       	ld	r31, X
     b60:	13 97       	sbiw	r26, 0x03	; 3
     b62:	8d 91       	ld	r24, X+
     b64:	9c 91       	ld	r25, X
     b66:	11 97       	sbiw	r26, 0x01	; 1
     b68:	91 83       	std	Z+1, r25	; 0x01
     b6a:	80 83       	st	Z, r24
  p->next->prev = p->prev;
     b6c:	cd 91       	ld	r28, X+
     b6e:	dc 91       	ld	r29, X
     b70:	11 97       	sbiw	r26, 0x01	; 1
     b72:	fb 83       	std	Y+3, r31	; 0x03
     b74:	ea 83       	std	Y+2, r30	; 0x02
     b76:	be cf       	rjmp	.-132    	; 0xaf4 <__sch_wakeup+0x26>

00000b78 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
     b78:	cf 93       	push	r28
     b7a:	df 93       	push	r29
     b7c:	dc 01       	movw	r26, r24

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     b7e:	1f 96       	adiw	r26, 0x0f	; 15
     b80:	1c 92       	st	X, r1
     b82:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     b84:	1b 96       	adiw	r26, 0x0b	; 11
     b86:	ed 91       	ld	r30, X+
     b88:	fc 91       	ld	r31, X
     b8a:	1c 97       	sbiw	r26, 0x0c	; 12
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio >= p->prio));
     b8c:	14 96       	adiw	r26, 0x04	; 4
     b8e:	8c 91       	ld	r24, X
     b90:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     b92:	01 90       	ld	r0, Z+
     b94:	f0 81       	ld	r31, Z
     b96:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     b98:	94 81       	ldd	r25, Z+4	; 0x04
     b9a:	98 17       	cp	r25, r24
     b9c:	d0 f7       	brcc	.-12     	; 0xb92 <chSchReadyI+0x1a>

  /* Insertion on prev.*/
  p->next       = pqp;
     b9e:	11 96       	adiw	r26, 0x01	; 1
     ba0:	fc 93       	st	X, r31
     ba2:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     ba4:	c2 81       	ldd	r28, Z+2	; 0x02
     ba6:	d3 81       	ldd	r29, Z+3	; 0x03
     ba8:	13 96       	adiw	r26, 0x03	; 3
     baa:	dc 93       	st	X, r29
     bac:	ce 93       	st	-X, r28
     bae:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     bb0:	b9 83       	std	Y+1, r27	; 0x01
     bb2:	a8 83       	st	Y, r26
  pqp->prev     = p;
     bb4:	b3 83       	std	Z+3, r27	; 0x03
     bb6:	a2 83       	std	Z+2, r26	; 0x02
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
}
     bb8:	cd 01       	movw	r24, r26
     bba:	df 91       	pop	r29
     bbc:	cf 91       	pop	r28
     bbe:	08 95       	ret

00000bc0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
     bc0:	cf 93       	push	r28
     bc2:	df 93       	push	r29
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     bc4:	e6 ea       	ldi	r30, 0xA6	; 166
     bc6:	f5 e0       	ldi	r31, 0x05	; 5
     bc8:	65 81       	ldd	r22, Z+5	; 0x05
     bca:	76 81       	ldd	r23, Z+6	; 0x06

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
  chDbgAssert(otp->owner == oip, "invalid core");

  /* New state.*/
  otp->state = newstate;
     bcc:	db 01       	movw	r26, r22
     bce:	1f 96       	adiw	r26, 0x0f	; 15
     bd0:	8c 93       	st	X, r24
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
     bd2:	80 81       	ld	r24, Z
     bd4:	91 81       	ldd	r25, Z+1	; 0x01

  pqp->next       = p->next;
     bd6:	ec 01       	movw	r28, r24
     bd8:	a8 81       	ld	r26, Y
     bda:	b9 81       	ldd	r27, Y+1	; 0x01
     bdc:	b1 83       	std	Z+1, r27	; 0x01
     bde:	a0 83       	st	Z, r26
  pqp->next->prev = pqp;
     be0:	13 96       	adiw	r26, 0x03	; 3
     be2:	fc 93       	st	X, r31
     be4:	ee 93       	st	-X, r30
     be6:	12 97       	sbiw	r26, 0x02	; 2
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
     be8:	21 e0       	ldi	r18, 0x01	; 1
     bea:	2f 87       	std	Y+15, r18	; 0x0f
  __instance_set_currthread(oip, ntp);
     bec:	96 83       	std	Z+6, r25	; 0x06
     bee:	85 83       	std	Z+5, r24	; 0x05
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
     bf0:	fc d4       	rcall	.+2552   	; 0x15ea <_port_switch>
}
     bf2:	df 91       	pop	r29
     bf4:	cf 91       	pop	r28
     bf6:	08 95       	ret

00000bf8 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
     bf8:	ff 92       	push	r15
     bfa:	0f 93       	push	r16
     bfc:	1f 93       	push	r17
     bfe:	cf 93       	push	r28
     c00:	df 93       	push	r29
     c02:	cd b7       	in	r28, 0x3d	; 61
     c04:	de b7       	in	r29, 0x3e	; 62
     c06:	2c 97       	sbiw	r28, 0x0c	; 12
     c08:	0f b6       	in	r0, 0x3f	; 63
     c0a:	f8 94       	cli
     c0c:	de bf       	out	0x3e, r29	; 62
     c0e:	0f be       	out	0x3f, r0	; 63
     c10:	cd bf       	out	0x3d, r28	; 61
     c12:	f8 2e       	mov	r15, r24
  thread_t *tp = __instance_get_currthread(currcore);
     c14:	00 91 ab 05 	lds	r16, 0x05AB	; 0x8005ab <ch0+0x5>
     c18:	10 91 ac 05 	lds	r17, 0x05AC	; 0x8005ac <ch0+0x6>

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
     c1c:	6f 3f       	cpi	r22, 0xFF	; 255
     c1e:	76 07       	cpc	r23, r22
     c20:	f1 f0       	breq	.+60     	; 0xc5e <chSchGoSleepTimeoutS+0x66>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
     c22:	98 01       	movw	r18, r16
     c24:	47 e6       	ldi	r20, 0x67	; 103
     c26:	55 e0       	ldi	r21, 0x05	; 5
     c28:	ce 01       	movw	r24, r28
     c2a:	01 96       	adiw	r24, 0x01	; 1
     c2c:	7c de       	rcall	.-776    	; 0x926 <chVTDoSetI>
    chSchGoSleepS(newstate);
     c2e:	8f 2d       	mov	r24, r15
     c30:	c7 df       	rcall	.-114    	; 0xbc0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
     c32:	89 81       	ldd	r24, Y+1	; 0x01
     c34:	9a 81       	ldd	r25, Y+2	; 0x02
     c36:	89 2b       	or	r24, r25
     c38:	19 f0       	breq	.+6      	; 0xc40 <chSchGoSleepTimeoutS+0x48>
      chVTDoResetI(&vt);
     c3a:	ce 01       	movw	r24, r28
     c3c:	01 96       	adiw	r24, 0x01	; 1
     c3e:	b5 de       	rcall	.-662    	; 0x9aa <chVTDoResetI>
  else {
    chSchGoSleepS(newstate);
  }

  return tp->u.rdymsg;
}
     c40:	f8 01       	movw	r30, r16
     c42:	82 89       	ldd	r24, Z+18	; 0x12
     c44:	93 89       	ldd	r25, Z+19	; 0x13
     c46:	2c 96       	adiw	r28, 0x0c	; 12
     c48:	0f b6       	in	r0, 0x3f	; 63
     c4a:	f8 94       	cli
     c4c:	de bf       	out	0x3e, r29	; 62
     c4e:	0f be       	out	0x3f, r0	; 63
     c50:	cd bf       	out	0x3d, r28	; 61
     c52:	df 91       	pop	r29
     c54:	cf 91       	pop	r28
     c56:	1f 91       	pop	r17
     c58:	0f 91       	pop	r16
     c5a:	ff 90       	pop	r15
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
     c5c:	08 95       	ret
     c5e:	8f 2d       	mov	r24, r15
     c60:	af df       	rcall	.-162    	; 0xbc0 <chSchGoSleepS>
     c62:	ee cf       	rjmp	.-36     	; 0xc40 <chSchGoSleepTimeoutS+0x48>

00000c64 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
     c64:	cf 93       	push	r28
     c66:	df 93       	push	r29
     c68:	dc 01       	movw	r26, r24
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     c6a:	c0 91 ab 05 	lds	r28, 0x05AB	; 0x8005ab <ch0+0x5>
     c6e:	d0 91 ac 05 	lds	r29, 0x05AC	; 0x8005ac <ch0+0x6>
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
     c72:	53 96       	adiw	r26, 0x13	; 19
     c74:	7c 93       	st	X, r23
     c76:	6e 93       	st	-X, r22
     c78:	52 97       	sbiw	r26, 0x12	; 18
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
     c7a:	14 96       	adiw	r26, 0x04	; 4
     c7c:	2c 91       	ld	r18, X
     c7e:	14 97       	sbiw	r26, 0x04	; 4
     c80:	9c 81       	ldd	r25, Y+4	; 0x04
     c82:	92 17       	cp	r25, r18
     c84:	e8 f0       	brcs	.+58     	; 0xcc0 <chSchWakeupS+0x5c>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     c86:	1f 96       	adiw	r26, 0x0f	; 15
     c88:	1c 92       	st	X, r1
     c8a:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     c8c:	1b 96       	adiw	r26, 0x0b	; 11
     c8e:	ed 91       	ld	r30, X+
     c90:	fc 91       	ld	r31, X
     c92:	1c 97       	sbiw	r26, 0x0c	; 12
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     c94:	01 90       	ld	r0, Z+
     c96:	f0 81       	ld	r31, Z
     c98:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     c9a:	84 81       	ldd	r24, Z+4	; 0x04
     c9c:	82 17       	cp	r24, r18
     c9e:	d0 f7       	brcc	.-12     	; 0xc94 <chSchWakeupS+0x30>

  /* Insertion on prev.*/
  p->next       = pqp;
     ca0:	11 96       	adiw	r26, 0x01	; 1
     ca2:	fc 93       	st	X, r31
     ca4:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     ca6:	c2 81       	ldd	r28, Z+2	; 0x02
     ca8:	d3 81       	ldd	r29, Z+3	; 0x03
     caa:	13 96       	adiw	r26, 0x03	; 3
     cac:	dc 93       	st	X, r29
     cae:	ce 93       	st	-X, r28
     cb0:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     cb2:	b9 83       	std	Y+1, r27	; 0x01
     cb4:	a8 83       	st	Y, r26
  pqp->prev     = p;
     cb6:	b3 83       	std	Z+3, r27	; 0x03
     cb8:	a2 83       	std	Z+2, r26	; 0x02
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
     cba:	df 91       	pop	r29
     cbc:	cf 91       	pop	r28
     cbe:	08 95       	ret

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     cc0:	1f 86       	std	Y+15, r1	; 0x0f

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
     cc2:	eb 85       	ldd	r30, Y+11	; 0x0b
     cc4:	fc 85       	ldd	r31, Y+12	; 0x0c
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     cc6:	01 90       	ld	r0, Z+
     cc8:	f0 81       	ld	r31, Z
     cca:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio > p->prio));
     ccc:	84 81       	ldd	r24, Z+4	; 0x04
     cce:	98 17       	cp	r25, r24
     cd0:	d0 f3       	brcs	.-12     	; 0xcc6 <chSchWakeupS+0x62>
     cd2:	cd 01       	movw	r24, r26

  /* Insertion on prev.*/
  p->next       = pqp;
     cd4:	f9 83       	std	Y+1, r31	; 0x01
     cd6:	e8 83       	st	Y, r30
  p->prev       = pqp->prev;
     cd8:	a2 81       	ldd	r26, Z+2	; 0x02
     cda:	b3 81       	ldd	r27, Z+3	; 0x03
     cdc:	bb 83       	std	Y+3, r27	; 0x03
     cde:	aa 83       	std	Y+2, r26	; 0x02
  p->prev->next = p;
     ce0:	cd 93       	st	X+, r28
     ce2:	dc 93       	st	X, r29
  pqp->prev     = p;
     ce4:	d3 83       	std	Z+3, r29	; 0x03
     ce6:	c2 83       	std	Z+2, r28	; 0x02
    if (otp->hdr.pqueue.prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    ntp->state = CH_STATE_CURRENT;
     ce8:	21 e0       	ldi	r18, 0x01	; 1
     cea:	fc 01       	movw	r30, r24
     cec:	27 87       	std	Z+15, r18	; 0x0f
    __instance_set_currthread(oip, ntp);
     cee:	90 93 ac 05 	sts	0x05AC, r25	; 0x8005ac <ch0+0x6>
     cf2:	80 93 ab 05 	sts	0x05AB, r24	; 0x8005ab <ch0+0x5>

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
     cf6:	be 01       	movw	r22, r28
     cf8:	78 d4       	rcall	.+2288   	; 0x15ea <_port_switch>
  }
}
     cfa:	df 91       	pop	r29
     cfc:	cf 91       	pop	r28
     cfe:	08 95       	ret

00000d00 <chSchIsPreemptionRequired>:
 */
bool chSchIsPreemptionRequired(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
     d00:	a0 91 a6 05 	lds	r26, 0x05A6	; 0x8005a6 <ch0>
     d04:	b0 91 a7 05 	lds	r27, 0x05A7	; 0x8005a7 <ch0+0x1>
  tprio_t p2 = tp->hdr.pqueue.prio;
     d08:	e0 91 ab 05 	lds	r30, 0x05AB	; 0x8005ab <ch0+0x5>
     d0c:	f0 91 ac 05 	lds	r31, 0x05AC	; 0x8005ac <ch0+0x6>
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
     d10:	81 e0       	ldi	r24, 0x01	; 1
     d12:	14 96       	adiw	r26, 0x04	; 4
     d14:	2c 91       	ld	r18, X
     d16:	94 81       	ldd	r25, Z+4	; 0x04
     d18:	92 17       	cp	r25, r18
     d1a:	08 f0       	brcs	.+2      	; 0xd1e <chSchIsPreemptionRequired+0x1e>
     d1c:	80 e0       	ldi	r24, 0x00	; 0
#endif
}
     d1e:	08 95       	ret

00000d20 <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
     d20:	cf 93       	push	r28
     d22:	df 93       	push	r29
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     d24:	a0 91 ab 05 	lds	r26, 0x05AB	; 0x8005ab <ch0+0x5>
     d28:	b0 91 ac 05 	lds	r27, 0x05AC	; 0x8005ac <ch0+0x6>
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
     d2c:	40 91 a6 05 	lds	r20, 0x05A6	; 0x8005a6 <ch0>
     d30:	50 91 a7 05 	lds	r21, 0x05A7	; 0x8005a7 <ch0+0x1>

  pqp->next       = p->next;
     d34:	ea 01       	movw	r28, r20
     d36:	e8 81       	ld	r30, Y
     d38:	f9 81       	ldd	r31, Y+1	; 0x01
     d3a:	f0 93 a7 05 	sts	0x05A7, r31	; 0x8005a7 <ch0+0x1>
     d3e:	e0 93 a6 05 	sts	0x05A6, r30	; 0x8005a6 <ch0>
  pqp->next->prev = pqp;
     d42:	86 ea       	ldi	r24, 0xA6	; 166
     d44:	95 e0       	ldi	r25, 0x05	; 5
     d46:	93 83       	std	Z+3, r25	; 0x03
     d48:	82 83       	std	Z+2, r24	; 0x02
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
     d4a:	81 e0       	ldi	r24, 0x01	; 1
     d4c:	8f 87       	std	Y+15, r24	; 0x0f
  __instance_set_currthread(oip, ntp);
     d4e:	50 93 ac 05 	sts	0x05AC, r21	; 0x8005ac <ch0+0x6>
     d52:	40 93 ab 05 	sts	0x05AB, r20	; 0x8005ab <ch0+0x5>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     d56:	1f 96       	adiw	r26, 0x0f	; 15
     d58:	1c 92       	st	X, r1
     d5a:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
     d5c:	1b 96       	adiw	r26, 0x0b	; 11
     d5e:	ed 91       	ld	r30, X+
     d60:	fc 91       	ld	r31, X
     d62:	1c 97       	sbiw	r26, 0x0c	; 12
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio > p->prio));
     d64:	14 96       	adiw	r26, 0x04	; 4
     d66:	2c 91       	ld	r18, X
     d68:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     d6a:	01 90       	ld	r0, Z+
     d6c:	f0 81       	ld	r31, Z
     d6e:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio > p->prio));
     d70:	94 81       	ldd	r25, Z+4	; 0x04
     d72:	29 17       	cp	r18, r25
     d74:	d0 f3       	brcs	.-12     	; 0xd6a <chSchDoPreemption+0x4a>

  /* Insertion on prev.*/
  p->next       = pqp;
     d76:	11 96       	adiw	r26, 0x01	; 1
     d78:	fc 93       	st	X, r31
     d7a:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     d7c:	82 81       	ldd	r24, Z+2	; 0x02
     d7e:	93 81       	ldd	r25, Z+3	; 0x03
     d80:	13 96       	adiw	r26, 0x03	; 3
     d82:	9c 93       	st	X, r25
     d84:	8e 93       	st	-X, r24
     d86:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     d88:	ec 01       	movw	r28, r24
     d8a:	b9 83       	std	Y+1, r27	; 0x01
     d8c:	a8 83       	st	Y, r26
  pqp->prev     = p;
     d8e:	b3 83       	std	Z+3, r27	; 0x03
     d90:	a2 83       	std	Z+2, r26	; 0x02
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
     d92:	bd 01       	movw	r22, r26
     d94:	ca 01       	movw	r24, r20
     d96:	29 d4       	rcall	.+2130   	; 0x15ea <_port_switch>
}
     d98:	df 91       	pop	r29
     d9a:	cf 91       	pop	r28
     d9c:	08 95       	ret

00000d9e <chSchRescheduleS>:

  chDbgCheckClassS();

  /* Note, we are favoring the path where the reschedule is necessary
     because higher priority threads are ready.*/
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
     d9e:	a0 91 a6 05 	lds	r26, 0x05A6	; 0x8005a6 <ch0>
     da2:	b0 91 a7 05 	lds	r27, 0x05A7	; 0x8005a7 <ch0+0x1>
     da6:	e0 91 ab 05 	lds	r30, 0x05AB	; 0x8005ab <ch0+0x5>
     daa:	f0 91 ac 05 	lds	r31, 0x05AC	; 0x8005ac <ch0+0x6>
     dae:	14 96       	adiw	r26, 0x04	; 4
     db0:	9c 91       	ld	r25, X
     db2:	84 81       	ldd	r24, Z+4	; 0x04
     db4:	89 17       	cp	r24, r25
     db6:	08 f0       	brcs	.+2      	; 0xdba <chSchRescheduleS+0x1c>
    __sch_reschedule_ahead();
  }
}
     db8:	08 95       	ret
  chDbgCheckClassS();

  /* Note, we are favoring the path where the reschedule is necessary
     because higher priority threads are ready.*/
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
    __sch_reschedule_ahead();
     dba:	b2 cf       	rjmp	.-156    	; 0xd20 <chSchDoPreemption>

00000dbc <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
     dbc:	ff cf       	rjmp	.-2      	; 0xdbc <__idle_thread>

00000dbe <chInstanceObjectInit>:
 * @param[in] oicp      pointer to the @p os_instance_config_t structure
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
     dbe:	df 92       	push	r13
     dc0:	ef 92       	push	r14
     dc2:	ff 92       	push	r15
     dc4:	0f 93       	push	r16
     dc6:	1f 93       	push	r17
     dc8:	cf 93       	push	r28
     dca:	df 93       	push	r29
     dcc:	cd b7       	in	r28, 0x3d	; 61
     dce:	de b7       	in	r29, 0x3e	; 62
     dd0:	2b 97       	sbiw	r28, 0x0b	; 11
     dd2:	0f b6       	in	r0, 0x3f	; 63
     dd4:	f8 94       	cli
     dd6:	de bf       	out	0x3e, r29	; 62
     dd8:	0f be       	out	0x3f, r0	; 63
     dda:	cd bf       	out	0x3d, r28	; 61
     ddc:	8c 01       	movw	r16, r24
     dde:	7b 01       	movw	r14, r22
  core_id = port_get_core_id();
#else
  core_id = 0U;
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
     de0:	90 93 a5 05 	sts	0x05A5, r25	; 0x8005a5 <ch_system+0x2>
     de4:	80 93 a4 05 	sts	0x05A4, r24	; 0x8005a4 <ch_system+0x1>

  /* Core associated to this instance.*/
  oip->core_id = core_id;
     de8:	fc 01       	movw	r30, r24
     dea:	14 8e       	std	Z+28, r1	; 0x1c
     dec:	13 8e       	std	Z+27, r1	; 0x1b

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
     dee:	72 a3       	std	Z+34, r23	; 0x22
     df0:	61 a3       	std	Z+33, r22	; 0x21

  /* Port initialization for the current instance.*/
  port_init(oip);
     df2:	dd 24       	eor	r13, r13
     df4:	d3 94       	inc	r13
     df6:	d0 92 ed 05 	sts	0x05ED, r13	; 0x8005ed <__avr_in_isr>
 *
 * @notapi
 */
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {

  pqp->next = pqp;
     dfa:	91 83       	std	Z+1, r25	; 0x01
     dfc:	80 83       	st	Z, r24
  pqp->prev = pqp;
     dfe:	93 83       	std	Z+3, r25	; 0x03
     e00:	82 83       	std	Z+2, r24	; 0x02
  pqp->prio = (tprio_t)0;
     e02:	14 82       	std	Z+4, r1	; 0x04
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {

  ch_queue_init(&rp->queue);
     e04:	47 96       	adiw	r24, 0x17	; 23
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
     e06:	90 8f       	std	Z+24, r25	; 0x18
     e08:	87 8b       	std	Z+23, r24	; 0x17
  qp->prev = qp;
     e0a:	92 8f       	std	Z+26, r25	; 0x1a
     e0c:	81 8f       	std	Z+25, r24	; 0x19
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {

  rfcup->mask = (rfcu_mask_t)0;
     e0e:	15 8e       	std	Z+29, r1	; 0x1d
     e10:	16 8e       	std	Z+30, r1	; 0x1e
     e12:	17 8e       	std	Z+31, r1	; 0x1f
     e14:	10 a2       	std	Z+32, r1	; 0x20
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {

  ch_dlist_init(&vtlp->dlist);
     e16:	40 97       	sbiw	r24, 0x10	; 16
 *
 * @notapi
 */
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {

  dlhp->next  = dlhp;
     e18:	90 87       	std	Z+8, r25	; 0x08
     e1a:	87 83       	std	Z+7, r24	; 0x07
  dlhp->prev  = dlhp;
     e1c:	92 87       	std	Z+10, r25	; 0x0a
     e1e:	81 87       	std	Z+9, r24	; 0x09
  dlhp->delta = (sysinterval_t)-1;
     e20:	8f ef       	ldi	r24, 0xFF	; 255
     e22:	9f ef       	ldi	r25, 0xFF	; 255
     e24:	94 87       	std	Z+12, r25	; 0x0c
     e26:	83 87       	std	Z+11, r24	; 0x0b
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
     e28:	16 86       	std	Z+14, r1	; 0x0e
     e2a:	15 86       	std	Z+13, r1	; 0x0d
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return currcore->vtlist.systime;
     e2c:	20 91 b3 05 	lds	r18, 0x05B3	; 0x8005b3 <ch0+0xd>
     e30:	30 91 b4 05 	lds	r19, 0x05B4	; 0x8005b4 <ch0+0xe>
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
     e34:	27 87       	std	Z+15, r18	; 0x0f
     e36:	30 8b       	std	Z+16, r19	; 0x10
     e38:	11 8a       	std	Z+17, r1	; 0x11
     e3a:	12 8a       	std	Z+18, r1	; 0x12
     e3c:	13 8a       	std	Z+19, r1	; 0x13
     e3e:	14 8a       	std	Z+20, r1	; 0x14
     e40:	15 8a       	std	Z+21, r1	; 0x15
     e42:	16 8a       	std	Z+22, r1	; 0x16
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {

  sdp->panic_msg = NULL;
     e44:	ef 5b       	subi	r30, 0xBF	; 191
     e46:	ff 4f       	sbci	r31, 0xFF	; 255
     e48:	11 82       	std	Z+1, r1	; 0x01
     e4a:	10 82       	st	Z, r1
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
     e4c:	b8 01       	movw	r22, r16
     e4e:	6d 5d       	subi	r22, 0xDD	; 221
     e50:	7f 4f       	sbci	r23, 0xFF	; 255
     e52:	20 e8       	ldi	r18, 0x80	; 128
     e54:	4f e2       	ldi	r20, 0x2F	; 47
     e56:	51 e0       	ldi	r21, 0x01	; 1
     e58:	c8 01       	movw	r24, r16
     e5a:	2a d0       	rcall	.+84     	; 0xeb0 <__thd_object_init>
     e5c:	f8 01       	movw	r30, r16
     e5e:	96 83       	std	Z+6, r25	; 0x06
     e60:	85 83       	std	Z+5, r24	; 0x05
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
     e62:	fc 01       	movw	r30, r24
     e64:	d7 86       	std	Z+15, r13	; 0x0f
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
     e66:	83 e2       	ldi	r24, 0x23	; 35
     e68:	91 e0       	ldi	r25, 0x01	; 1
     e6a:	9a 83       	std	Y+2, r25	; 0x02
     e6c:	89 83       	std	Y+1, r24	; 0x01
     e6e:	f7 01       	movw	r30, r14
     e70:	82 81       	ldd	r24, Z+2	; 0x02
     e72:	93 81       	ldd	r25, Z+3	; 0x03
     e74:	9c 83       	std	Y+4, r25	; 0x04
     e76:	8b 83       	std	Y+3, r24	; 0x03
     e78:	84 81       	ldd	r24, Z+4	; 0x04
     e7a:	95 81       	ldd	r25, Z+5	; 0x05
     e7c:	9e 83       	std	Y+6, r25	; 0x06
     e7e:	8d 83       	std	Y+5, r24	; 0x05
     e80:	df 82       	std	Y+7, r13	; 0x07
     e82:	8e ed       	ldi	r24, 0xDE	; 222
     e84:	96 e0       	ldi	r25, 0x06	; 6
     e86:	99 87       	std	Y+9, r25	; 0x09
     e88:	88 87       	std	Y+8, r24	; 0x08
     e8a:	1b 86       	std	Y+11, r1	; 0x0b
     e8c:	1a 86       	std	Y+10, r1	; 0x0a
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
     e8e:	ce 01       	movw	r24, r28
     e90:	01 96       	adiw	r24, 0x01	; 1
     e92:	9e d0       	rcall	.+316    	; 0xfd0 <chThdCreateI>
  }
#endif
}
     e94:	2b 96       	adiw	r28, 0x0b	; 11
     e96:	0f b6       	in	r0, 0x3f	; 63
     e98:	f8 94       	cli
     e9a:	de bf       	out	0x3e, r29	; 62
     e9c:	0f be       	out	0x3f, r0	; 63
     e9e:	cd bf       	out	0x3d, r28	; 61
     ea0:	df 91       	pop	r29
     ea2:	cf 91       	pop	r28
     ea4:	1f 91       	pop	r17
     ea6:	0f 91       	pop	r16
     ea8:	ff 90       	pop	r15
     eaa:	ef 90       	pop	r14
     eac:	df 90       	pop	r13
     eae:	08 95       	ret

00000eb0 <__thd_object_init>:
void chThdResume(thread_reference_t *trp, msg_t msg) {

  chSysLock();
  chThdResumeS(trp, msg);
  chSysUnlock();
}
     eb0:	cf 93       	push	r28
     eb2:	df 93       	push	r29
     eb4:	fb 01       	movw	r30, r22
     eb6:	24 83       	std	Z+4, r18	; 0x04
     eb8:	32 e0       	ldi	r19, 0x02	; 2
     eba:	37 87       	std	Z+15, r19	; 0x0f
     ebc:	10 8a       	std	Z+16, r1	; 0x10
     ebe:	94 87       	std	Z+12, r25	; 0x0c
     ec0:	83 87       	std	Z+11, r24	; 0x0b
     ec2:	25 8f       	std	Z+29, r18	; 0x1d
     ec4:	14 8e       	std	Z+28, r1	; 0x1c
     ec6:	13 8e       	std	Z+27, r1	; 0x1b
     ec8:	12 8e       	std	Z+26, r1	; 0x1a
     eca:	21 e0       	ldi	r18, 0x01	; 1
     ecc:	21 8b       	std	Z+17, r18	; 0x11
     ece:	56 87       	std	Z+14, r21	; 0x0e
     ed0:	45 87       	std	Z+13, r20	; 0x0d
     ed2:	9b 01       	movw	r18, r22
     ed4:	29 5f       	subi	r18, 0xF9	; 249
     ed6:	3f 4f       	sbci	r19, 0xFF	; 255
     ed8:	ac 01       	movw	r20, r24
     eda:	49 5e       	subi	r20, 0xE9	; 233
     edc:	5f 4f       	sbci	r21, 0xFF	; 255
     ede:	50 87       	std	Z+8, r21	; 0x08
     ee0:	47 83       	std	Z+7, r20	; 0x07
     ee2:	ec 01       	movw	r28, r24
     ee4:	a9 8d       	ldd	r26, Y+25	; 0x19
     ee6:	ba 8d       	ldd	r27, Y+26	; 0x1a
     ee8:	b2 87       	std	Z+10, r27	; 0x0a
     eea:	a1 87       	std	Z+9, r26	; 0x09
     eec:	2d 93       	st	X+, r18
     eee:	3c 93       	st	X, r19
     ef0:	3a 8f       	std	Y+26, r19	; 0x1a
     ef2:	29 8f       	std	Y+25, r18	; 0x19
     ef4:	cb 01       	movw	r24, r22
     ef6:	44 96       	adiw	r24, 0x14	; 20
     ef8:	95 8b       	std	Z+21, r25	; 0x15
     efa:	84 8b       	std	Z+20, r24	; 0x14
     efc:	02 96       	adiw	r24, 0x02	; 2
     efe:	97 8b       	std	Z+23, r25	; 0x17
     f00:	86 8b       	std	Z+22, r24	; 0x16
     f02:	91 8f       	std	Z+25, r25	; 0x19
     f04:	80 8f       	std	Z+24, r24	; 0x18
     f06:	cb 01       	movw	r24, r22
     f08:	df 91       	pop	r29
     f0a:	cf 91       	pop	r28
     f0c:	08 95       	ret

00000f0e <chThdCreateSuspendedI>:
     f0e:	cf 93       	push	r28
     f10:	df 93       	push	r29
     f12:	dc 01       	movw	r26, r24
     f14:	14 96       	adiw	r26, 0x04	; 4
     f16:	2d 91       	ld	r18, X+
     f18:	3c 91       	ld	r19, X
     f1a:	15 97       	sbiw	r26, 0x05	; 5
     f1c:	f9 01       	movw	r30, r18
     f1e:	7e 97       	sbiw	r30, 0x1e	; 30
     f20:	e9 01       	movw	r28, r18
     f22:	e3 97       	sbiw	r28, 0x33	; 51
     f24:	d6 83       	std	Z+6, r29	; 0x06
     f26:	c5 83       	std	Z+5, r28	; 0x05
     f28:	17 96       	adiw	r26, 0x07	; 7
     f2a:	9c 91       	ld	r25, X
     f2c:	17 97       	sbiw	r26, 0x07	; 7
     f2e:	18 96       	adiw	r26, 0x08	; 8
     f30:	8c 91       	ld	r24, X
     f32:	18 97       	sbiw	r26, 0x08	; 8
     f34:	9a 8b       	std	Y+18, r25	; 0x12
     f36:	89 8b       	std	Y+17, r24	; 0x11
     f38:	19 96       	adiw	r26, 0x09	; 9
     f3a:	9c 91       	ld	r25, X
     f3c:	19 97       	sbiw	r26, 0x09	; 9
     f3e:	1a 96       	adiw	r26, 0x0a	; 10
     f40:	8c 91       	ld	r24, X
     f42:	1a 97       	sbiw	r26, 0x0a	; 10
     f44:	98 8b       	std	Y+16, r25	; 0x10
     f46:	8f 87       	std	Y+15, r24	; 0x0f
     f48:	84 e2       	ldi	r24, 0x24	; 36
     f4a:	9b e0       	ldi	r25, 0x0B	; 11
     f4c:	9b 8b       	std	Y+19, r25	; 0x13
     f4e:	8c 8b       	std	Y+20, r24	; 0x14
     f50:	16 96       	adiw	r26, 0x06	; 6
     f52:	8c 91       	ld	r24, X
     f54:	16 97       	sbiw	r26, 0x06	; 6
     f56:	4d 91       	ld	r20, X+
     f58:	5c 91       	ld	r21, X
     f5a:	84 83       	std	Z+4, r24	; 0x04
     f5c:	92 e0       	ldi	r25, 0x02	; 2
     f5e:	97 87       	std	Z+15, r25	; 0x0f
     f60:	10 8a       	std	Z+16, r1	; 0x10
     f62:	66 ea       	ldi	r22, 0xA6	; 166
     f64:	75 e0       	ldi	r23, 0x05	; 5
     f66:	74 87       	std	Z+12, r23	; 0x0c
     f68:	63 87       	std	Z+11, r22	; 0x0b
     f6a:	85 8f       	std	Z+29, r24	; 0x1d
     f6c:	14 8e       	std	Z+28, r1	; 0x1c
     f6e:	13 8e       	std	Z+27, r1	; 0x1b
     f70:	12 8e       	std	Z+26, r1	; 0x1a
     f72:	81 e0       	ldi	r24, 0x01	; 1
     f74:	81 8b       	std	Z+17, r24	; 0x11
     f76:	56 87       	std	Z+14, r21	; 0x0e
     f78:	45 87       	std	Z+13, r20	; 0x0d
     f7a:	d9 01       	movw	r26, r18
     f7c:	57 97       	sbiw	r26, 0x17	; 23
     f7e:	8d eb       	ldi	r24, 0xBD	; 189
     f80:	95 e0       	ldi	r25, 0x05	; 5
     f82:	11 96       	adiw	r26, 0x01	; 1
     f84:	9c 93       	st	X, r25
     f86:	8e 93       	st	-X, r24
     f88:	eb 01       	movw	r28, r22
     f8a:	89 8d       	ldd	r24, Y+25	; 0x19
     f8c:	9a 8d       	ldd	r25, Y+26	; 0x1a
     f8e:	13 96       	adiw	r26, 0x03	; 3
     f90:	9c 93       	st	X, r25
     f92:	8e 93       	st	-X, r24
     f94:	12 97       	sbiw	r26, 0x02	; 2
     f96:	ec 01       	movw	r28, r24
     f98:	b9 83       	std	Y+1, r27	; 0x01
     f9a:	a8 83       	st	Y, r26
     f9c:	eb 01       	movw	r28, r22
     f9e:	ba 8f       	std	Y+26, r27	; 0x1a
     fa0:	a9 8f       	std	Y+25, r26	; 0x19
     fa2:	1d 96       	adiw	r26, 0x0d	; 13
     fa4:	0b 2e       	mov	r0, r27
     fa6:	11 96       	adiw	r26, 0x01	; 1
     fa8:	0c 92       	st	X, r0
     faa:	11 97       	sbiw	r26, 0x01	; 1
     fac:	ac 93       	st	X, r26
     fae:	12 96       	adiw	r26, 0x02	; 2
     fb0:	0b 2e       	mov	r0, r27
     fb2:	11 96       	adiw	r26, 0x01	; 1
     fb4:	0c 92       	st	X, r0
     fb6:	11 97       	sbiw	r26, 0x01	; 1
     fb8:	ac 93       	st	X, r26
     fba:	0a 2e       	mov	r0, r26
     fbc:	1b 2e       	mov	r1, r27
     fbe:	13 96       	adiw	r26, 0x03	; 3
     fc0:	1c 92       	st	X, r1
     fc2:	0e 92       	st	-X, r0
     fc4:	11 24       	eor	r1, r1
     fc6:	12 97       	sbiw	r26, 0x02	; 2
     fc8:	cf 01       	movw	r24, r30
     fca:	df 91       	pop	r29
     fcc:	cf 91       	pop	r28
     fce:	08 95       	ret

00000fd0 <chThdCreateI>:
     fd0:	9e df       	rcall	.-196    	; 0xf0e <chThdCreateSuspendedI>
     fd2:	d2 cd       	rjmp	.-1116   	; 0xb78 <chSchReadyI>

00000fd4 <chThdCreateStatic>:
     fd4:	0f 93       	push	r16
     fd6:	1f 93       	push	r17
     fd8:	cf 93       	push	r28
     fda:	df 93       	push	r29
     fdc:	f8 94       	cli
     fde:	6e 51       	subi	r22, 0x1E	; 30
     fe0:	71 09       	sbc	r23, r1
     fe2:	ec 01       	movw	r28, r24
     fe4:	c6 0f       	add	r28, r22
     fe6:	d7 1f       	adc	r29, r23
     fe8:	fe 01       	movw	r30, r28
     fea:	75 97       	sbiw	r30, 0x15	; 21
     fec:	fe 83       	std	Y+6, r31	; 0x06
     fee:	ed 83       	std	Y+5, r30	; 0x05
     ff0:	22 8b       	std	Z+18, r18	; 0x12
     ff2:	31 8b       	std	Z+17, r19	; 0x11
     ff4:	00 8b       	std	Z+16, r16	; 0x10
     ff6:	17 87       	std	Z+15, r17	; 0x0f
     ff8:	84 e2       	ldi	r24, 0x24	; 36
     ffa:	9b e0       	ldi	r25, 0x0B	; 11
     ffc:	93 8b       	std	Z+19, r25	; 0x13
     ffe:	84 8b       	std	Z+20, r24	; 0x14
    1000:	4c 83       	std	Y+4, r20	; 0x04
    1002:	82 e0       	ldi	r24, 0x02	; 2
    1004:	8f 87       	std	Y+15, r24	; 0x0f
    1006:	18 8a       	std	Y+16, r1	; 0x10
    1008:	e6 ea       	ldi	r30, 0xA6	; 166
    100a:	f5 e0       	ldi	r31, 0x05	; 5
    100c:	fc 87       	std	Y+12, r31	; 0x0c
    100e:	eb 87       	std	Y+11, r30	; 0x0b
    1010:	4d 8f       	std	Y+29, r20	; 0x1d
    1012:	1c 8e       	std	Y+28, r1	; 0x1c
    1014:	1b 8e       	std	Y+27, r1	; 0x1b
    1016:	1a 8e       	std	Y+26, r1	; 0x1a
    1018:	81 e0       	ldi	r24, 0x01	; 1
    101a:	89 8b       	std	Y+17, r24	; 0x11
    101c:	88 e2       	ldi	r24, 0x28	; 40
    101e:	91 e0       	ldi	r25, 0x01	; 1
    1020:	9e 87       	std	Y+14, r25	; 0x0e
    1022:	8d 87       	std	Y+13, r24	; 0x0d
    1024:	ce 01       	movw	r24, r28
    1026:	07 96       	adiw	r24, 0x07	; 7
    1028:	2d eb       	ldi	r18, 0xBD	; 189
    102a:	35 e0       	ldi	r19, 0x05	; 5
    102c:	38 87       	std	Y+8, r19	; 0x08
    102e:	2f 83       	std	Y+7, r18	; 0x07
    1030:	a1 8d       	ldd	r26, Z+25	; 0x19
    1032:	b2 8d       	ldd	r27, Z+26	; 0x1a
    1034:	ba 87       	std	Y+10, r27	; 0x0a
    1036:	a9 87       	std	Y+9, r26	; 0x09
    1038:	8d 93       	st	X+, r24
    103a:	9c 93       	st	X, r25
    103c:	92 8f       	std	Z+26, r25	; 0x1a
    103e:	81 8f       	std	Z+25, r24	; 0x19
    1040:	0d 96       	adiw	r24, 0x0d	; 13
    1042:	9d 8b       	std	Y+21, r25	; 0x15
    1044:	8c 8b       	std	Y+20, r24	; 0x14
    1046:	02 96       	adiw	r24, 0x02	; 2
    1048:	9f 8b       	std	Y+23, r25	; 0x17
    104a:	8e 8b       	std	Y+22, r24	; 0x16
    104c:	99 8f       	std	Y+25, r25	; 0x19
    104e:	88 8f       	std	Y+24, r24	; 0x18
    1050:	70 e0       	ldi	r23, 0x00	; 0
    1052:	60 e0       	ldi	r22, 0x00	; 0
    1054:	ce 01       	movw	r24, r28
    1056:	06 de       	rcall	.-1012   	; 0xc64 <chSchWakeupS>
    1058:	78 94       	sei
    105a:	ce 01       	movw	r24, r28
    105c:	df 91       	pop	r29
    105e:	cf 91       	pop	r28
    1060:	1f 91       	pop	r17
    1062:	0f 91       	pop	r16
    1064:	08 95       	ret

00001066 <chThdExitS>:
    1066:	0f 93       	push	r16
    1068:	1f 93       	push	r17
    106a:	cf 93       	push	r28
    106c:	df 93       	push	r29
    106e:	c0 91 ab 05 	lds	r28, 0x05AB	; 0x8005ab <ch0+0x5>
    1072:	d0 91 ac 05 	lds	r29, 0x05AC	; 0x8005ac <ch0+0x6>
    1076:	9b 8b       	std	Y+19, r25	; 0x13
    1078:	8a 8b       	std	Y+18, r24	; 0x12
    107a:	8e 01       	movw	r16, r28
    107c:	0c 5e       	subi	r16, 0xEC	; 236
    107e:	1f 4f       	sbci	r17, 0xFF	; 255
    1080:	8c 89       	ldd	r24, Y+20	; 0x14
    1082:	9d 89       	ldd	r25, Y+21	; 0x15
    1084:	08 17       	cp	r16, r24
    1086:	19 07       	cpc	r17, r25
    1088:	59 f0       	breq	.+22     	; 0x10a0 <chThdExitS+0x3a>
    108a:	fc 01       	movw	r30, r24
    108c:	20 81       	ld	r18, Z
    108e:	31 81       	ldd	r19, Z+1	; 0x01
    1090:	3d 8b       	std	Y+21, r19	; 0x15
    1092:	2c 8b       	std	Y+20, r18	; 0x14
    1094:	71 dd       	rcall	.-1310   	; 0xb78 <chSchReadyI>
    1096:	8c 89       	ldd	r24, Y+20	; 0x14
    1098:	9d 89       	ldd	r25, Y+21	; 0x15
    109a:	80 17       	cp	r24, r16
    109c:	91 07       	cpc	r25, r17
    109e:	a9 f7       	brne	.-22     	; 0x108a <chThdExitS+0x24>
    10a0:	89 89       	ldd	r24, Y+17	; 0x11
    10a2:	81 11       	cpse	r24, r1
    10a4:	0c c0       	rjmp	.+24     	; 0x10be <chThdExitS+0x58>
    10a6:	e9 85       	ldd	r30, Y+9	; 0x09
    10a8:	fa 85       	ldd	r31, Y+10	; 0x0a
    10aa:	8f 81       	ldd	r24, Y+7	; 0x07
    10ac:	98 85       	ldd	r25, Y+8	; 0x08
    10ae:	91 83       	std	Z+1, r25	; 0x01
    10b0:	80 83       	st	Z, r24
    10b2:	af 81       	ldd	r26, Y+7	; 0x07
    10b4:	b8 85       	ldd	r27, Y+8	; 0x08
    10b6:	13 96       	adiw	r26, 0x03	; 3
    10b8:	fc 93       	st	X, r31
    10ba:	ee 93       	st	-X, r30
    10bc:	12 97       	sbiw	r26, 0x02	; 2
    10be:	8f e0       	ldi	r24, 0x0F	; 15
    10c0:	df 91       	pop	r29
    10c2:	cf 91       	pop	r28
    10c4:	1f 91       	pop	r17
    10c6:	0f 91       	pop	r16
    10c8:	7b cd       	rjmp	.-1290   	; 0xbc0 <chSchGoSleepS>

000010ca <chThdExit>:
    10ca:	f8 94       	cli
    10cc:	cc cf       	rjmp	.-104    	; 0x1066 <chThdExitS>

000010ce <chThdSleep>:
    10ce:	f8 94       	cli
    10d0:	bc 01       	movw	r22, r24
    10d2:	88 e0       	ldi	r24, 0x08	; 8
    10d4:	91 dd       	rcall	.-1246   	; 0xbf8 <chSchGoSleepTimeoutS>
    10d6:	78 94       	sei
    10d8:	08 95       	ret

000010da <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
    10da:	cf 93       	push	r28
    10dc:	df 93       	push	r29
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
    10de:	e0 91 ab 05 	lds	r30, 0x05AB	; 0x8005ab <ch0+0x5>
    10e2:	f0 91 ac 05 	lds	r31, 0x05AC	; 0x8005ac <ch0+0x6>
  thread_t *currtp = chThdGetSelfX();

  if (unlikely(TIME_IMMEDIATE == timeout)) {
    10e6:	61 15       	cp	r22, r1
    10e8:	71 05       	cpc	r23, r1
    10ea:	79 f0       	breq	.+30     	; 0x110a <chThdEnqueueTimeoutS+0x30>
 *
 * @notapi
 */
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {

  p->next       = qp;
    10ec:	91 83       	std	Z+1, r25	; 0x01
    10ee:	80 83       	st	Z, r24
  p->prev       = qp->prev;
    10f0:	ec 01       	movw	r28, r24
    10f2:	aa 81       	ldd	r26, Y+2	; 0x02
    10f4:	bb 81       	ldd	r27, Y+3	; 0x03
    10f6:	b3 83       	std	Z+3, r27	; 0x03
    10f8:	a2 83       	std	Z+2, r26	; 0x02
  p->prev->next = p;
    10fa:	ed 93       	st	X+, r30
    10fc:	fc 93       	st	X, r31
  qp->prev      = p;
    10fe:	fb 83       	std	Y+3, r31	; 0x03
    1100:	ea 83       	std	Y+2, r30	; 0x02
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    1102:	84 e0       	ldi	r24, 0x04	; 4
}
    1104:	df 91       	pop	r29
    1106:	cf 91       	pop	r28
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    1108:	77 cd       	rjmp	.-1298   	; 0xbf8 <chSchGoSleepTimeoutS>
}
    110a:	8f ef       	ldi	r24, 0xFF	; 255
    110c:	9f ef       	ldi	r25, 0xFF	; 255
    110e:	df 91       	pop	r29
    1110:	cf 91       	pop	r28
    1112:	08 95       	ret

00001114 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    1114:	cf 93       	push	r28
    1116:	df 93       	push	r29
    1118:	fc 01       	movw	r30, r24
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    111a:	80 81       	ld	r24, Z
    111c:	91 81       	ldd	r25, Z+1	; 0x01

  if (ch_queue_notempty(&tqp->queue)) {
    111e:	e8 17       	cp	r30, r24
    1120:	f9 07       	cpc	r31, r25
    1122:	71 f0       	breq	.+28     	; 0x1140 <chThdDequeueNextI+0x2c>
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;

  qp->next       = p->next;
    1124:	ec 01       	movw	r28, r24
    1126:	a8 81       	ld	r26, Y
    1128:	b9 81       	ldd	r27, Y+1	; 0x01
    112a:	b1 83       	std	Z+1, r27	; 0x01
    112c:	a0 83       	st	Z, r26
  qp->next->prev = qp;
    112e:	13 96       	adiw	r26, 0x03	; 3
    1130:	fc 93       	st	X, r31
    1132:	ee 93       	st	-X, r30
    1134:	12 97       	sbiw	r26, 0x02	; 2

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
    1136:	7b 8b       	std	Y+19, r23	; 0x13
    1138:	6a 8b       	std	Y+18, r22	; 0x12
    chThdDoDequeueNextI(tqp, msg);
  }
}
    113a:	df 91       	pop	r29
    113c:	cf 91       	pop	r28
  (void) chSchReadyI(tp);
    113e:	1c cd       	rjmp	.-1480   	; 0xb78 <chSchReadyI>
    1140:	df 91       	pop	r29
    1142:	cf 91       	pop	r28
    1144:	08 95       	ret

00001146 <chMtxObjectInit>:
  mp->cnt++;
#endif
  mp->owner = currtp;
  mp->next = currtp->mtxlist;
  currtp->mtxlist = mp;
  return true;
    1146:	fc 01       	movw	r30, r24
    1148:	91 83       	std	Z+1, r25	; 0x01
    114a:	80 83       	st	Z, r24
    114c:	93 83       	std	Z+3, r25	; 0x03
    114e:	82 83       	std	Z+2, r24	; 0x02
    1150:	15 82       	std	Z+5, r1	; 0x05
    1152:	14 82       	std	Z+4, r1	; 0x04
    1154:	08 95       	ret

00001156 <chMtxLockS>:
    1156:	0f 93       	push	r16
    1158:	1f 93       	push	r17
    115a:	cf 93       	push	r28
    115c:	df 93       	push	r29
    115e:	ec 01       	movw	r28, r24
    1160:	00 91 ab 05 	lds	r16, 0x05AB	; 0x8005ab <ch0+0x5>
    1164:	10 91 ac 05 	lds	r17, 0x05AC	; 0x8005ac <ch0+0x6>
    1168:	ec 81       	ldd	r30, Y+4	; 0x04
    116a:	fd 81       	ldd	r31, Y+5	; 0x05
    116c:	30 97       	sbiw	r30, 0x00	; 0
    116e:	09 f4       	brne	.+2      	; 0x1172 <chMtxLockS+0x1c>
    1170:	7e c0       	rjmp	.+252    	; 0x126e <chMtxLockS+0x118>
    1172:	d8 01       	movw	r26, r16
    1174:	14 96       	adiw	r26, 0x04	; 4
    1176:	8c 91       	ld	r24, X
    1178:	94 81       	ldd	r25, Z+4	; 0x04
    117a:	98 17       	cp	r25, r24
    117c:	50 f4       	brcc	.+20     	; 0x1192 <chMtxLockS+0x3c>
    117e:	84 83       	std	Z+4, r24	; 0x04
    1180:	87 85       	ldd	r24, Z+15	; 0x0f
    1182:	86 30       	cpi	r24, 0x06	; 6
    1184:	09 f4       	brne	.+2      	; 0x1188 <chMtxLockS+0x32>
    1186:	85 c0       	rjmp	.+266    	; 0x1292 <chMtxLockS+0x13c>
    1188:	87 30       	cpi	r24, 0x07	; 7
    118a:	71 f1       	breq	.+92     	; 0x11e8 <chMtxLockS+0x92>
    118c:	88 23       	and	r24, r24
    118e:	09 f4       	brne	.+2      	; 0x1192 <chMtxLockS+0x3c>
    1190:	5b c0       	rjmp	.+182    	; 0x1248 <chMtxLockS+0xf2>
    1192:	9e 01       	movw	r18, r28
    1194:	fe 01       	movw	r30, r28
    1196:	07 c0       	rjmp	.+14     	; 0x11a6 <chMtxLockS+0x50>
    1198:	94 81       	ldd	r25, Z+4	; 0x04
    119a:	d8 01       	movw	r26, r16
    119c:	14 96       	adiw	r26, 0x04	; 4
    119e:	8c 91       	ld	r24, X
    11a0:	98 17       	cp	r25, r24
    11a2:	08 f4       	brcc	.+2      	; 0x11a6 <chMtxLockS+0x50>
    11a4:	62 c0       	rjmp	.+196    	; 0x126a <chMtxLockS+0x114>
    11a6:	01 90       	ld	r0, Z+
    11a8:	f0 81       	ld	r31, Z
    11aa:	e0 2d       	mov	r30, r0
    11ac:	ce 17       	cp	r28, r30
    11ae:	df 07       	cpc	r29, r31
    11b0:	99 f7       	brne	.-26     	; 0x1198 <chMtxLockS+0x42>
    11b2:	f8 01       	movw	r30, r16
    11b4:	31 83       	std	Z+1, r19	; 0x01
    11b6:	20 83       	st	Z, r18
    11b8:	d9 01       	movw	r26, r18
    11ba:	12 96       	adiw	r26, 0x02	; 2
    11bc:	ed 91       	ld	r30, X+
    11be:	fc 91       	ld	r31, X
    11c0:	d8 01       	movw	r26, r16
    11c2:	13 96       	adiw	r26, 0x03	; 3
    11c4:	fc 93       	st	X, r31
    11c6:	ee 93       	st	-X, r30
    11c8:	12 97       	sbiw	r26, 0x02	; 2
    11ca:	11 83       	std	Z+1, r17	; 0x01
    11cc:	00 83       	st	Z, r16
    11ce:	f9 01       	movw	r30, r18
    11d0:	13 83       	std	Z+3, r17	; 0x03
    11d2:	02 83       	std	Z+2, r16	; 0x02
    11d4:	53 96       	adiw	r26, 0x13	; 19
    11d6:	dc 93       	st	X, r29
    11d8:	ce 93       	st	-X, r28
    11da:	52 97       	sbiw	r26, 0x12	; 18
    11dc:	86 e0       	ldi	r24, 0x06	; 6
    11de:	df 91       	pop	r29
    11e0:	cf 91       	pop	r28
    11e2:	1f 91       	pop	r17
    11e4:	0f 91       	pop	r16
    11e6:	ec cc       	rjmp	.-1576   	; 0xbc0 <chSchGoSleepS>
    11e8:	22 81       	ldd	r18, Z+2	; 0x02
    11ea:	33 81       	ldd	r19, Z+3	; 0x03
    11ec:	80 81       	ld	r24, Z
    11ee:	91 81       	ldd	r25, Z+1	; 0x01
    11f0:	d9 01       	movw	r26, r18
    11f2:	8d 93       	st	X+, r24
    11f4:	9c 93       	st	X, r25
    11f6:	80 81       	ld	r24, Z
    11f8:	91 81       	ldd	r25, Z+1	; 0x01
    11fa:	dc 01       	movw	r26, r24
    11fc:	13 96       	adiw	r26, 0x03	; 3
    11fe:	3c 93       	st	X, r19
    1200:	2e 93       	st	-X, r18
    1202:	12 97       	sbiw	r26, 0x02	; 2
    1204:	22 89       	ldd	r18, Z+18	; 0x12
    1206:	33 89       	ldd	r19, Z+19	; 0x13
    1208:	d9 01       	movw	r26, r18
    120a:	07 c0       	rjmp	.+14     	; 0x121a <chMtxLockS+0xc4>
    120c:	14 96       	adiw	r26, 0x04	; 4
    120e:	9c 91       	ld	r25, X
    1210:	14 97       	sbiw	r26, 0x04	; 4
    1212:	84 81       	ldd	r24, Z+4	; 0x04
    1214:	98 17       	cp	r25, r24
    1216:	08 f4       	brcc	.+2      	; 0x121a <chMtxLockS+0xc4>
    1218:	78 c0       	rjmp	.+240    	; 0x130a <chMtxLockS+0x1b4>
    121a:	0d 90       	ld	r0, X+
    121c:	bc 91       	ld	r27, X
    121e:	a0 2d       	mov	r26, r0
    1220:	2a 17       	cp	r18, r26
    1222:	3b 07       	cpc	r19, r27
    1224:	99 f7       	brne	.-26     	; 0x120c <chMtxLockS+0xb6>
    1226:	31 83       	std	Z+1, r19	; 0x01
    1228:	20 83       	st	Z, r18
    122a:	d9 01       	movw	r26, r18
    122c:	12 96       	adiw	r26, 0x02	; 2
    122e:	8d 91       	ld	r24, X+
    1230:	9c 91       	ld	r25, X
    1232:	93 83       	std	Z+3, r25	; 0x03
    1234:	82 83       	std	Z+2, r24	; 0x02
    1236:	dc 01       	movw	r26, r24
    1238:	ed 93       	st	X+, r30
    123a:	fc 93       	st	X, r31
    123c:	d9 01       	movw	r26, r18
    123e:	13 96       	adiw	r26, 0x03	; 3
    1240:	fc 93       	st	X, r31
    1242:	ee 93       	st	-X, r30
    1244:	12 97       	sbiw	r26, 0x02	; 2
    1246:	a5 cf       	rjmp	.-182    	; 0x1192 <chMtxLockS+0x3c>
    1248:	22 81       	ldd	r18, Z+2	; 0x02
    124a:	33 81       	ldd	r19, Z+3	; 0x03
    124c:	80 81       	ld	r24, Z
    124e:	91 81       	ldd	r25, Z+1	; 0x01
    1250:	d9 01       	movw	r26, r18
    1252:	8d 93       	st	X+, r24
    1254:	9c 93       	st	X, r25
    1256:	80 81       	ld	r24, Z
    1258:	91 81       	ldd	r25, Z+1	; 0x01
    125a:	dc 01       	movw	r26, r24
    125c:	13 96       	adiw	r26, 0x03	; 3
    125e:	3c 93       	st	X, r19
    1260:	2e 93       	st	-X, r18
    1262:	12 97       	sbiw	r26, 0x02	; 2
    1264:	cf 01       	movw	r24, r30
    1266:	88 dc       	rcall	.-1776   	; 0xb78 <chSchReadyI>
    1268:	94 cf       	rjmp	.-216    	; 0x1192 <chMtxLockS+0x3c>
    126a:	9f 01       	movw	r18, r30
    126c:	a2 cf       	rjmp	.-188    	; 0x11b2 <chMtxLockS+0x5c>
    126e:	1d 83       	std	Y+5, r17	; 0x05
    1270:	0c 83       	std	Y+4, r16	; 0x04
    1272:	d8 01       	movw	r26, r16
    1274:	5b 96       	adiw	r26, 0x1b	; 27
    1276:	8d 91       	ld	r24, X+
    1278:	9c 91       	ld	r25, X
    127a:	5c 97       	sbiw	r26, 0x1c	; 28
    127c:	9f 83       	std	Y+7, r25	; 0x07
    127e:	8e 83       	std	Y+6, r24	; 0x06
    1280:	5c 96       	adiw	r26, 0x1c	; 28
    1282:	dc 93       	st	X, r29
    1284:	ce 93       	st	-X, r28
    1286:	5b 97       	sbiw	r26, 0x1b	; 27
    1288:	df 91       	pop	r29
    128a:	cf 91       	pop	r28
    128c:	1f 91       	pop	r17
    128e:	0f 91       	pop	r16
    1290:	08 95       	ret
    1292:	22 81       	ldd	r18, Z+2	; 0x02
    1294:	33 81       	ldd	r19, Z+3	; 0x03
    1296:	80 81       	ld	r24, Z
    1298:	91 81       	ldd	r25, Z+1	; 0x01
    129a:	d9 01       	movw	r26, r18
    129c:	8d 93       	st	X+, r24
    129e:	9c 93       	st	X, r25
    12a0:	80 81       	ld	r24, Z
    12a2:	91 81       	ldd	r25, Z+1	; 0x01
    12a4:	dc 01       	movw	r26, r24
    12a6:	13 96       	adiw	r26, 0x03	; 3
    12a8:	3c 93       	st	X, r19
    12aa:	2e 93       	st	-X, r18
    12ac:	12 97       	sbiw	r26, 0x02	; 2
    12ae:	22 89       	ldd	r18, Z+18	; 0x12
    12b0:	33 89       	ldd	r19, Z+19	; 0x13
    12b2:	d9 01       	movw	r26, r18
    12b4:	06 c0       	rjmp	.+12     	; 0x12c2 <chMtxLockS+0x16c>
    12b6:	14 96       	adiw	r26, 0x04	; 4
    12b8:	9c 91       	ld	r25, X
    12ba:	14 97       	sbiw	r26, 0x04	; 4
    12bc:	84 81       	ldd	r24, Z+4	; 0x04
    12be:	98 17       	cp	r25, r24
    12c0:	30 f1       	brcs	.+76     	; 0x130e <chMtxLockS+0x1b8>
    12c2:	0d 90       	ld	r0, X+
    12c4:	bc 91       	ld	r27, X
    12c6:	a0 2d       	mov	r26, r0
    12c8:	2a 17       	cp	r18, r26
    12ca:	3b 07       	cpc	r19, r27
    12cc:	a1 f7       	brne	.-24     	; 0x12b6 <chMtxLockS+0x160>
    12ce:	31 83       	std	Z+1, r19	; 0x01
    12d0:	20 83       	st	Z, r18
    12d2:	d9 01       	movw	r26, r18
    12d4:	12 96       	adiw	r26, 0x02	; 2
    12d6:	8d 91       	ld	r24, X+
    12d8:	9c 91       	ld	r25, X
    12da:	93 83       	std	Z+3, r25	; 0x03
    12dc:	82 83       	std	Z+2, r24	; 0x02
    12de:	dc 01       	movw	r26, r24
    12e0:	ed 93       	st	X+, r30
    12e2:	fc 93       	st	X, r31
    12e4:	d9 01       	movw	r26, r18
    12e6:	13 96       	adiw	r26, 0x03	; 3
    12e8:	fc 93       	st	X, r31
    12ea:	ee 93       	st	-X, r30
    12ec:	12 97       	sbiw	r26, 0x02	; 2
    12ee:	02 88       	ldd	r0, Z+18	; 0x12
    12f0:	f3 89       	ldd	r31, Z+19	; 0x13
    12f2:	e0 2d       	mov	r30, r0
    12f4:	04 80       	ldd	r0, Z+4	; 0x04
    12f6:	f5 81       	ldd	r31, Z+5	; 0x05
    12f8:	e0 2d       	mov	r30, r0
    12fa:	d8 01       	movw	r26, r16
    12fc:	14 96       	adiw	r26, 0x04	; 4
    12fe:	8c 91       	ld	r24, X
    1300:	94 81       	ldd	r25, Z+4	; 0x04
    1302:	98 17       	cp	r25, r24
    1304:	08 f4       	brcc	.+2      	; 0x1308 <chMtxLockS+0x1b2>
    1306:	3b cf       	rjmp	.-394    	; 0x117e <chMtxLockS+0x28>
    1308:	44 cf       	rjmp	.-376    	; 0x1192 <chMtxLockS+0x3c>
    130a:	9d 01       	movw	r18, r26
    130c:	8c cf       	rjmp	.-232    	; 0x1226 <chMtxLockS+0xd0>
    130e:	9d 01       	movw	r18, r26
    1310:	de cf       	rjmp	.-68     	; 0x12ce <chMtxLockS+0x178>

00001312 <chMtxLock>:
    1312:	f8 94       	cli
    1314:	20 df       	rcall	.-448    	; 0x1156 <chMtxLockS>
    1316:	78 94       	sei
    1318:	08 95       	ret

0000131a <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
    131a:	cf 93       	push	r28
    131c:	df 93       	push	r29
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
    131e:	c0 91 ab 05 	lds	r28, 0x05AB	; 0x8005ab <ch0+0x5>
    1322:	d0 91 ac 05 	lds	r29, 0x05AC	; 0x8005ac <ch0+0x6>
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1326:	f8 94       	cli
    chDbgAssert(currtp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
    1328:	dc 01       	movw	r26, r24
    132a:	16 96       	adiw	r26, 0x06	; 6
    132c:	ed 91       	ld	r30, X+
    132e:	fc 91       	ld	r31, X
    1330:	17 97       	sbiw	r26, 0x07	; 7
    1332:	fc 8f       	std	Y+28, r31	; 0x1c
    1334:	eb 8f       	std	Y+27, r30	; 0x1b

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
    1336:	2d 91       	ld	r18, X+
    1338:	3c 91       	ld	r19, X
    133a:	28 17       	cp	r18, r24
    133c:	39 07       	cpc	r19, r25
    133e:	81 f1       	breq	.+96     	; 0x13a0 <chMtxUnlock+0x86>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
    1340:	3d 8d       	ldd	r19, Y+29	; 0x1d
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    1342:	30 97       	sbiw	r30, 0x00	; 0
    1344:	79 f0       	breq	.+30     	; 0x1364 <chMtxUnlock+0x4a>
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    1346:	a0 81       	ld	r26, Z
    1348:	b1 81       	ldd	r27, Z+1	; 0x01
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    134a:	ea 17       	cp	r30, r26
    134c:	fb 07       	cpc	r31, r27
    134e:	29 f0       	breq	.+10     	; 0x135a <chMtxUnlock+0x40>
    1350:	14 96       	adiw	r26, 0x04	; 4
    1352:	2c 91       	ld	r18, X
    1354:	32 17       	cp	r19, r18
    1356:	08 f4       	brcc	.+2      	; 0x135a <chMtxUnlock+0x40>
    1358:	32 2f       	mov	r19, r18
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
        }
        lmp = lmp->next;
    135a:	06 80       	ldd	r0, Z+6	; 0x06
    135c:	f7 81       	ldd	r31, Z+7	; 0x07
    135e:	e0 2d       	mov	r30, r0

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    1360:	30 97       	sbiw	r30, 0x00	; 0
    1362:	89 f7       	brne	.-30     	; 0x1346 <chMtxUnlock+0x2c>
    1364:	fc 01       	movw	r30, r24
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
    1366:	3c 83       	std	Y+4, r19	; 0x04
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;
    1368:	a0 81       	ld	r26, Z
    136a:	b1 81       	ldd	r27, Z+1	; 0x01

  qp->next       = p->next;
    136c:	cd 91       	ld	r28, X+
    136e:	dc 91       	ld	r29, X
    1370:	11 97       	sbiw	r26, 0x01	; 1
    1372:	d1 83       	std	Z+1, r29	; 0x01
    1374:	c0 83       	st	Z, r28
  qp->next->prev = qp;
    1376:	9b 83       	std	Y+3, r25	; 0x03
    1378:	8a 83       	std	Y+2, r24	; 0x02
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
    137a:	b5 83       	std	Z+5, r27	; 0x05
    137c:	a4 83       	std	Z+4, r26	; 0x04
      mp->next = tp->mtxlist;
    137e:	5b 96       	adiw	r26, 0x1b	; 27
    1380:	8d 91       	ld	r24, X+
    1382:	9c 91       	ld	r25, X
    1384:	5c 97       	sbiw	r26, 0x1c	; 28
    1386:	97 83       	std	Z+7, r25	; 0x07
    1388:	86 83       	std	Z+6, r24	; 0x06
      tp->mtxlist = mp;
    138a:	5c 96       	adiw	r26, 0x1c	; 28
    138c:	fc 93       	st	X, r31
    138e:	ee 93       	st	-X, r30
    1390:	5b 97       	sbiw	r26, 0x1b	; 27

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
    1392:	cd 01       	movw	r24, r26
    1394:	f1 db       	rcall	.-2078   	; 0xb78 <chSchReadyI>
      chSchRescheduleS();
    1396:	03 dd       	rcall	.-1530   	; 0xd9e <chSchRescheduleS>
    1398:	78 94       	sei
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    139a:	df 91       	pop	r29
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
    139c:	cf 91       	pop	r28
    139e:	08 95       	ret
    13a0:	f9 01       	movw	r30, r18
         just changed priority.*/
      (void) chSchReadyI(tp);
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
    13a2:	15 82       	std	Z+5, r1	; 0x05
    13a4:	14 82       	std	Z+4, r1	; 0x04
    13a6:	78 94       	sei
    13a8:	df 91       	pop	r29
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
    13aa:	cf 91       	pop	r28
    13ac:	08 95       	ret

000013ae <chMtxUnlockS>:
    13ae:	cf 93       	push	r28
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
    13b0:	df 93       	push	r29
    13b2:	ec 01       	movw	r28, r24
    13b4:	20 91 ab 05 	lds	r18, 0x05AB	; 0x8005ab <ch0+0x5>
    13b8:	30 91 ac 05 	lds	r19, 0x05AC	; 0x8005ac <ch0+0x6>
    chDbgAssert(currtp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
    13bc:	ee 81       	ldd	r30, Y+6	; 0x06
    13be:	ff 81       	ldd	r31, Y+7	; 0x07
    13c0:	d9 01       	movw	r26, r18
    13c2:	5c 96       	adiw	r26, 0x1c	; 28
    13c4:	fc 93       	st	X, r31
    13c6:	ee 93       	st	-X, r30
    13c8:	5b 97       	sbiw	r26, 0x1b	; 27

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
    13ca:	a8 81       	ld	r26, Y
    13cc:	b9 81       	ldd	r27, Y+1	; 0x01
    13ce:	a8 17       	cp	r26, r24
    13d0:	b9 07       	cpc	r27, r25
    13d2:	61 f1       	breq	.+88     	; 0x142c <chMtxUnlockS+0x7e>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
    13d4:	d9 01       	movw	r26, r18
    13d6:	5d 96       	adiw	r26, 0x1d	; 29
    13d8:	9c 91       	ld	r25, X
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    13da:	30 97       	sbiw	r30, 0x00	; 0
    13dc:	79 f0       	breq	.+30     	; 0x13fc <chMtxUnlockS+0x4e>
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    13de:	a0 81       	ld	r26, Z
    13e0:	b1 81       	ldd	r27, Z+1	; 0x01
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    13e2:	ea 17       	cp	r30, r26
    13e4:	fb 07       	cpc	r31, r27
    13e6:	29 f0       	breq	.+10     	; 0x13f2 <chMtxUnlockS+0x44>
    13e8:	14 96       	adiw	r26, 0x04	; 4
    13ea:	8c 91       	ld	r24, X
    13ec:	98 17       	cp	r25, r24
    13ee:	08 f4       	brcc	.+2      	; 0x13f2 <chMtxUnlockS+0x44>
    13f0:	98 2f       	mov	r25, r24
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
          newprio = threadref(lmp->queue.next)->hdr.pqueue.prio;
        }
        lmp = lmp->next;
    13f2:	06 80       	ldd	r0, Z+6	; 0x06
    13f4:	f7 81       	ldd	r31, Z+7	; 0x07
    13f6:	e0 2d       	mov	r30, r0

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    13f8:	30 97       	sbiw	r30, 0x00	; 0
    13fa:	89 f7       	brne	.-30     	; 0x13de <chMtxUnlockS+0x30>
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
    13fc:	f9 01       	movw	r30, r18
    13fe:	94 83       	std	Z+4, r25	; 0x04
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;
    1400:	e8 81       	ld	r30, Y
    1402:	f9 81       	ldd	r31, Y+1	; 0x01

  qp->next       = p->next;
    1404:	a0 81       	ld	r26, Z
    1406:	b1 81       	ldd	r27, Z+1	; 0x01
    1408:	b9 83       	std	Y+1, r27	; 0x01
    140a:	a8 83       	st	Y, r26
  qp->next->prev = qp;
    140c:	13 96       	adiw	r26, 0x03	; 3
    140e:	dc 93       	st	X, r29
    1410:	ce 93       	st	-X, r28
    1412:	12 97       	sbiw	r26, 0x02	; 2
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
    1414:	fd 83       	std	Y+5, r31	; 0x05
    1416:	ec 83       	std	Y+4, r30	; 0x04
      mp->next = tp->mtxlist;
    1418:	83 8d       	ldd	r24, Z+27	; 0x1b
    141a:	94 8d       	ldd	r25, Z+28	; 0x1c
    141c:	9f 83       	std	Y+7, r25	; 0x07
    141e:	8e 83       	std	Y+6, r24	; 0x06
      tp->mtxlist = mp;
    1420:	d4 8f       	std	Z+28, r29	; 0x1c
    1422:	c3 8f       	std	Z+27, r28	; 0x1b
      (void) chSchReadyI(tp);
    1424:	cf 01       	movw	r24, r30
      mp->owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
    1426:	df 91       	pop	r29
    1428:	cf 91       	pop	r28
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
      (void) chSchReadyI(tp);
    142a:	a6 cb       	rjmp	.-2228   	; 0xb78 <chSchReadyI>
    }
    else {
      mp->owner = NULL;
    142c:	15 96       	adiw	r26, 0x05	; 5
    142e:	1c 92       	st	X, r1
    1430:	1e 92       	st	-X, r1
    1432:	14 97       	sbiw	r26, 0x04	; 4
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
    1434:	df 91       	pop	r29
    1436:	cf 91       	pop	r28
    1438:	08 95       	ret

0000143a <chCondObjectInit>:
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (ch_queue_notempty(&cp->queue)) {
    chSchReadyI(threadref(ch_queue_fifo_remove(&cp->queue)))->u.rdymsg = MSG_RESET;
  }
}
    143a:	fc 01       	movw	r30, r24
    143c:	91 83       	std	Z+1, r25	; 0x01
    143e:	80 83       	st	Z, r24
    1440:	93 83       	std	Z+3, r25	; 0x03
    1442:	82 83       	std	Z+2, r24	; 0x02
    1444:	08 95       	ret

00001446 <chCondSignal>:
    1446:	cf 93       	push	r28
    1448:	df 93       	push	r29
    144a:	fc 01       	movw	r30, r24
    144c:	f8 94       	cli
    144e:	80 81       	ld	r24, Z
    1450:	91 81       	ldd	r25, Z+1	; 0x01
    1452:	e8 17       	cp	r30, r24
    1454:	f9 07       	cpc	r31, r25
    1456:	61 f0       	breq	.+24     	; 0x1470 <chCondSignal+0x2a>
    1458:	ec 01       	movw	r28, r24
    145a:	a8 81       	ld	r26, Y
    145c:	b9 81       	ldd	r27, Y+1	; 0x01
    145e:	b1 83       	std	Z+1, r27	; 0x01
    1460:	a0 83       	st	Z, r26
    1462:	13 96       	adiw	r26, 0x03	; 3
    1464:	fc 93       	st	X, r31
    1466:	ee 93       	st	-X, r30
    1468:	12 97       	sbiw	r26, 0x02	; 2
    146a:	70 e0       	ldi	r23, 0x00	; 0
    146c:	60 e0       	ldi	r22, 0x00	; 0
    146e:	fa db       	rcall	.-2060   	; 0xc64 <chSchWakeupS>
    1470:	78 94       	sei
    1472:	df 91       	pop	r29
    1474:	cf 91       	pop	r28
    1476:	08 95       	ret

00001478 <chCondWaitS>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
    1478:	ef 92       	push	r14
    147a:	ff 92       	push	r15
    147c:	0f 93       	push	r16
    147e:	1f 93       	push	r17
    1480:	cf 93       	push	r28
    1482:	df 93       	push	r29
    1484:	8c 01       	movw	r16, r24
    1486:	c0 91 ab 05 	lds	r28, 0x05AB	; 0x8005ab <ch0+0x5>
    148a:	d0 91 ac 05 	lds	r29, 0x05AC	; 0x8005ac <ch0+0x6>
 *
 * @xclass
 */
static inline mutex_t *chMtxGetNextMutexX(void) {

  return chThdGetSelfX()->mtxlist;
    148e:	eb 8c       	ldd	r14, Y+27	; 0x1b
    1490:	fc 8c       	ldd	r15, Y+28	; 0x1c
  chDbgCheckClassS();
  chDbgCheck(cp != NULL);
  chDbgAssert(mp != NULL, "not owning a mutex");

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
    1492:	c7 01       	movw	r24, r14
    1494:	8c df       	rcall	.-232    	; 0x13ae <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currtp->u.wtobjp = cp;
    1496:	1b 8b       	std	Y+19, r17	; 0x13
    1498:	0a 8b       	std	Y+18, r16	; 0x12
  ch_sch_prio_insert(&cp->queue, &currtp->hdr.queue);
    149a:	d8 01       	movw	r26, r16
    149c:	f8 01       	movw	r30, r16
    149e:	04 c0       	rjmp	.+8      	; 0x14a8 <chCondWaitS+0x30>
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
  } while ((cp != qp) &&
    14a0:	94 81       	ldd	r25, Z+4	; 0x04
    14a2:	8c 81       	ldd	r24, Y+4	; 0x04
    14a4:	98 17       	cp	r25, r24
    14a6:	18 f1       	brcs	.+70     	; 0x14ee <chCondWaitS+0x76>
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
    14a8:	01 90       	ld	r0, Z+
    14aa:	f0 81       	ld	r31, Z
    14ac:	e0 2d       	mov	r30, r0
  } while ((cp != qp) &&
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
    14ae:	0e 17       	cp	r16, r30
    14b0:	1f 07       	cpc	r17, r31
    14b2:	b1 f7       	brne	.-20     	; 0x14a0 <chCondWaitS+0x28>
  tp->next       = cp;
    14b4:	b9 83       	std	Y+1, r27	; 0x01
    14b6:	a8 83       	st	Y, r26
  tp->prev       = cp->prev;
    14b8:	12 96       	adiw	r26, 0x02	; 2
    14ba:	ed 91       	ld	r30, X+
    14bc:	fc 91       	ld	r31, X
    14be:	13 97       	sbiw	r26, 0x03	; 3
    14c0:	fb 83       	std	Y+3, r31	; 0x03
    14c2:	ea 83       	std	Y+2, r30	; 0x02
  tp->prev->next = tp;
    14c4:	d1 83       	std	Z+1, r29	; 0x01
    14c6:	c0 83       	st	Z, r28
  cp->prev       = tp;
    14c8:	13 96       	adiw	r26, 0x03	; 3
    14ca:	dc 93       	st	X, r29
    14cc:	ce 93       	st	-X, r28
    14ce:	12 97       	sbiw	r26, 0x02	; 2
  chSchGoSleepS(CH_STATE_WTCOND);
    14d0:	87 e0       	ldi	r24, 0x07	; 7
    14d2:	76 db       	rcall	.-2324   	; 0xbc0 <chSchGoSleepS>
  msg = currtp->u.rdymsg;
    14d4:	0a 88       	ldd	r0, Y+18	; 0x12
    14d6:	db 89       	ldd	r29, Y+19	; 0x13
  chMtxLockS(mp);
    14d8:	c0 2d       	mov	r28, r0
    14da:	c7 01       	movw	r24, r14
    14dc:	3c de       	rcall	.-904    	; 0x1156 <chMtxLockS>

  return msg;
}
    14de:	ce 01       	movw	r24, r28
    14e0:	df 91       	pop	r29
    14e2:	cf 91       	pop	r28
    14e4:	1f 91       	pop	r17
    14e6:	0f 91       	pop	r16
    14e8:	ff 90       	pop	r15
    14ea:	ef 90       	pop	r14
    14ec:	08 95       	ret
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
    14ee:	df 01       	movw	r26, r30
    14f0:	e1 cf       	rjmp	.-62     	; 0x14b4 <chCondWaitS+0x3c>

000014f2 <chCondWait>:
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    14f2:	f8 94       	cli
 */
msg_t chCondWait(condition_variable_t *cp) {
  msg_t msg;

  chSysLock();
  msg = chCondWaitS(cp);
    14f4:	c1 df       	rcall	.-126    	; 0x1478 <chCondWaitS>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    14f6:	78 94       	sei
  chSysUnlock();
  return msg;
}
    14f8:	08 95       	ret

000014fa <chEvtSignalI>:

  chSysLock();
  chEvtSignalI(tp, events);
  chSchRescheduleS();
  chSysUnlock();
}
    14fa:	fc 01       	movw	r30, r24
    14fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    14fe:	68 2b       	or	r22, r24
    1500:	62 8f       	std	Z+26, r22	; 0x1a
    1502:	87 85       	ldd	r24, Z+15	; 0x0f
    1504:	8a 30       	cpi	r24, 0x0A	; 10
    1506:	59 f0       	breq	.+22     	; 0x151e <chEvtSignalI+0x24>
    1508:	8b 30       	cpi	r24, 0x0B	; 11
    150a:	09 f0       	breq	.+2      	; 0x150e <chEvtSignalI+0x14>
    150c:	08 95       	ret
    150e:	82 89       	ldd	r24, Z+18	; 0x12
    1510:	68 23       	and	r22, r24
    1512:	86 13       	cpse	r24, r22
    1514:	fb cf       	rjmp	.-10     	; 0x150c <chEvtSignalI+0x12>
    1516:	13 8a       	std	Z+19, r1	; 0x13
    1518:	12 8a       	std	Z+18, r1	; 0x12
    151a:	cf 01       	movw	r24, r30
    151c:	2d cb       	rjmp	.-2470   	; 0xb78 <chSchReadyI>
    151e:	82 89       	ldd	r24, Z+18	; 0x12
    1520:	68 23       	and	r22, r24
    1522:	c9 f7       	brne	.-14     	; 0x1516 <chEvtSignalI+0x1c>
    1524:	08 95       	ret

00001526 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
    1526:	ef 92       	push	r14
    1528:	ff 92       	push	r15
    152a:	1f 93       	push	r17
    152c:	cf 93       	push	r28
    152e:	df 93       	push	r29
    1530:	7c 01       	movw	r14, r24
    1532:	16 2f       	mov	r17, r22
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
    1534:	fc 01       	movw	r30, r24
    1536:	c0 81       	ld	r28, Z
    1538:	d1 81       	ldd	r29, Z+1	; 0x01
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    153a:	8c 17       	cp	r24, r28
    153c:	9d 07       	cpc	r25, r29
    153e:	91 f0       	breq	.+36     	; 0x1564 <chEvtBroadcastFlagsI+0x3e>
  /*lint -restore*/
    elp->flags |= flags;
    1540:	8d 81       	ldd	r24, Y+5	; 0x05
    1542:	81 2b       	or	r24, r17
    1544:	8d 83       	std	Y+5, r24	; 0x05
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    1546:	11 23       	and	r17, r17
    1548:	19 f0       	breq	.+6      	; 0x1550 <chEvtBroadcastFlagsI+0x2a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
    154a:	8e 81       	ldd	r24, Y+6	; 0x06
    154c:	81 23       	and	r24, r17
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    154e:	21 f0       	breq	.+8      	; 0x1558 <chEvtBroadcastFlagsI+0x32>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    1550:	6c 81       	ldd	r22, Y+4	; 0x04
    1552:	8a 81       	ldd	r24, Y+2	; 0x02
    1554:	9b 81       	ldd	r25, Y+3	; 0x03
    1556:	d1 df       	rcall	.-94     	; 0x14fa <chEvtSignalI>
    }
    elp = elp->next;
    1558:	09 90       	ld	r0, Y+
    155a:	d8 81       	ld	r29, Y
    155c:	c0 2d       	mov	r28, r0
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    155e:	ec 16       	cp	r14, r28
    1560:	fd 06       	cpc	r15, r29
    1562:	71 f7       	brne	.-36     	; 0x1540 <chEvtBroadcastFlagsI+0x1a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
  }
}
    1564:	df 91       	pop	r29
    1566:	cf 91       	pop	r28
    1568:	1f 91       	pop	r17
    156a:	ff 90       	pop	r15
    156c:	ef 90       	pop	r14
    156e:	08 95       	ret

00001570 <__core_init>:
  chSysLock();
  p = chCoreAllocFromBaseI(size, align, offset);
  chSysUnlock();

  return p;
}
    1570:	e9 ee       	ldi	r30, 0xE9	; 233
    1572:	f5 e0       	ldi	r31, 0x05	; 5
    1574:	8f ee       	ldi	r24, 0xEF	; 239
    1576:	91 e0       	ldi	r25, 0x01	; 1
    1578:	91 83       	std	Z+1, r25	; 0x01
    157a:	80 83       	st	Z, r24
    157c:	8f e6       	ldi	r24, 0x6F	; 111
    157e:	92 e0       	ldi	r25, 0x02	; 2
    1580:	93 83       	std	Z+3, r25	; 0x03
    1582:	82 83       	std	Z+2, r24	; 0x02
    1584:	08 95       	ret

00001586 <chCoreAllocFromTop>:
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1586:	f8 94       	cli
  uint8_t *p, *prev;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
    1588:	e0 91 eb 05 	lds	r30, 0x05EB	; 0x8005eb <ch_memcore+0x2>
    158c:	f0 91 ec 05 	lds	r31, 0x05EC	; 0x8005ec <ch_memcore+0x3>
    1590:	9f 01       	movw	r18, r30
    1592:	28 1b       	sub	r18, r24
    1594:	39 0b       	sbc	r19, r25
    1596:	c9 01       	movw	r24, r18
    1598:	71 95       	neg	r23
    159a:	61 95       	neg	r22
    159c:	71 09       	sbc	r23, r1
    159e:	86 23       	and	r24, r22
    15a0:	97 23       	and	r25, r23
  prev = p - offset;
    15a2:	9c 01       	movw	r18, r24
    15a4:	24 1b       	sub	r18, r20
    15a6:	35 0b       	sbc	r19, r21

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
    15a8:	40 91 e9 05 	lds	r20, 0x05E9	; 0x8005e9 <ch_memcore>
    15ac:	50 91 ea 05 	lds	r21, 0x05EA	; 0x8005ea <ch_memcore+0x1>
    15b0:	24 17       	cp	r18, r20
    15b2:	35 07       	cpc	r19, r21
    15b4:	48 f0       	brcs	.+18     	; 0x15c8 <chCoreAllocFromTop+0x42>
    15b6:	e2 17       	cp	r30, r18
    15b8:	f3 07       	cpc	r31, r19
    15ba:	30 f0       	brcs	.+12     	; 0x15c8 <chCoreAllocFromTop+0x42>
    return NULL;
  }

  ch_memcore.topmem = prev;
    15bc:	30 93 ec 05 	sts	0x05EC, r19	; 0x8005ec <ch_memcore+0x3>
    15c0:	20 93 eb 05 	sts	0x05EB, r18	; 0x8005eb <ch_memcore+0x2>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    15c4:	78 94       	sei
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
    15c6:	08 95       	ret
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
  prev = p - offset;

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
    return NULL;
    15c8:	90 e0       	ldi	r25, 0x00	; 0
    15ca:	80 e0       	ldi	r24, 0x00	; 0
    15cc:	78 94       	sei
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
    15ce:	08 95       	ret

000015d0 <__heap_init>:
 *
 * @notapi
 */
void __heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
    15d0:	ef e6       	ldi	r30, 0x6F	; 111
    15d2:	f2 e0       	ldi	r31, 0x02	; 2
    15d4:	83 ec       	ldi	r24, 0xC3	; 195
    15d6:	9a e0       	ldi	r25, 0x0A	; 10
    15d8:	91 83       	std	Z+1, r25	; 0x01
    15da:	80 83       	st	Z, r24
  H_NEXT(&default_heap.header) = NULL;
    15dc:	13 82       	std	Z+3, r1	; 0x03
    15de:	12 82       	std	Z+2, r1	; 0x02
  H_PAGES(&default_heap.header) = 0;
    15e0:	15 82       	std	Z+5, r1	; 0x05
    15e2:	14 82       	std	Z+4, r1	; 0x04
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
    15e4:	85 e7       	ldi	r24, 0x75	; 117
    15e6:	92 e0       	ldi	r25, 0x02	; 2
    15e8:	ae cd       	rjmp	.-1188   	; 0x1146 <chMtxObjectInit>

000015ea <_port_switch>:
void _port_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;
  (void)otp;

  asm volatile ("push    r2");
    15ea:	2f 92       	push	r2
  asm volatile ("push    r3");
    15ec:	3f 92       	push	r3
  asm volatile ("push    r4");
    15ee:	4f 92       	push	r4
  asm volatile ("push    r5");
    15f0:	5f 92       	push	r5
  asm volatile ("push    r6");
    15f2:	6f 92       	push	r6
  asm volatile ("push    r7");
    15f4:	7f 92       	push	r7
  asm volatile ("push    r8");
    15f6:	8f 92       	push	r8
  asm volatile ("push    r9");
    15f8:	9f 92       	push	r9
  asm volatile ("push    r10");
    15fa:	af 92       	push	r10
  asm volatile ("push    r11");
    15fc:	bf 92       	push	r11
  asm volatile ("push    r12");
    15fe:	cf 92       	push	r12
  asm volatile ("push    r13");
    1600:	df 92       	push	r13
  asm volatile ("push    r14");
    1602:	ef 92       	push	r14
  asm volatile ("push    r15");
    1604:	ff 92       	push	r15
  asm volatile ("push    r16");
    1606:	0f 93       	push	r16
  asm volatile ("push    r17");
    1608:	1f 93       	push	r17
  asm volatile ("push    r28");
    160a:	cf 93       	push	r28
  asm volatile ("push    r29");
    160c:	df 93       	push	r29

#if defined(__CHIBIOS_RT__)
  asm volatile ("movw    r30, r22");
    160e:	fb 01       	movw	r30, r22
  asm volatile ("in      r0, 0x3d");
    1610:	0d b6       	in	r0, 0x3d	; 61
  asm volatile ("std     Z+5, r0");
    1612:	05 82       	std	Z+5, r0	; 0x05
  asm volatile ("in      r0, 0x3e");
    1614:	0e b6       	in	r0, 0x3e	; 62
  asm volatile ("std     Z+6, r0");
    1616:	06 82       	std	Z+6, r0	; 0x06

  asm volatile ("movw    r30, r24");
    1618:	fc 01       	movw	r30, r24
  asm volatile ("ldd     r0, Z+5");
    161a:	05 80       	ldd	r0, Z+5	; 0x05
  asm volatile ("out     0x3d, r0");
    161c:	0d be       	out	0x3d, r0	; 61
  asm volatile ("ldd     r0, Z+6");
    161e:	06 80       	ldd	r0, Z+6	; 0x06
  asm volatile ("out     0x3e, r0");
    1620:	0e be       	out	0x3e, r0	; 62
  asm volatile ("out     0x3d, r0");
  asm volatile ("ldd     r0, Z+1");
  asm volatile ("out     0x3e, r0");
#endif

  asm volatile ("pop     r29");
    1622:	df 91       	pop	r29
  asm volatile ("pop     r28");
    1624:	cf 91       	pop	r28
  asm volatile ("pop     r17");
    1626:	1f 91       	pop	r17
  asm volatile ("pop     r16");
    1628:	0f 91       	pop	r16
  asm volatile ("pop     r15");
    162a:	ff 90       	pop	r15
  asm volatile ("pop     r14");
    162c:	ef 90       	pop	r14
  asm volatile ("pop     r13");
    162e:	df 90       	pop	r13
  asm volatile ("pop     r12");
    1630:	cf 90       	pop	r12
  asm volatile ("pop     r11");
    1632:	bf 90       	pop	r11
  asm volatile ("pop     r10");
    1634:	af 90       	pop	r10
  asm volatile ("pop     r9");
    1636:	9f 90       	pop	r9
  asm volatile ("pop     r8");
    1638:	8f 90       	pop	r8
  asm volatile ("pop     r7");
    163a:	7f 90       	pop	r7
  asm volatile ("pop     r6");
    163c:	6f 90       	pop	r6
  asm volatile ("pop     r5");
    163e:	5f 90       	pop	r5
  asm volatile ("pop     r4");
    1640:	4f 90       	pop	r4
  asm volatile ("pop     r3");
    1642:	3f 90       	pop	r3
  asm volatile ("pop     r2");
    1644:	2f 90       	pop	r2
  asm volatile ("ret");
    1646:	08 95       	ret

00001648 <_port_thread_start>:
    1648:	78 94       	sei
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
  asm volatile ("movw    r24, r4");
    164a:	c2 01       	movw	r24, r4
  asm volatile ("movw    r30, r2");
    164c:	f1 01       	movw	r30, r2
  asm volatile ("icall");
    164e:	09 95       	icall
  asm volatile ("call    chThdExit");  /* Used for avr5 Architecture. */
    1650:	3c cd       	rjmp	.-1416   	; 0x10ca <chThdExit>
}
    1652:	08 95       	ret

00001654 <InitBuffer>:
  }
}

void InitBuffer()
{
  chMtxObjectInit(&qmtx);
    1654:	8c e4       	ldi	r24, 0x4C	; 76
    1656:	94 e0       	ldi	r25, 0x04	; 4
    1658:	76 dd       	rcall	.-1300   	; 0x1146 <chMtxObjectInit>
  chCondObjectInit(&qempty);
    165a:	88 e4       	ldi	r24, 0x48	; 72
    165c:	94 e0       	ldi	r25, 0x04	; 4
    165e:	ed de       	rcall	.-550    	; 0x143a <chCondObjectInit>
  chCondObjectInit(&qfull);
    1660:	84 e4       	ldi	r24, 0x44	; 68
    1662:	94 e0       	ldi	r25, 0x04	; 4
    1664:	ea de       	rcall	.-556    	; 0x143a <chCondObjectInit>
 
  rdp = wrp = &queue[0];
    1666:	8a e5       	ldi	r24, 0x5A	; 90
    1668:	94 e0       	ldi	r25, 0x04	; 4
    166a:	90 93 57 04 	sts	0x0457, r25	; 0x800457 <wrp+0x1>
    166e:	80 93 56 04 	sts	0x0456, r24	; 0x800456 <wrp>
    1672:	90 93 59 04 	sts	0x0459, r25	; 0x800459 <rdp+0x1>
    1676:	80 93 58 04 	sts	0x0458, r24	; 0x800458 <rdp>
  qsize = 0;
    167a:	10 92 55 04 	sts	0x0455, r1	; 0x800455 <qsize+0x1>
    167e:	10 92 54 04 	sts	0x0454, r1	; 0x800454 <qsize>
}
    1682:	08 95       	ret

00001684 <main>:

/*
 * Application entry point.
 */
int main(void) 
{
    1684:	cf 93       	push	r28
    1686:	df 93       	push	r29
    1688:	00 d0       	rcall	.+0      	; 0x168a <main+0x6>
    168a:	1f 92       	push	r1
    168c:	cd b7       	in	r28, 0x3d	; 61
    168e:	de b7       	in	r29, 0x3e	; 62
  thread_t *thd0 = 0, *thd1 = 0, *thd2 = 0;
  SerialConfig Serial_Configuration = {.sc_brr = UBRR2x(115200), .sc_bits_per_char = USART_CHAR_SIZE_8};
    1690:	80 e1       	ldi	r24, 0x10	; 16
    1692:	90 e0       	ldi	r25, 0x00	; 0
    1694:	9a 83       	std	Y+2, r25	; 0x02
    1696:	89 83       	std	Y+1, r24	; 0x01
    1698:	83 e0       	ldi	r24, 0x03	; 3
    169a:	8b 83       	std	Y+3, r24	; 0x03

  InitBuffer();
    169c:	db df       	rcall	.-74     	; 0x1654 <InitBuffer>
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
    169e:	0e 94 63 00 	call	0xc6	; 0xc6 <halInit>
  chSysInit();
    16a2:	2b d9       	rcall	.-3498   	; 0x8fa <chSysInit>

  sdStart(&SD1, &Serial_Configuration);
    16a4:	be 01       	movw	r22, r28
    16a6:	6f 5f       	subi	r22, 0xFF	; 255
    16a8:	7f 4f       	sbci	r23, 0xFF	; 255
    16aa:	8a e5       	ldi	r24, 0x5A	; 90
    16ac:	95 e0       	ldi	r25, 0x05	; 5
    16ae:	0e 94 08 03 	call	0x610	; 0x610 <sdStart>

  palSetPadMode(IOPORT2, PEDESTRE, PAL_MODE_INPUT_PULLUP);
    16b2:	43 e0       	ldi	r20, 0x03	; 3
    16b4:	60 e1       	ldi	r22, 0x10	; 16
    16b6:	83 e2       	ldi	r24, 0x23	; 35
    16b8:	90 e0       	ldi	r25, 0x00	; 0
    16ba:	08 d8       	rcall	.-4080   	; 0x6cc <_pal_lld_setgroupmode>
  palSetPadMode(IOPORT2, CARRO_SECUNDARIA, PAL_MODE_INPUT_PULLUP);
    16bc:	43 e0       	ldi	r20, 0x03	; 3
    16be:	68 e0       	ldi	r22, 0x08	; 8
    16c0:	83 e2       	ldi	r24, 0x23	; 35
    16c2:	90 e0       	ldi	r25, 0x00	; 0
    16c4:	03 d8       	rcall	.-4090   	; 0x6cc <_pal_lld_setgroupmode>
  palSetPadMode(IOPORT2, AMBULANCIA_PRINCIPAL, PAL_MODE_INPUT_PULLUP);
    16c6:	43 e0       	ldi	r20, 0x03	; 3
    16c8:	64 e0       	ldi	r22, 0x04	; 4
    16ca:	83 e2       	ldi	r24, 0x23	; 35
    16cc:	90 e0       	ldi	r25, 0x00	; 0
    16ce:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
  palSetPadMode(IOPORT2, AMBULANCIA_SECUNDARIA, PAL_MODE_INPUT_PULLUP);  
    16d2:	43 e0       	ldi	r20, 0x03	; 3
    16d4:	62 e0       	ldi	r22, 0x02	; 2
    16d6:	83 e2       	ldi	r24, 0x23	; 35
    16d8:	90 e0       	ldi	r25, 0x00	; 0
    16da:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>

  thd0 = chThdCreateStatic(wa_WriteEvent, sizeof(wa_WriteEvent), NORMALPRIO, Write_Save_Event, NULL);
    16de:	10 e0       	ldi	r17, 0x00	; 0
    16e0:	00 e0       	ldi	r16, 0x00	; 0
    16e2:	2e eb       	ldi	r18, 0xBE	; 190
    16e4:	3b e0       	ldi	r19, 0x0B	; 11
    16e6:	40 e8       	ldi	r20, 0x80	; 128
    16e8:	63 ee       	ldi	r22, 0xE3	; 227
    16ea:	70 e0       	ldi	r23, 0x00	; 0
    16ec:	80 e6       	ldi	r24, 0x60	; 96
    16ee:	93 e0       	ldi	r25, 0x03	; 3
    16f0:	71 dc       	rcall	.-1822   	; 0xfd4 <chThdCreateStatic>
  thd1 = chThdCreateStatic(wa_ReadEvent, sizeof(wa_ReadEvent), NORMALPRIO, Read_Collect_Event, NULL);
    16f2:	2b e1       	ldi	r18, 0x1B	; 27
    16f4:	3c e0       	ldi	r19, 0x0C	; 12
    16f6:	40 e8       	ldi	r20, 0x80	; 128
    16f8:	63 ee       	ldi	r22, 0xE3	; 227
    16fa:	70 e0       	ldi	r23, 0x00	; 0
    16fc:	8d e7       	ldi	r24, 0x7D	; 125
    16fe:	92 e0       	ldi	r25, 0x02	; 2
  //thd2 = chThdCreateStatic(wa_ProcessEvent, sizeof(wa_ProcessEvent), NORMALPRIO, ProcessEvent, NULL);

  while (true) 
  {
    chThdSleepMilliseconds(1);
    1700:	69 dc       	rcall	.-1838   	; 0xfd4 <chThdCreateStatic>
    1702:	80 e1       	ldi	r24, 0x10	; 16
    1704:	90 e0       	ldi	r25, 0x00	; 0
    1706:	e3 dc       	rcall	.-1594   	; 0x10ce <chThdSleep>
    1708:	fc cf       	rjmp	.-8      	; 0x1702 <main+0x7e>

0000170a <PushBUffer>:
  rdp = wrp = &queue[0];
  qsize = 0;
}

void PushBUffer(msg_t msg)
{
    170a:	cf 93       	push	r28
    170c:	df 93       	push	r29
    170e:	ec 01       	movw	r28, r24
  /* Entering monitor.*/
  chMtxLock(&qmtx);
    1710:	8c e4       	ldi	r24, 0x4C	; 76
    1712:	94 e0       	ldi	r25, 0x04	; 4
    1714:	fe dd       	rcall	.-1028   	; 0x1312 <chMtxLock>
  return qsize == 0;
}

int IsBufferFull()
{
  return qsize >= QUEUE_SIZE;
    1716:	80 91 54 04 	lds	r24, 0x0454	; 0x800454 <qsize>
    171a:	90 91 55 04 	lds	r25, 0x0455	; 0x800455 <qsize+0x1>
{
  /* Entering monitor.*/
  chMtxLock(&qmtx);
 
  /* Waiting for space in the queue.*/
  while (IsBufferFull())
    171e:	80 38       	cpi	r24, 0x80	; 128
    1720:	91 05       	cpc	r25, r1
    1722:	50 f0       	brcs	.+20     	; 0x1738 <PushBUffer+0x2e>
    chCondWait(&qfull);
    1724:	84 e4       	ldi	r24, 0x44	; 68
    1726:	94 e0       	ldi	r25, 0x04	; 4
    1728:	e4 de       	rcall	.-568    	; 0x14f2 <chCondWait>
  return qsize == 0;
}

int IsBufferFull()
{
  return qsize >= QUEUE_SIZE;
    172a:	80 91 54 04 	lds	r24, 0x0454	; 0x800454 <qsize>
    172e:	90 91 55 04 	lds	r25, 0x0455	; 0x800455 <qsize+0x1>
{
  /* Entering monitor.*/
  chMtxLock(&qmtx);
 
  /* Waiting for space in the queue.*/
  while (IsBufferFull())
    1732:	80 38       	cpi	r24, 0x80	; 128
    1734:	91 05       	cpc	r25, r1
    1736:	b0 f7       	brcc	.-20     	; 0x1724 <PushBUffer+0x1a>
    chCondWait(&qfull);
 
  /* Writing the message in the queue.*/  
  *wrp = msg;
    1738:	e0 91 56 04 	lds	r30, 0x0456	; 0x800456 <wrp>
    173c:	f0 91 57 04 	lds	r31, 0x0457	; 0x800457 <wrp+0x1>
    1740:	c1 93       	st	Z+, r28
    1742:	d1 93       	st	Z+, r29
  if (++wrp >= &queue[QUEUE_SIZE])
    1744:	25 e0       	ldi	r18, 0x05	; 5
    1746:	ea 35       	cpi	r30, 0x5A	; 90
    1748:	f2 07       	cpc	r31, r18
    174a:	98 f0       	brcs	.+38     	; 0x1772 <PushBUffer+0x68>
    wrp = &queue[0];
    174c:	2a e5       	ldi	r18, 0x5A	; 90
    174e:	34 e0       	ldi	r19, 0x04	; 4
    1750:	30 93 57 04 	sts	0x0457, r19	; 0x800457 <wrp+0x1>
    1754:	20 93 56 04 	sts	0x0456, r18	; 0x800456 <wrp>
  qsize++;
    1758:	01 96       	adiw	r24, 0x01	; 1
    175a:	90 93 55 04 	sts	0x0455, r25	; 0x800455 <qsize+0x1>
    175e:	80 93 54 04 	sts	0x0454, r24	; 0x800454 <qsize>

  /* Signaling that there is at least a message.*/
  chCondSignal(&qempty);
    1762:	88 e4       	ldi	r24, 0x48	; 72
    1764:	94 e0       	ldi	r25, 0x04	; 4
    1766:	6f de       	rcall	.-802    	; 0x1446 <chCondSignal>

  /* Leaving monitor.*/
  chMtxUnlock(&qmtx);
    1768:	8c e4       	ldi	r24, 0x4C	; 76
}
    176a:	94 e0       	ldi	r25, 0x04	; 4
    176c:	df 91       	pop	r29

  /* Signaling that there is at least a message.*/
  chCondSignal(&qempty);

  /* Leaving monitor.*/
  chMtxUnlock(&qmtx);
    176e:	cf 91       	pop	r28
    1770:	d4 cd       	rjmp	.-1112   	; 0x131a <chMtxUnlock>
  while (IsBufferFull())
    chCondWait(&qfull);
 
  /* Writing the message in the queue.*/  
  *wrp = msg;
  if (++wrp >= &queue[QUEUE_SIZE])
    1772:	f0 93 57 04 	sts	0x0457, r31	; 0x800457 <wrp+0x1>
    1776:	e0 93 56 04 	sts	0x0456, r30	; 0x800456 <wrp>
    177a:	ee cf       	rjmp	.-36     	; 0x1758 <PushBUffer+0x4e>

0000177c <Write_Save_Event>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
    177c:	e0 91 ab 05 	lds	r30, 0x05AB	; 0x8005ab <ch0+0x5>
    1780:	f0 91 ac 05 	lds	r31, 0x05AC	; 0x8005ac <ch0+0x6>
    1784:	8a e5       	ldi	r24, 0x5A	; 90
    1786:	91 e0       	ldi	r25, 0x01	; 1
    1788:	96 87       	std	Z+14, r25	; 0x0e
    178a:	85 87       	std	Z+13, r24	; 0x0d
    178c:	09 c0       	rjmp	.+18     	; 0x17a0 <Write_Save_Event+0x24>
  while (1)
  {
    if (palReadPad(IOPORT2, PEDESTRE) == PAL_LOW)
      PushBUffer(PEDESTRE);

    if (palReadPad(IOPORT2, CARRO_SECUNDARIA) == PAL_LOW)
    178e:	1b 9b       	sbis	0x03, 3	; 3
    1790:	0e c0       	rjmp	.+28     	; 0x17ae <Write_Save_Event+0x32>
      PushBUffer(CARRO_SECUNDARIA);

    if (palReadPad(IOPORT2, AMBULANCIA_PRINCIPAL) == PAL_LOW)
    1792:	1a 9b       	sbis	0x03, 2	; 3
    1794:	11 c0       	rjmp	.+34     	; 0x17b8 <Write_Save_Event+0x3c>
      PushBUffer(AMBULANCIA_PRINCIPAL);

    if (palReadPad(IOPORT2, AMBULANCIA_SECUNDARIA) == PAL_LOW)
    1796:	19 9b       	sbis	0x03, 1	; 3
    1798:	14 c0       	rjmp	.+40     	; 0x17c2 <Write_Save_Event+0x46>
      PushBUffer(AMBULANCIA_SECUNDARIA);

    /* Debouce Delay */
    chThdSleepMilliseconds(100);
    179a:	8b e1       	ldi	r24, 0x1B	; 27
    179c:	96 e0       	ldi	r25, 0x06	; 6
    179e:	97 dc       	rcall	.-1746   	; 0x10ce <chThdSleep>
static THD_FUNCTION(Write_Save_Event, arg)
{
  chRegSetThreadName("Save/Write Event");
  while (1)
  {
    if (palReadPad(IOPORT2, PEDESTRE) == PAL_LOW)
    17a0:	1c 99       	sbic	0x03, 4	; 3
    17a2:	f5 cf       	rjmp	.-22     	; 0x178e <Write_Save_Event+0x12>
      PushBUffer(PEDESTRE);
    17a4:	84 e0       	ldi	r24, 0x04	; 4
    17a6:	90 e0       	ldi	r25, 0x00	; 0
    17a8:	b0 df       	rcall	.-160    	; 0x170a <PushBUffer>

    if (palReadPad(IOPORT2, CARRO_SECUNDARIA) == PAL_LOW)
    17aa:	1b 99       	sbic	0x03, 3	; 3
    17ac:	f2 cf       	rjmp	.-28     	; 0x1792 <Write_Save_Event+0x16>
      PushBUffer(CARRO_SECUNDARIA);
    17ae:	83 e0       	ldi	r24, 0x03	; 3
    17b0:	90 e0       	ldi	r25, 0x00	; 0
    17b2:	ab df       	rcall	.-170    	; 0x170a <PushBUffer>

    if (palReadPad(IOPORT2, AMBULANCIA_PRINCIPAL) == PAL_LOW)
    17b4:	1a 99       	sbic	0x03, 2	; 3
      PushBUffer(AMBULANCIA_PRINCIPAL);
    17b6:	ef cf       	rjmp	.-34     	; 0x1796 <Write_Save_Event+0x1a>
    17b8:	82 e0       	ldi	r24, 0x02	; 2
    17ba:	90 e0       	ldi	r25, 0x00	; 0
    17bc:	a6 df       	rcall	.-180    	; 0x170a <PushBUffer>

    if (palReadPad(IOPORT2, AMBULANCIA_SECUNDARIA) == PAL_LOW)
    17be:	19 99       	sbic	0x03, 1	; 3
      PushBUffer(AMBULANCIA_SECUNDARIA);
    17c0:	ec cf       	rjmp	.-40     	; 0x179a <Write_Save_Event+0x1e>
    17c2:	81 e0       	ldi	r24, 0x01	; 1
    17c4:	90 e0       	ldi	r25, 0x00	; 0
    17c6:	a1 df       	rcall	.-190    	; 0x170a <PushBUffer>
    17c8:	e8 cf       	rjmp	.-48     	; 0x179a <Write_Save_Event+0x1e>

000017ca <PopBUffer>:
  /* Leaving monitor.*/
  chMtxUnlock(&qmtx);
}

uint8_t PopBUffer()
{
    17ca:	cf 93       	push	r28
  msg_t msg;
 
  /* Entering monitor.*/
  chMtxLock(&qmtx);
    17cc:	8c e4       	ldi	r24, 0x4C	; 76
    17ce:	94 e0       	ldi	r25, 0x04	; 4
    17d0:	a0 dd       	rcall	.-1216   	; 0x1312 <chMtxLock>
  return (uint8_t)msg;
}

int IsBUfferEmpty()
{
  return qsize == 0;
    17d2:	80 91 54 04 	lds	r24, 0x0454	; 0x800454 <qsize>
    17d6:	90 91 55 04 	lds	r25, 0x0455	; 0x800455 <qsize+0x1>
 
  /* Entering monitor.*/
  chMtxLock(&qmtx);
 
  /* Waiting for messages in the queue.*/
  while (IsBUfferEmpty())
    17da:	00 97       	sbiw	r24, 0x00	; 0
    17dc:	49 f4       	brne	.+18     	; 0x17f0 <PopBUffer+0x26>
    chCondWait(&qempty);
    17de:	88 e4       	ldi	r24, 0x48	; 72
    17e0:	94 e0       	ldi	r25, 0x04	; 4
    17e2:	87 de       	rcall	.-754    	; 0x14f2 <chCondWait>
  return (uint8_t)msg;
}

int IsBUfferEmpty()
{
  return qsize == 0;
    17e4:	80 91 54 04 	lds	r24, 0x0454	; 0x800454 <qsize>
    17e8:	90 91 55 04 	lds	r25, 0x0455	; 0x800455 <qsize+0x1>
 
  /* Entering monitor.*/
  chMtxLock(&qmtx);
 
  /* Waiting for messages in the queue.*/
  while (IsBUfferEmpty())
    17ec:	00 97       	sbiw	r24, 0x00	; 0
    17ee:	b9 f3       	breq	.-18     	; 0x17de <PopBUffer+0x14>
    chCondWait(&qempty);
 
  /* Reading the message from the queue.*/  
  msg = *rdp;
    17f0:	e0 91 58 04 	lds	r30, 0x0458	; 0x800458 <rdp>
    17f4:	f0 91 59 04 	lds	r31, 0x0459	; 0x800459 <rdp+0x1>
    17f8:	c0 81       	ld	r28, Z
  if (++rdp >= &queue[QUEUE_SIZE])
    17fa:	32 96       	adiw	r30, 0x02	; 2
    17fc:	25 e0       	ldi	r18, 0x05	; 5
    17fe:	ea 35       	cpi	r30, 0x5A	; 90
    1800:	f2 07       	cpc	r31, r18
    1802:	a0 f0       	brcs	.+40     	; 0x182c <PopBUffer+0x62>
    rdp = &queue[0];
    1804:	2a e5       	ldi	r18, 0x5A	; 90
    1806:	34 e0       	ldi	r19, 0x04	; 4
    1808:	30 93 59 04 	sts	0x0459, r19	; 0x800459 <rdp+0x1>
    180c:	20 93 58 04 	sts	0x0458, r18	; 0x800458 <rdp>
  qsize--;
    1810:	01 97       	sbiw	r24, 0x01	; 1
    1812:	90 93 55 04 	sts	0x0455, r25	; 0x800455 <qsize+0x1>
    1816:	80 93 54 04 	sts	0x0454, r24	; 0x800454 <qsize>
 
  /* Signaling that there is at least one free slot.*/
  chCondSignal(&qfull);
    181a:	84 e4       	ldi	r24, 0x44	; 68
    181c:	94 e0       	ldi	r25, 0x04	; 4
    181e:	13 de       	rcall	.-986    	; 0x1446 <chCondSignal>
 
  /* Leaving monitor.*/
  chMtxUnlock(&qmtx);
    1820:	8c e4       	ldi	r24, 0x4C	; 76
    1822:	94 e0       	ldi	r25, 0x04	; 4
    1824:	7a dd       	rcall	.-1292   	; 0x131a <chMtxUnlock>
    1826:	8c 2f       	mov	r24, r28
 
  return (uint8_t)msg;
}
    1828:	cf 91       	pop	r28
    182a:	08 95       	ret
    182c:	f0 93 59 04 	sts	0x0459, r31	; 0x800459 <rdp+0x1>
  while (IsBUfferEmpty())
    chCondWait(&qempty);
 
  /* Reading the message from the queue.*/  
  msg = *rdp;
  if (++rdp >= &queue[QUEUE_SIZE])
    1830:	e0 93 58 04 	sts	0x0458, r30	; 0x800458 <rdp>
    1834:	ed cf       	rjmp	.-38     	; 0x1810 <PopBUffer+0x46>

00001836 <Read_Collect_Event>:
    1836:	cf 93       	push	r28
/* 
  * Thread Read Event
*/
static THD_WORKING_AREA(wa_ReadEvent, 128);
static THD_FUNCTION(Read_Collect_Event, arg)
{
    1838:	df 93       	push	r29
    183a:	00 d0       	rcall	.+0      	; 0x183c <Read_Collect_Event+0x6>
    183c:	00 d0       	rcall	.+0      	; 0x183e <Read_Collect_Event+0x8>
    183e:	1f 92       	push	r1
    1840:	cd b7       	in	r28, 0x3d	; 61
    1842:	de b7       	in	r29, 0x3e	; 62
    1844:	e0 91 ab 05 	lds	r30, 0x05AB	; 0x8005ab <ch0+0x5>
    1848:	f0 91 ac 05 	lds	r31, 0x05AC	; 0x8005ac <ch0+0x6>
    184c:	8b e6       	ldi	r24, 0x6B	; 107
    184e:	91 e0       	ldi	r25, 0x01	; 1
    1850:	96 87       	std	Z+14, r25	; 0x0e
    1852:	85 87       	std	Z+13, r24	; 0x0d
    1854:	ce 01       	movw	r24, r28
    1856:	01 96       	adiw	r24, 0x01	; 1
    1858:	7c 01       	movw	r14, r24
  while (1)
  {
    if (!IsBUfferEmpty())
      STATE = PopBUffer();

    snprintf(r, 5, "%d\r\n", STATE);
    185a:	0e e7       	ldi	r16, 0x7E	; 126
    185c:	11 e0       	ldi	r17, 0x01	; 1
    185e:	85 e0       	ldi	r24, 0x05	; 5
    1860:	d8 2e       	mov	r13, r24
    1862:	1c c0       	rjmp	.+56     	; 0x189c <Read_Collect_Event+0x66>
    1864:	80 91 43 04 	lds	r24, 0x0443	; 0x800443 <STATE>
    1868:	1f 92       	push	r1
    186a:	8f 93       	push	r24
    186c:	1f 93       	push	r17
    186e:	0f 93       	push	r16
    1870:	1f 92       	push	r1
    1872:	df 92       	push	r13
    1874:	ff 92       	push	r15
    1876:	ef 92       	push	r14
    1878:	9f d3       	rcall	.+1854   	; 0x1fb8 <snprintf>
    sdWrite(&SD1, &r, sizeof(r));
    187a:	2f ef       	ldi	r18, 0xFF	; 255
    187c:	3f ef       	ldi	r19, 0xFF	; 255
    187e:	45 e0       	ldi	r20, 0x05	; 5
    1880:	50 e0       	ldi	r21, 0x00	; 0
    1882:	b7 01       	movw	r22, r14
    1884:	81 e7       	ldi	r24, 0x71	; 113
    1886:	95 e0       	ldi	r25, 0x05	; 5
    1888:	0e 94 71 02 	call	0x4e2	; 0x4e2 <oqWriteTimeout>
    chThdSleepMilliseconds(1);
    188c:	80 e1       	ldi	r24, 0x10	; 16
    188e:	90 e0       	ldi	r25, 0x00	; 0
    1890:	1e dc       	rcall	.-1988   	; 0x10ce <chThdSleep>
{
  char r[5];
  chRegSetThreadName("Read/Collect Event");
  while (1)
  {
    if (!IsBUfferEmpty())
    1892:	0f b6       	in	r0, 0x3f	; 63
    1894:	f8 94       	cli
    1896:	de bf       	out	0x3e, r29	; 62
    1898:	0f be       	out	0x3f, r0	; 63
    189a:	cd bf       	out	0x3d, r28	; 61
    189c:	80 91 54 04 	lds	r24, 0x0454	; 0x800454 <qsize>
    18a0:	90 91 55 04 	lds	r25, 0x0455	; 0x800455 <qsize+0x1>
    18a4:	89 2b       	or	r24, r25
      STATE = PopBUffer();
    18a6:	f1 f2       	breq	.-68     	; 0x1864 <Read_Collect_Event+0x2e>
    18a8:	90 df       	rcall	.-224    	; 0x17ca <PopBUffer>
    18aa:	80 93 43 04 	sts	0x0443, r24	; 0x800443 <STATE>
    18ae:	dc cf       	rjmp	.-72     	; 0x1868 <Read_Collect_Event+0x32>

000018b0 <vfprintf>:
    18b0:	ab e0       	ldi	r26, 0x0B	; 11
    18b2:	b0 e0       	ldi	r27, 0x00	; 0
    18b4:	ed e5       	ldi	r30, 0x5D	; 93
    18b6:	fc e0       	ldi	r31, 0x0C	; 12
    18b8:	c4 c2       	rjmp	.+1416   	; 0x1e42 <__prologue_saves__+0x8>
    18ba:	6c 01       	movw	r12, r24
    18bc:	7b 01       	movw	r14, r22
    18be:	3a 01       	movw	r6, r20
    18c0:	fc 01       	movw	r30, r24
    18c2:	17 82       	std	Z+7, r1	; 0x07
    18c4:	16 82       	std	Z+6, r1	; 0x06
    18c6:	83 81       	ldd	r24, Z+3	; 0x03
    18c8:	81 ff       	sbrs	r24, 1
    18ca:	ff c0       	rjmp	.+510    	; 0x1aca <vfprintf+0x21a>
    18cc:	ce 01       	movw	r24, r28
    18ce:	01 96       	adiw	r24, 0x01	; 1
    18d0:	4c 01       	movw	r8, r24
    18d2:	f6 01       	movw	r30, r12
    18d4:	b3 80       	ldd	r11, Z+3	; 0x03
    18d6:	f7 01       	movw	r30, r14
    18d8:	b3 fc       	sbrc	r11, 3
    18da:	05 91       	lpm	r16, Z+
    18dc:	b3 fe       	sbrs	r11, 3
    18de:	01 91       	ld	r16, Z+
    18e0:	7f 01       	movw	r14, r30
    18e2:	00 23       	and	r16, r16
    18e4:	41 f1       	breq	.+80     	; 0x1936 <vfprintf+0x86>
    18e6:	05 32       	cpi	r16, 0x25	; 37
    18e8:	39 f4       	brne	.+14     	; 0x18f8 <vfprintf+0x48>
    18ea:	b3 fc       	sbrc	r11, 3
    18ec:	05 91       	lpm	r16, Z+
    18ee:	b3 fe       	sbrs	r11, 3
    18f0:	01 91       	ld	r16, Z+
    18f2:	7f 01       	movw	r14, r30
    18f4:	05 32       	cpi	r16, 0x25	; 37
    18f6:	39 f5       	brne	.+78     	; 0x1946 <vfprintf+0x96>
    18f8:	b6 01       	movw	r22, r12
    18fa:	80 2f       	mov	r24, r16
    18fc:	90 e0       	ldi	r25, 0x00	; 0
    18fe:	2c d3       	rcall	.+1624   	; 0x1f58 <fputc>
    1900:	53 01       	movw	r10, r6
    1902:	35 01       	movw	r6, r10
    1904:	e6 cf       	rjmp	.-52     	; 0x18d2 <vfprintf+0x22>
    1906:	10 68       	ori	r17, 0x80	; 128
    1908:	f7 01       	movw	r30, r14
    190a:	b3 fc       	sbrc	r11, 3
    190c:	05 91       	lpm	r16, Z+
    190e:	b3 fe       	sbrs	r11, 3
    1910:	01 91       	ld	r16, Z+
    1912:	7f 01       	movw	r14, r30
    1914:	17 fd       	sbrc	r17, 7
    1916:	0d c0       	rjmp	.+26     	; 0x1932 <vfprintf+0x82>
    1918:	00 23       	and	r16, r16
    191a:	69 f0       	breq	.+26     	; 0x1936 <vfprintf+0x86>
    191c:	60 2f       	mov	r22, r16
    191e:	70 e0       	ldi	r23, 0x00	; 0
    1920:	8f e6       	ldi	r24, 0x6F	; 111
    1922:	90 e0       	ldi	r25, 0x00	; 0
    1924:	c9 d2       	rcall	.+1426   	; 0x1eb8 <strchr_P>
    1926:	89 2b       	or	r24, r25
    1928:	79 f7       	brne	.-34     	; 0x1908 <vfprintf+0x58>
    192a:	03 32       	cpi	r16, 0x23	; 35
    192c:	51 f0       	breq	.+20     	; 0x1942 <vfprintf+0x92>
    192e:	0c 36       	cpi	r16, 0x6C	; 108
    1930:	51 f3       	breq	.-44     	; 0x1906 <vfprintf+0x56>
    1932:	01 11       	cpse	r16, r1
    1934:	0a c0       	rjmp	.+20     	; 0x194a <vfprintf+0x9a>
    1936:	f6 01       	movw	r30, r12
    1938:	86 81       	ldd	r24, Z+6	; 0x06
    193a:	97 81       	ldd	r25, Z+7	; 0x07
    193c:	2b 96       	adiw	r28, 0x0b	; 11
    193e:	ee e0       	ldi	r30, 0x0E	; 14
    1940:	9c c2       	rjmp	.+1336   	; 0x1e7a <__epilogue_restores__+0x8>
    1942:	10 e1       	ldi	r17, 0x10	; 16
    1944:	e1 cf       	rjmp	.-62     	; 0x1908 <vfprintf+0x58>
    1946:	10 e0       	ldi	r17, 0x00	; 0
    1948:	e5 cf       	rjmp	.-54     	; 0x1914 <vfprintf+0x64>
    194a:	60 2f       	mov	r22, r16
    194c:	70 e0       	ldi	r23, 0x00	; 0
    194e:	88 e6       	ldi	r24, 0x68	; 104
    1950:	90 e0       	ldi	r25, 0x00	; 0
    1952:	b2 d2       	rcall	.+1380   	; 0x1eb8 <strchr_P>
    1954:	89 2b       	or	r24, r25
    1956:	49 f0       	breq	.+18     	; 0x196a <vfprintf+0xba>
    1958:	53 01       	movw	r10, r6
    195a:	f4 e0       	ldi	r31, 0x04	; 4
    195c:	af 0e       	add	r10, r31
    195e:	b1 1c       	adc	r11, r1
    1960:	b6 01       	movw	r22, r12
    1962:	8f e3       	ldi	r24, 0x3F	; 63
    1964:	90 e0       	ldi	r25, 0x00	; 0
    1966:	f8 d2       	rcall	.+1520   	; 0x1f58 <fputc>
    1968:	cc cf       	rjmp	.-104    	; 0x1902 <vfprintf+0x52>
    196a:	03 36       	cpi	r16, 0x63	; 99
    196c:	09 f4       	brne	.+2      	; 0x1970 <vfprintf+0xc0>
    196e:	52 c0       	rjmp	.+164    	; 0x1a14 <vfprintf+0x164>
    1970:	03 37       	cpi	r16, 0x73	; 115
    1972:	09 f4       	brne	.+2      	; 0x1976 <vfprintf+0xc6>
    1974:	59 c0       	rjmp	.+178    	; 0x1a28 <vfprintf+0x178>
    1976:	03 35       	cpi	r16, 0x53	; 83
    1978:	09 f4       	brne	.+2      	; 0x197c <vfprintf+0xcc>
    197a:	55 c0       	rjmp	.+170    	; 0x1a26 <vfprintf+0x176>
    197c:	04 36       	cpi	r16, 0x64	; 100
    197e:	19 f0       	breq	.+6      	; 0x1986 <vfprintf+0xd6>
    1980:	09 36       	cpi	r16, 0x69	; 105
    1982:	09 f0       	breq	.+2      	; 0x1986 <vfprintf+0xd6>
    1984:	70 c0       	rjmp	.+224    	; 0x1a66 <vfprintf+0x1b6>
    1986:	53 01       	movw	r10, r6
    1988:	17 ff       	sbrs	r17, 7
    198a:	62 c0       	rjmp	.+196    	; 0x1a50 <vfprintf+0x1a0>
    198c:	f4 e0       	ldi	r31, 0x04	; 4
    198e:	af 0e       	add	r10, r31
    1990:	b1 1c       	adc	r11, r1
    1992:	f3 01       	movw	r30, r6
    1994:	60 81       	ld	r22, Z
    1996:	71 81       	ldd	r23, Z+1	; 0x01
    1998:	82 81       	ldd	r24, Z+2	; 0x02
    199a:	93 81       	ldd	r25, Z+3	; 0x03
    199c:	1f 7e       	andi	r17, 0xEF	; 239
    199e:	97 ff       	sbrs	r25, 7
    19a0:	08 c0       	rjmp	.+16     	; 0x19b2 <vfprintf+0x102>
    19a2:	90 95       	com	r25
    19a4:	80 95       	com	r24
    19a6:	70 95       	com	r23
    19a8:	61 95       	neg	r22
    19aa:	7f 4f       	sbci	r23, 0xFF	; 255
    19ac:	8f 4f       	sbci	r24, 0xFF	; 255
    19ae:	9f 4f       	sbci	r25, 0xFF	; 255
    19b0:	10 64       	ori	r17, 0x40	; 64
    19b2:	2a e0       	ldi	r18, 0x0A	; 10
    19b4:	30 e0       	ldi	r19, 0x00	; 0
    19b6:	a4 01       	movw	r20, r8
    19b8:	44 d3       	rcall	.+1672   	; 0x2042 <__ultoa_invert>
    19ba:	08 2f       	mov	r16, r24
    19bc:	08 19       	sub	r16, r8
    19be:	16 ff       	sbrs	r17, 6
    19c0:	04 c0       	rjmp	.+8      	; 0x19ca <vfprintf+0x11a>
    19c2:	b6 01       	movw	r22, r12
    19c4:	8d e2       	ldi	r24, 0x2D	; 45
    19c6:	90 e0       	ldi	r25, 0x00	; 0
    19c8:	c7 d2       	rcall	.+1422   	; 0x1f58 <fputc>
    19ca:	14 ff       	sbrs	r17, 4
    19cc:	13 c0       	rjmp	.+38     	; 0x19f4 <vfprintf+0x144>
    19ce:	fe 01       	movw	r30, r28
    19d0:	e0 0f       	add	r30, r16
    19d2:	f1 1d       	adc	r31, r1
    19d4:	80 81       	ld	r24, Z
    19d6:	80 33       	cpi	r24, 0x30	; 48
    19d8:	69 f0       	breq	.+26     	; 0x19f4 <vfprintf+0x144>
    19da:	b6 01       	movw	r22, r12
    19dc:	80 e3       	ldi	r24, 0x30	; 48
    19de:	90 e0       	ldi	r25, 0x00	; 0
    19e0:	bb d2       	rcall	.+1398   	; 0x1f58 <fputc>
    19e2:	12 ff       	sbrs	r17, 2
    19e4:	07 c0       	rjmp	.+14     	; 0x19f4 <vfprintf+0x144>
    19e6:	10 72       	andi	r17, 0x20	; 32
    19e8:	81 2f       	mov	r24, r17
    19ea:	90 e0       	ldi	r25, 0x00	; 0
    19ec:	b6 01       	movw	r22, r12
    19ee:	88 5a       	subi	r24, 0xA8	; 168
    19f0:	9f 4f       	sbci	r25, 0xFF	; 255
    19f2:	b2 d2       	rcall	.+1380   	; 0x1f58 <fputc>
    19f4:	01 50       	subi	r16, 0x01	; 1
    19f6:	10 e0       	ldi	r17, 0x00	; 0
    19f8:	0f 5f       	subi	r16, 0xFF	; 255
    19fa:	1f 4f       	sbci	r17, 0xFF	; 255
    19fc:	08 0d       	add	r16, r8
    19fe:	19 1d       	adc	r17, r9
    1a00:	f8 01       	movw	r30, r16
    1a02:	82 91       	ld	r24, -Z
    1a04:	8f 01       	movw	r16, r30
    1a06:	b6 01       	movw	r22, r12
    1a08:	90 e0       	ldi	r25, 0x00	; 0
    1a0a:	a6 d2       	rcall	.+1356   	; 0x1f58 <fputc>
    1a0c:	08 15       	cp	r16, r8
    1a0e:	19 05       	cpc	r17, r9
    1a10:	b9 f7       	brne	.-18     	; 0x1a00 <vfprintf+0x150>
    1a12:	77 cf       	rjmp	.-274    	; 0x1902 <vfprintf+0x52>
    1a14:	53 01       	movw	r10, r6
    1a16:	82 e0       	ldi	r24, 0x02	; 2
    1a18:	a8 0e       	add	r10, r24
    1a1a:	b1 1c       	adc	r11, r1
    1a1c:	b6 01       	movw	r22, r12
    1a1e:	f3 01       	movw	r30, r6
    1a20:	80 81       	ld	r24, Z
    1a22:	91 81       	ldd	r25, Z+1	; 0x01
    1a24:	a0 cf       	rjmp	.-192    	; 0x1966 <vfprintf+0xb6>
    1a26:	11 60       	ori	r17, 0x01	; 1
    1a28:	53 01       	movw	r10, r6
    1a2a:	f2 e0       	ldi	r31, 0x02	; 2
    1a2c:	af 0e       	add	r10, r31
    1a2e:	b1 1c       	adc	r11, r1
    1a30:	f3 01       	movw	r30, r6
    1a32:	60 80       	ld	r6, Z
    1a34:	71 80       	ldd	r7, Z+1	; 0x01
    1a36:	f3 01       	movw	r30, r6
    1a38:	10 fd       	sbrc	r17, 0
    1a3a:	85 91       	lpm	r24, Z+
    1a3c:	10 ff       	sbrs	r17, 0
    1a3e:	81 91       	ld	r24, Z+
    1a40:	3f 01       	movw	r6, r30
    1a42:	88 23       	and	r24, r24
    1a44:	09 f4       	brne	.+2      	; 0x1a48 <vfprintf+0x198>
    1a46:	5d cf       	rjmp	.-326    	; 0x1902 <vfprintf+0x52>
    1a48:	b6 01       	movw	r22, r12
    1a4a:	90 e0       	ldi	r25, 0x00	; 0
    1a4c:	85 d2       	rcall	.+1290   	; 0x1f58 <fputc>
    1a4e:	f3 cf       	rjmp	.-26     	; 0x1a36 <vfprintf+0x186>
    1a50:	f2 e0       	ldi	r31, 0x02	; 2
    1a52:	af 0e       	add	r10, r31
    1a54:	b1 1c       	adc	r11, r1
    1a56:	f3 01       	movw	r30, r6
    1a58:	60 81       	ld	r22, Z
    1a5a:	71 81       	ldd	r23, Z+1	; 0x01
    1a5c:	07 2e       	mov	r0, r23
    1a5e:	00 0c       	add	r0, r0
    1a60:	88 0b       	sbc	r24, r24
    1a62:	99 0b       	sbc	r25, r25
    1a64:	9b cf       	rjmp	.-202    	; 0x199c <vfprintf+0xec>
    1a66:	00 37       	cpi	r16, 0x70	; 112
    1a68:	09 f1       	breq	.+66     	; 0x1aac <vfprintf+0x1fc>
    1a6a:	40 f4       	brcc	.+16     	; 0x1a7c <vfprintf+0x1cc>
    1a6c:	08 35       	cpi	r16, 0x58	; 88
    1a6e:	01 f1       	breq	.+64     	; 0x1ab0 <vfprintf+0x200>
    1a70:	0f 36       	cpi	r16, 0x6F	; 111
    1a72:	09 f0       	breq	.+2      	; 0x1a76 <vfprintf+0x1c6>
    1a74:	60 cf       	rjmp	.-320    	; 0x1936 <vfprintf+0x86>
    1a76:	28 e0       	ldi	r18, 0x08	; 8
    1a78:	30 e0       	ldi	r19, 0x00	; 0
    1a7a:	0c c0       	rjmp	.+24     	; 0x1a94 <vfprintf+0x1e4>
    1a7c:	05 37       	cpi	r16, 0x75	; 117
    1a7e:	39 f0       	breq	.+14     	; 0x1a8e <vfprintf+0x1de>
    1a80:	08 37       	cpi	r16, 0x78	; 120
    1a82:	09 f0       	breq	.+2      	; 0x1a86 <vfprintf+0x1d6>
    1a84:	58 cf       	rjmp	.-336    	; 0x1936 <vfprintf+0x86>
    1a86:	14 62       	ori	r17, 0x24	; 36
    1a88:	20 e1       	ldi	r18, 0x10	; 16
    1a8a:	30 e0       	ldi	r19, 0x00	; 0
    1a8c:	03 c0       	rjmp	.+6      	; 0x1a94 <vfprintf+0x1e4>
    1a8e:	1f 7e       	andi	r17, 0xEF	; 239
    1a90:	2a e0       	ldi	r18, 0x0A	; 10
    1a92:	30 e0       	ldi	r19, 0x00	; 0
    1a94:	53 01       	movw	r10, r6
    1a96:	17 ff       	sbrs	r17, 7
    1a98:	0f c0       	rjmp	.+30     	; 0x1ab8 <vfprintf+0x208>
    1a9a:	f4 e0       	ldi	r31, 0x04	; 4
    1a9c:	af 0e       	add	r10, r31
    1a9e:	b1 1c       	adc	r11, r1
    1aa0:	f3 01       	movw	r30, r6
    1aa2:	60 81       	ld	r22, Z
    1aa4:	71 81       	ldd	r23, Z+1	; 0x01
    1aa6:	82 81       	ldd	r24, Z+2	; 0x02
    1aa8:	93 81       	ldd	r25, Z+3	; 0x03
    1aaa:	85 cf       	rjmp	.-246    	; 0x19b6 <vfprintf+0x106>
    1aac:	10 61       	ori	r17, 0x10	; 16
    1aae:	eb cf       	rjmp	.-42     	; 0x1a86 <vfprintf+0x1d6>
    1ab0:	14 60       	ori	r17, 0x04	; 4
    1ab2:	20 e1       	ldi	r18, 0x10	; 16
    1ab4:	32 e0       	ldi	r19, 0x02	; 2
    1ab6:	ee cf       	rjmp	.-36     	; 0x1a94 <vfprintf+0x1e4>
    1ab8:	f2 e0       	ldi	r31, 0x02	; 2
    1aba:	af 0e       	add	r10, r31
    1abc:	b1 1c       	adc	r11, r1
    1abe:	f3 01       	movw	r30, r6
    1ac0:	60 81       	ld	r22, Z
    1ac2:	71 81       	ldd	r23, Z+1	; 0x01
    1ac4:	90 e0       	ldi	r25, 0x00	; 0
    1ac6:	80 e0       	ldi	r24, 0x00	; 0
    1ac8:	76 cf       	rjmp	.-276    	; 0x19b6 <vfprintf+0x106>
    1aca:	8f ef       	ldi	r24, 0xFF	; 255
    1acc:	9f ef       	ldi	r25, 0xFF	; 255
    1ace:	36 cf       	rjmp	.-404    	; 0x193c <vfprintf+0x8c>

00001ad0 <putval>:
    1ad0:	20 fd       	sbrc	r18, 0
    1ad2:	09 c0       	rjmp	.+18     	; 0x1ae6 <putval+0x16>
    1ad4:	fc 01       	movw	r30, r24
    1ad6:	23 fd       	sbrc	r18, 3
    1ad8:	05 c0       	rjmp	.+10     	; 0x1ae4 <putval+0x14>
    1ada:	22 ff       	sbrs	r18, 2
    1adc:	02 c0       	rjmp	.+4      	; 0x1ae2 <putval+0x12>
    1ade:	73 83       	std	Z+3, r23	; 0x03
    1ae0:	62 83       	std	Z+2, r22	; 0x02
    1ae2:	51 83       	std	Z+1, r21	; 0x01
    1ae4:	40 83       	st	Z, r20
    1ae6:	08 95       	ret

00001ae8 <mulacc>:
    1ae8:	44 fd       	sbrc	r20, 4
    1aea:	17 c0       	rjmp	.+46     	; 0x1b1a <mulacc+0x32>
    1aec:	46 fd       	sbrc	r20, 6
    1aee:	1d c0       	rjmp	.+58     	; 0x1b2a <mulacc+0x42>
    1af0:	db 01       	movw	r26, r22
    1af2:	fc 01       	movw	r30, r24
    1af4:	aa 0f       	add	r26, r26
    1af6:	bb 1f       	adc	r27, r27
    1af8:	ee 1f       	adc	r30, r30
    1afa:	ff 1f       	adc	r31, r31
    1afc:	10 94       	com	r1
    1afe:	d1 f7       	brne	.-12     	; 0x1af4 <mulacc+0xc>
    1b00:	6a 0f       	add	r22, r26
    1b02:	7b 1f       	adc	r23, r27
    1b04:	8e 1f       	adc	r24, r30
    1b06:	9f 1f       	adc	r25, r31
    1b08:	66 0f       	add	r22, r22
    1b0a:	77 1f       	adc	r23, r23
    1b0c:	88 1f       	adc	r24, r24
    1b0e:	99 1f       	adc	r25, r25
    1b10:	62 0f       	add	r22, r18
    1b12:	71 1d       	adc	r23, r1
    1b14:	81 1d       	adc	r24, r1
    1b16:	91 1d       	adc	r25, r1
    1b18:	08 95       	ret
    1b1a:	33 e0       	ldi	r19, 0x03	; 3
    1b1c:	66 0f       	add	r22, r22
    1b1e:	77 1f       	adc	r23, r23
    1b20:	88 1f       	adc	r24, r24
    1b22:	99 1f       	adc	r25, r25
    1b24:	31 50       	subi	r19, 0x01	; 1
    1b26:	d1 f7       	brne	.-12     	; 0x1b1c <mulacc+0x34>
    1b28:	f3 cf       	rjmp	.-26     	; 0x1b10 <mulacc+0x28>
    1b2a:	34 e0       	ldi	r19, 0x04	; 4
    1b2c:	f7 cf       	rjmp	.-18     	; 0x1b1c <mulacc+0x34>

00001b2e <skip_spaces>:
    1b2e:	0f 93       	push	r16
    1b30:	1f 93       	push	r17
    1b32:	cf 93       	push	r28
    1b34:	df 93       	push	r29
    1b36:	8c 01       	movw	r16, r24
    1b38:	c8 01       	movw	r24, r16
    1b3a:	d2 d1       	rcall	.+932    	; 0x1ee0 <fgetc>
    1b3c:	ec 01       	movw	r28, r24
    1b3e:	97 fd       	sbrc	r25, 7
    1b40:	06 c0       	rjmp	.+12     	; 0x1b4e <skip_spaces+0x20>
    1b42:	b2 d1       	rcall	.+868    	; 0x1ea8 <isspace>
    1b44:	89 2b       	or	r24, r25
    1b46:	c1 f7       	brne	.-16     	; 0x1b38 <skip_spaces+0xa>
    1b48:	b8 01       	movw	r22, r16
    1b4a:	ce 01       	movw	r24, r28
    1b4c:	62 d2       	rcall	.+1220   	; 0x2012 <ungetc>
    1b4e:	ce 01       	movw	r24, r28
    1b50:	df 91       	pop	r29
    1b52:	cf 91       	pop	r28
    1b54:	1f 91       	pop	r17
    1b56:	0f 91       	pop	r16
    1b58:	08 95       	ret

00001b5a <conv_int>:
    1b5a:	8f 92       	push	r8
    1b5c:	9f 92       	push	r9
    1b5e:	af 92       	push	r10
    1b60:	bf 92       	push	r11
    1b62:	ef 92       	push	r14
    1b64:	ff 92       	push	r15
    1b66:	0f 93       	push	r16
    1b68:	1f 93       	push	r17
    1b6a:	cf 93       	push	r28
    1b6c:	df 93       	push	r29
    1b6e:	8c 01       	movw	r16, r24
    1b70:	d6 2f       	mov	r29, r22
    1b72:	7a 01       	movw	r14, r20
    1b74:	b2 2e       	mov	r11, r18
    1b76:	b4 d1       	rcall	.+872    	; 0x1ee0 <fgetc>
    1b78:	9c 01       	movw	r18, r24
    1b7a:	33 27       	eor	r19, r19
    1b7c:	2b 32       	cpi	r18, 0x2B	; 43
    1b7e:	31 05       	cpc	r19, r1
    1b80:	29 f0       	breq	.+10     	; 0x1b8c <conv_int+0x32>
    1b82:	2d 32       	cpi	r18, 0x2D	; 45
    1b84:	31 05       	cpc	r19, r1
    1b86:	a1 f4       	brne	.+40     	; 0x1bb0 <conv_int+0x56>
    1b88:	68 94       	set
    1b8a:	b7 f8       	bld	r11, 7
    1b8c:	d1 50       	subi	r29, 0x01	; 1
    1b8e:	61 f4       	brne	.+24     	; 0x1ba8 <conv_int+0x4e>
    1b90:	80 e0       	ldi	r24, 0x00	; 0
    1b92:	df 91       	pop	r29
    1b94:	cf 91       	pop	r28
    1b96:	1f 91       	pop	r17
    1b98:	0f 91       	pop	r16
    1b9a:	ff 90       	pop	r15
    1b9c:	ef 90       	pop	r14
    1b9e:	bf 90       	pop	r11
    1ba0:	af 90       	pop	r10
    1ba2:	9f 90       	pop	r9
    1ba4:	8f 90       	pop	r8
    1ba6:	08 95       	ret
    1ba8:	c8 01       	movw	r24, r16
    1baa:	9a d1       	rcall	.+820    	; 0x1ee0 <fgetc>
    1bac:	97 fd       	sbrc	r25, 7
    1bae:	f0 cf       	rjmp	.-32     	; 0x1b90 <conv_int+0x36>
    1bb0:	cb 2d       	mov	r28, r11
    1bb2:	cd 7f       	andi	r28, 0xFD	; 253
    1bb4:	2b 2d       	mov	r18, r11
    1bb6:	20 73       	andi	r18, 0x30	; 48
    1bb8:	e9 f4       	brne	.+58     	; 0x1bf4 <conv_int+0x9a>
    1bba:	80 33       	cpi	r24, 0x30	; 48
    1bbc:	d9 f4       	brne	.+54     	; 0x1bf4 <conv_int+0x9a>
    1bbe:	aa 24       	eor	r10, r10
    1bc0:	aa 94       	dec	r10
    1bc2:	ad 0e       	add	r10, r29
    1bc4:	79 f0       	breq	.+30     	; 0x1be4 <conv_int+0x8a>
    1bc6:	c8 01       	movw	r24, r16
    1bc8:	8b d1       	rcall	.+790    	; 0x1ee0 <fgetc>
    1bca:	97 fd       	sbrc	r25, 7
    1bcc:	0b c0       	rjmp	.+22     	; 0x1be4 <conv_int+0x8a>
    1bce:	28 2f       	mov	r18, r24
    1bd0:	2f 7d       	andi	r18, 0xDF	; 223
    1bd2:	28 35       	cpi	r18, 0x58	; 88
    1bd4:	59 f4       	brne	.+22     	; 0x1bec <conv_int+0x92>
    1bd6:	c2 64       	ori	r28, 0x42	; 66
    1bd8:	d2 50       	subi	r29, 0x02	; 2
    1bda:	21 f0       	breq	.+8      	; 0x1be4 <conv_int+0x8a>
    1bdc:	c8 01       	movw	r24, r16
    1bde:	80 d1       	rcall	.+768    	; 0x1ee0 <fgetc>
    1be0:	97 ff       	sbrs	r25, 7
    1be2:	08 c0       	rjmp	.+16     	; 0x1bf4 <conv_int+0x9a>
    1be4:	81 2c       	mov	r8, r1
    1be6:	91 2c       	mov	r9, r1
    1be8:	54 01       	movw	r10, r8
    1bea:	1a c0       	rjmp	.+52     	; 0x1c20 <conv_int+0xc6>
    1bec:	b6 fe       	sbrs	r11, 6
    1bee:	29 c0       	rjmp	.+82     	; 0x1c42 <conv_int+0xe8>
    1bf0:	c2 60       	ori	r28, 0x02	; 2
    1bf2:	da 2d       	mov	r29, r10
    1bf4:	81 2c       	mov	r8, r1
    1bf6:	91 2c       	mov	r9, r1
    1bf8:	54 01       	movw	r10, r8
    1bfa:	20 ed       	ldi	r18, 0xD0	; 208
    1bfc:	28 0f       	add	r18, r24
    1bfe:	28 30       	cpi	r18, 0x08	; 8
    1c00:	18 f1       	brcs	.+70     	; 0x1c48 <conv_int+0xee>
    1c02:	c4 fd       	sbrc	r28, 4
    1c04:	09 c0       	rjmp	.+18     	; 0x1c18 <conv_int+0xbe>
    1c06:	2a 30       	cpi	r18, 0x0A	; 10
    1c08:	f8 f0       	brcs	.+62     	; 0x1c48 <conv_int+0xee>
    1c0a:	c6 ff       	sbrs	r28, 6
    1c0c:	05 c0       	rjmp	.+10     	; 0x1c18 <conv_int+0xbe>
    1c0e:	2f 7d       	andi	r18, 0xDF	; 223
    1c10:	3f ee       	ldi	r19, 0xEF	; 239
    1c12:	32 0f       	add	r19, r18
    1c14:	36 30       	cpi	r19, 0x06	; 6
    1c16:	b8 f0       	brcs	.+46     	; 0x1c46 <conv_int+0xec>
    1c18:	b8 01       	movw	r22, r16
    1c1a:	fb d1       	rcall	.+1014   	; 0x2012 <ungetc>
    1c1c:	c1 ff       	sbrs	r28, 1
    1c1e:	b8 cf       	rjmp	.-144    	; 0x1b90 <conv_int+0x36>
    1c20:	c7 ff       	sbrs	r28, 7
    1c22:	08 c0       	rjmp	.+16     	; 0x1c34 <conv_int+0xda>
    1c24:	b0 94       	com	r11
    1c26:	a0 94       	com	r10
    1c28:	90 94       	com	r9
    1c2a:	80 94       	com	r8
    1c2c:	81 1c       	adc	r8, r1
    1c2e:	91 1c       	adc	r9, r1
    1c30:	a1 1c       	adc	r10, r1
    1c32:	b1 1c       	adc	r11, r1
    1c34:	2c 2f       	mov	r18, r28
    1c36:	b5 01       	movw	r22, r10
    1c38:	a4 01       	movw	r20, r8
    1c3a:	c7 01       	movw	r24, r14
    1c3c:	49 df       	rcall	.-366    	; 0x1ad0 <putval>
    1c3e:	81 e0       	ldi	r24, 0x01	; 1
    1c40:	a8 cf       	rjmp	.-176    	; 0x1b92 <conv_int+0x38>
    1c42:	c2 61       	ori	r28, 0x12	; 18
    1c44:	d6 cf       	rjmp	.-84     	; 0x1bf2 <conv_int+0x98>
    1c46:	27 50       	subi	r18, 0x07	; 7
    1c48:	4c 2f       	mov	r20, r28
    1c4a:	c5 01       	movw	r24, r10
    1c4c:	b4 01       	movw	r22, r8
    1c4e:	4c df       	rcall	.-360    	; 0x1ae8 <mulacc>
    1c50:	4b 01       	movw	r8, r22
    1c52:	5c 01       	movw	r10, r24
    1c54:	c2 60       	ori	r28, 0x02	; 2
    1c56:	d1 50       	subi	r29, 0x01	; 1
    1c58:	19 f3       	breq	.-58     	; 0x1c20 <conv_int+0xc6>
    1c5a:	c8 01       	movw	r24, r16
    1c5c:	41 d1       	rcall	.+642    	; 0x1ee0 <fgetc>
    1c5e:	97 ff       	sbrs	r25, 7
    1c60:	cc cf       	rjmp	.-104    	; 0x1bfa <conv_int+0xa0>
    1c62:	dc cf       	rjmp	.-72     	; 0x1c1c <conv_int+0xc2>

00001c64 <vfscanf>:
    1c64:	b0 e0       	ldi	r27, 0x00	; 0
    1c66:	a0 e0       	ldi	r26, 0x00	; 0
    1c68:	e7 e3       	ldi	r30, 0x37	; 55
    1c6a:	fe e0       	ldi	r31, 0x0E	; 14
    1c6c:	e9 c0       	rjmp	.+466    	; 0x1e40 <__prologue_saves__+0x6>
    1c6e:	6c 01       	movw	r12, r24
    1c70:	eb 01       	movw	r28, r22
    1c72:	5a 01       	movw	r10, r20
    1c74:	fc 01       	movw	r30, r24
    1c76:	17 82       	std	Z+7, r1	; 0x07
    1c78:	16 82       	std	Z+6, r1	; 0x06
    1c7a:	51 2c       	mov	r5, r1
    1c7c:	f6 01       	movw	r30, r12
    1c7e:	f3 80       	ldd	r15, Z+3	; 0x03
    1c80:	fe 01       	movw	r30, r28
    1c82:	f3 fc       	sbrc	r15, 3
    1c84:	85 91       	lpm	r24, Z+
    1c86:	f3 fe       	sbrs	r15, 3
    1c88:	81 91       	ld	r24, Z+
    1c8a:	18 2f       	mov	r17, r24
    1c8c:	ef 01       	movw	r28, r30
    1c8e:	88 23       	and	r24, r24
    1c90:	c9 f0       	breq	.+50     	; 0x1cc4 <vfscanf+0x60>
    1c92:	90 e0       	ldi	r25, 0x00	; 0
    1c94:	09 d1       	rcall	.+530    	; 0x1ea8 <isspace>
    1c96:	89 2b       	or	r24, r25
    1c98:	19 f0       	breq	.+6      	; 0x1ca0 <vfscanf+0x3c>
    1c9a:	c6 01       	movw	r24, r12
    1c9c:	48 df       	rcall	.-368    	; 0x1b2e <skip_spaces>
    1c9e:	ee cf       	rjmp	.-36     	; 0x1c7c <vfscanf+0x18>
    1ca0:	15 32       	cpi	r17, 0x25	; 37
    1ca2:	41 f4       	brne	.+16     	; 0x1cb4 <vfscanf+0x50>
    1ca4:	fe 01       	movw	r30, r28
    1ca6:	f3 fc       	sbrc	r15, 3
    1ca8:	15 91       	lpm	r17, Z+
    1caa:	f3 fe       	sbrs	r15, 3
    1cac:	11 91       	ld	r17, Z+
    1cae:	ef 01       	movw	r28, r30
    1cb0:	15 32       	cpi	r17, 0x25	; 37
    1cb2:	59 f4       	brne	.+22     	; 0x1cca <vfscanf+0x66>
    1cb4:	c6 01       	movw	r24, r12
    1cb6:	14 d1       	rcall	.+552    	; 0x1ee0 <fgetc>
    1cb8:	97 fd       	sbrc	r25, 7
    1cba:	98 c0       	rjmp	.+304    	; 0x1dec <vfscanf+0x188>
    1cbc:	18 17       	cp	r17, r24
    1cbe:	f1 f2       	breq	.-68     	; 0x1c7c <vfscanf+0x18>
    1cc0:	b6 01       	movw	r22, r12
    1cc2:	a7 d1       	rcall	.+846    	; 0x2012 <ungetc>
    1cc4:	85 2d       	mov	r24, r5
    1cc6:	90 e0       	ldi	r25, 0x00	; 0
    1cc8:	95 c0       	rjmp	.+298    	; 0x1df4 <vfscanf+0x190>
    1cca:	00 e0       	ldi	r16, 0x00	; 0
    1ccc:	1a 32       	cpi	r17, 0x2A	; 42
    1cce:	31 f4       	brne	.+12     	; 0x1cdc <vfscanf+0x78>
    1cd0:	f3 fc       	sbrc	r15, 3
    1cd2:	15 91       	lpm	r17, Z+
    1cd4:	f3 fe       	sbrs	r15, 3
    1cd6:	11 91       	ld	r17, Z+
    1cd8:	ef 01       	movw	r28, r30
    1cda:	01 e0       	ldi	r16, 0x01	; 1
    1cdc:	e1 2c       	mov	r14, r1
    1cde:	20 ed       	ldi	r18, 0xD0	; 208
    1ce0:	21 0f       	add	r18, r17
    1ce2:	2a 30       	cpi	r18, 0x0A	; 10
    1ce4:	38 f1       	brcs	.+78     	; 0x1d34 <vfscanf+0xd0>
    1ce6:	01 ff       	sbrs	r16, 1
    1ce8:	34 c0       	rjmp	.+104    	; 0x1d52 <vfscanf+0xee>
    1cea:	ee 20       	and	r14, r14
    1cec:	59 f3       	breq	.-42     	; 0x1cc4 <vfscanf+0x60>
    1cee:	18 36       	cpi	r17, 0x68	; 104
    1cf0:	99 f1       	breq	.+102    	; 0x1d58 <vfscanf+0xf4>
    1cf2:	1c 36       	cpi	r17, 0x6C	; 108
    1cf4:	09 f4       	brne	.+2      	; 0x1cf8 <vfscanf+0x94>
    1cf6:	3a c0       	rjmp	.+116    	; 0x1d6c <vfscanf+0x108>
    1cf8:	11 23       	and	r17, r17
    1cfa:	21 f3       	breq	.-56     	; 0x1cc4 <vfscanf+0x60>
    1cfc:	61 2f       	mov	r22, r17
    1cfe:	70 e0       	ldi	r23, 0x00	; 0
    1d00:	8f e7       	ldi	r24, 0x7F	; 127
    1d02:	90 e0       	ldi	r25, 0x00	; 0
    1d04:	d9 d0       	rcall	.+434    	; 0x1eb8 <strchr_P>
    1d06:	89 2b       	or	r24, r25
    1d08:	e9 f2       	breq	.-70     	; 0x1cc4 <vfscanf+0x60>
    1d0a:	91 2c       	mov	r9, r1
    1d0c:	81 2c       	mov	r8, r1
    1d0e:	00 fd       	sbrc	r16, 0
    1d10:	06 c0       	rjmp	.+12     	; 0x1d1e <vfscanf+0xba>
    1d12:	f5 01       	movw	r30, r10
    1d14:	80 80       	ld	r8, Z
    1d16:	91 80       	ldd	r9, Z+1	; 0x01
    1d18:	c5 01       	movw	r24, r10
    1d1a:	02 96       	adiw	r24, 0x02	; 2
    1d1c:	5c 01       	movw	r10, r24
    1d1e:	1e 36       	cpi	r17, 0x6E	; 110
    1d20:	69 f5       	brne	.+90     	; 0x1d7c <vfscanf+0x118>
    1d22:	f6 01       	movw	r30, r12
    1d24:	46 81       	ldd	r20, Z+6	; 0x06
    1d26:	57 81       	ldd	r21, Z+7	; 0x07
    1d28:	70 e0       	ldi	r23, 0x00	; 0
    1d2a:	60 e0       	ldi	r22, 0x00	; 0
    1d2c:	20 2f       	mov	r18, r16
    1d2e:	c4 01       	movw	r24, r8
    1d30:	cf de       	rcall	.-610    	; 0x1ad0 <putval>
    1d32:	a4 cf       	rjmp	.-184    	; 0x1c7c <vfscanf+0x18>
    1d34:	02 60       	ori	r16, 0x02	; 2
    1d36:	6e 2d       	mov	r22, r14
    1d38:	70 e0       	ldi	r23, 0x00	; 0
    1d3a:	90 e0       	ldi	r25, 0x00	; 0
    1d3c:	80 e0       	ldi	r24, 0x00	; 0
    1d3e:	40 e2       	ldi	r20, 0x20	; 32
    1d40:	d3 de       	rcall	.-602    	; 0x1ae8 <mulacc>
    1d42:	e6 2e       	mov	r14, r22
    1d44:	fe 01       	movw	r30, r28
    1d46:	f3 fc       	sbrc	r15, 3
    1d48:	15 91       	lpm	r17, Z+
    1d4a:	f3 fe       	sbrs	r15, 3
    1d4c:	11 91       	ld	r17, Z+
    1d4e:	ef 01       	movw	r28, r30
    1d50:	c6 cf       	rjmp	.-116    	; 0x1cde <vfscanf+0x7a>
    1d52:	ee 24       	eor	r14, r14
    1d54:	ea 94       	dec	r14
    1d56:	cb cf       	rjmp	.-106    	; 0x1cee <vfscanf+0x8a>
    1d58:	fe 01       	movw	r30, r28
    1d5a:	f3 fc       	sbrc	r15, 3
    1d5c:	15 91       	lpm	r17, Z+
    1d5e:	f3 fe       	sbrs	r15, 3
    1d60:	11 91       	ld	r17, Z+
    1d62:	ef 01       	movw	r28, r30
    1d64:	18 36       	cpi	r17, 0x68	; 104
    1d66:	09 f0       	breq	.+2      	; 0x1d6a <vfscanf+0x106>
    1d68:	c7 cf       	rjmp	.-114    	; 0x1cf8 <vfscanf+0x94>
    1d6a:	08 60       	ori	r16, 0x08	; 8
    1d6c:	04 60       	ori	r16, 0x04	; 4
    1d6e:	fe 01       	movw	r30, r28
    1d70:	f3 fc       	sbrc	r15, 3
    1d72:	15 91       	lpm	r17, Z+
    1d74:	f3 fe       	sbrs	r15, 3
    1d76:	11 91       	ld	r17, Z+
    1d78:	ef 01       	movw	r28, r30
    1d7a:	be cf       	rjmp	.-132    	; 0x1cf8 <vfscanf+0x94>
    1d7c:	13 36       	cpi	r17, 0x63	; 99
    1d7e:	b9 f4       	brne	.+46     	; 0x1dae <vfscanf+0x14a>
    1d80:	01 fd       	sbrc	r16, 1
    1d82:	02 c0       	rjmp	.+4      	; 0x1d88 <vfscanf+0x124>
    1d84:	ee 24       	eor	r14, r14
    1d86:	e3 94       	inc	r14
    1d88:	c6 01       	movw	r24, r12
    1d8a:	aa d0       	rcall	.+340    	; 0x1ee0 <fgetc>
    1d8c:	97 fd       	sbrc	r25, 7
    1d8e:	2e c0       	rjmp	.+92     	; 0x1dec <vfscanf+0x188>
    1d90:	81 14       	cp	r8, r1
    1d92:	91 04       	cpc	r9, r1
    1d94:	29 f0       	breq	.+10     	; 0x1da0 <vfscanf+0x13c>
    1d96:	f4 01       	movw	r30, r8
    1d98:	80 83       	st	Z, r24
    1d9a:	c4 01       	movw	r24, r8
    1d9c:	01 96       	adiw	r24, 0x01	; 1
    1d9e:	4c 01       	movw	r8, r24
    1da0:	ea 94       	dec	r14
    1da2:	e1 10       	cpse	r14, r1
    1da4:	f1 cf       	rjmp	.-30     	; 0x1d88 <vfscanf+0x124>
    1da6:	00 fd       	sbrc	r16, 0
    1da8:	69 cf       	rjmp	.-302    	; 0x1c7c <vfscanf+0x18>
    1daa:	53 94       	inc	r5
    1dac:	67 cf       	rjmp	.-306    	; 0x1c7c <vfscanf+0x18>
    1dae:	c6 01       	movw	r24, r12
    1db0:	be de       	rcall	.-644    	; 0x1b2e <skip_spaces>
    1db2:	97 fd       	sbrc	r25, 7
    1db4:	1b c0       	rjmp	.+54     	; 0x1dec <vfscanf+0x188>
    1db6:	1f 36       	cpi	r17, 0x6F	; 111
    1db8:	09 f4       	brne	.+2      	; 0x1dbc <vfscanf+0x158>
    1dba:	3d c0       	rjmp	.+122    	; 0x1e36 <vfscanf+0x1d2>
    1dbc:	30 f4       	brcc	.+12     	; 0x1dca <vfscanf+0x166>
    1dbe:	14 36       	cpi	r17, 0x64	; 100
    1dc0:	41 f0       	breq	.+16     	; 0x1dd2 <vfscanf+0x16e>
    1dc2:	19 36       	cpi	r17, 0x69	; 105
    1dc4:	39 f0       	breq	.+14     	; 0x1dd4 <vfscanf+0x170>
    1dc6:	00 64       	ori	r16, 0x40	; 64
    1dc8:	05 c0       	rjmp	.+10     	; 0x1dd4 <vfscanf+0x170>
    1dca:	13 37       	cpi	r17, 0x73	; 115
    1dcc:	11 f1       	breq	.+68     	; 0x1e12 <vfscanf+0x1ae>
    1dce:	15 37       	cpi	r17, 0x75	; 117
    1dd0:	d1 f7       	brne	.-12     	; 0x1dc6 <vfscanf+0x162>
    1dd2:	00 62       	ori	r16, 0x20	; 32
    1dd4:	20 2f       	mov	r18, r16
    1dd6:	a4 01       	movw	r20, r8
    1dd8:	6e 2d       	mov	r22, r14
    1dda:	c6 01       	movw	r24, r12
    1ddc:	be de       	rcall	.-644    	; 0x1b5a <conv_int>
    1dde:	81 11       	cpse	r24, r1
    1de0:	e2 cf       	rjmp	.-60     	; 0x1da6 <vfscanf+0x142>
    1de2:	f6 01       	movw	r30, r12
    1de4:	83 81       	ldd	r24, Z+3	; 0x03
    1de6:	80 73       	andi	r24, 0x30	; 48
    1de8:	09 f4       	brne	.+2      	; 0x1dec <vfscanf+0x188>
    1dea:	6c cf       	rjmp	.-296    	; 0x1cc4 <vfscanf+0x60>
    1dec:	8f ef       	ldi	r24, 0xFF	; 255
    1dee:	9f ef       	ldi	r25, 0xFF	; 255
    1df0:	51 10       	cpse	r5, r1
    1df2:	68 cf       	rjmp	.-304    	; 0x1cc4 <vfscanf+0x60>
    1df4:	cd b7       	in	r28, 0x3d	; 61
    1df6:	de b7       	in	r29, 0x3e	; 62
    1df8:	ef e0       	ldi	r30, 0x0F	; 15
    1dfa:	3e c0       	rjmp	.+124    	; 0x1e78 <__epilogue_restores__+0x6>
    1dfc:	81 14       	cp	r8, r1
    1dfe:	91 04       	cpc	r9, r1
    1e00:	29 f0       	breq	.+10     	; 0x1e0c <vfscanf+0x1a8>
    1e02:	f4 01       	movw	r30, r8
    1e04:	60 82       	st	Z, r6
    1e06:	c4 01       	movw	r24, r8
    1e08:	01 96       	adiw	r24, 0x01	; 1
    1e0a:	4c 01       	movw	r8, r24
    1e0c:	ea 94       	dec	r14
    1e0e:	ee 20       	and	r14, r14
    1e10:	59 f0       	breq	.+22     	; 0x1e28 <vfscanf+0x1c4>
    1e12:	c6 01       	movw	r24, r12
    1e14:	65 d0       	rcall	.+202    	; 0x1ee0 <fgetc>
    1e16:	3c 01       	movw	r6, r24
    1e18:	97 fd       	sbrc	r25, 7
    1e1a:	06 c0       	rjmp	.+12     	; 0x1e28 <vfscanf+0x1c4>
    1e1c:	45 d0       	rcall	.+138    	; 0x1ea8 <isspace>
    1e1e:	89 2b       	or	r24, r25
    1e20:	69 f3       	breq	.-38     	; 0x1dfc <vfscanf+0x198>
    1e22:	b6 01       	movw	r22, r12
    1e24:	c3 01       	movw	r24, r6
    1e26:	f5 d0       	rcall	.+490    	; 0x2012 <ungetc>
    1e28:	81 14       	cp	r8, r1
    1e2a:	91 04       	cpc	r9, r1
    1e2c:	09 f4       	brne	.+2      	; 0x1e30 <vfscanf+0x1cc>
    1e2e:	bb cf       	rjmp	.-138    	; 0x1da6 <vfscanf+0x142>
    1e30:	f4 01       	movw	r30, r8
    1e32:	10 82       	st	Z, r1
    1e34:	b8 cf       	rjmp	.-144    	; 0x1da6 <vfscanf+0x142>
    1e36:	00 61       	ori	r16, 0x10	; 16
    1e38:	cd cf       	rjmp	.-102    	; 0x1dd4 <vfscanf+0x170>

00001e3a <__prologue_saves__>:
    1e3a:	2f 92       	push	r2
    1e3c:	3f 92       	push	r3
    1e3e:	4f 92       	push	r4
    1e40:	5f 92       	push	r5
    1e42:	6f 92       	push	r6
    1e44:	7f 92       	push	r7
    1e46:	8f 92       	push	r8
    1e48:	9f 92       	push	r9
    1e4a:	af 92       	push	r10
    1e4c:	bf 92       	push	r11
    1e4e:	cf 92       	push	r12
    1e50:	df 92       	push	r13
    1e52:	ef 92       	push	r14
    1e54:	ff 92       	push	r15
    1e56:	0f 93       	push	r16
    1e58:	1f 93       	push	r17
    1e5a:	cf 93       	push	r28
    1e5c:	df 93       	push	r29
    1e5e:	cd b7       	in	r28, 0x3d	; 61
    1e60:	de b7       	in	r29, 0x3e	; 62
    1e62:	ca 1b       	sub	r28, r26
    1e64:	db 0b       	sbc	r29, r27
    1e66:	0f b6       	in	r0, 0x3f	; 63
    1e68:	f8 94       	cli
    1e6a:	de bf       	out	0x3e, r29	; 62
    1e6c:	0f be       	out	0x3f, r0	; 63
    1e6e:	cd bf       	out	0x3d, r28	; 61
    1e70:	09 94       	ijmp

00001e72 <__epilogue_restores__>:
    1e72:	2a 88       	ldd	r2, Y+18	; 0x12
    1e74:	39 88       	ldd	r3, Y+17	; 0x11
    1e76:	48 88       	ldd	r4, Y+16	; 0x10
    1e78:	5f 84       	ldd	r5, Y+15	; 0x0f
    1e7a:	6e 84       	ldd	r6, Y+14	; 0x0e
    1e7c:	7d 84       	ldd	r7, Y+13	; 0x0d
    1e7e:	8c 84       	ldd	r8, Y+12	; 0x0c
    1e80:	9b 84       	ldd	r9, Y+11	; 0x0b
    1e82:	aa 84       	ldd	r10, Y+10	; 0x0a
    1e84:	b9 84       	ldd	r11, Y+9	; 0x09
    1e86:	c8 84       	ldd	r12, Y+8	; 0x08
    1e88:	df 80       	ldd	r13, Y+7	; 0x07
    1e8a:	ee 80       	ldd	r14, Y+6	; 0x06
    1e8c:	fd 80       	ldd	r15, Y+5	; 0x05
    1e8e:	0c 81       	ldd	r16, Y+4	; 0x04
    1e90:	1b 81       	ldd	r17, Y+3	; 0x03
    1e92:	aa 81       	ldd	r26, Y+2	; 0x02
    1e94:	b9 81       	ldd	r27, Y+1	; 0x01
    1e96:	ce 0f       	add	r28, r30
    1e98:	d1 1d       	adc	r29, r1
    1e9a:	0f b6       	in	r0, 0x3f	; 63
    1e9c:	f8 94       	cli
    1e9e:	de bf       	out	0x3e, r29	; 62
    1ea0:	0f be       	out	0x3f, r0	; 63
    1ea2:	cd bf       	out	0x3d, r28	; 61
    1ea4:	ed 01       	movw	r28, r26
    1ea6:	08 95       	ret

00001ea8 <isspace>:
    1ea8:	91 11       	cpse	r25, r1
    1eaa:	29 c1       	rjmp	.+594    	; 0x20fe <__ctype_isfalse>
    1eac:	80 32       	cpi	r24, 0x20	; 32
    1eae:	19 f0       	breq	.+6      	; 0x1eb6 <isspace+0xe>
    1eb0:	89 50       	subi	r24, 0x09	; 9
    1eb2:	85 50       	subi	r24, 0x05	; 5
    1eb4:	d0 f7       	brcc	.-12     	; 0x1eaa <isspace+0x2>
    1eb6:	08 95       	ret

00001eb8 <strchr_P>:
    1eb8:	fc 01       	movw	r30, r24
    1eba:	05 90       	lpm	r0, Z+
    1ebc:	06 16       	cp	r0, r22
    1ebe:	21 f0       	breq	.+8      	; 0x1ec8 <strchr_P+0x10>
    1ec0:	00 20       	and	r0, r0
    1ec2:	d9 f7       	brne	.-10     	; 0x1eba <strchr_P+0x2>
    1ec4:	c0 01       	movw	r24, r0
    1ec6:	08 95       	ret
    1ec8:	31 97       	sbiw	r30, 0x01	; 1
    1eca:	cf 01       	movw	r24, r30
    1ecc:	08 95       	ret

00001ece <memcpy>:
    1ece:	fb 01       	movw	r30, r22
    1ed0:	dc 01       	movw	r26, r24
    1ed2:	02 c0       	rjmp	.+4      	; 0x1ed8 <memcpy+0xa>
    1ed4:	01 90       	ld	r0, Z+
    1ed6:	0d 92       	st	X+, r0
    1ed8:	41 50       	subi	r20, 0x01	; 1
    1eda:	50 40       	sbci	r21, 0x00	; 0
    1edc:	d8 f7       	brcc	.-10     	; 0x1ed4 <memcpy+0x6>
    1ede:	08 95       	ret

00001ee0 <fgetc>:
    1ee0:	cf 93       	push	r28
    1ee2:	df 93       	push	r29
    1ee4:	ec 01       	movw	r28, r24
    1ee6:	2b 81       	ldd	r18, Y+3	; 0x03
    1ee8:	20 ff       	sbrs	r18, 0
    1eea:	1a c0       	rjmp	.+52     	; 0x1f20 <fgetc+0x40>
    1eec:	26 ff       	sbrs	r18, 6
    1eee:	0c c0       	rjmp	.+24     	; 0x1f08 <fgetc+0x28>
    1ef0:	2f 7b       	andi	r18, 0xBF	; 191
    1ef2:	2b 83       	std	Y+3, r18	; 0x03
    1ef4:	8e 81       	ldd	r24, Y+6	; 0x06
    1ef6:	9f 81       	ldd	r25, Y+7	; 0x07
    1ef8:	01 96       	adiw	r24, 0x01	; 1
    1efa:	9f 83       	std	Y+7, r25	; 0x07
    1efc:	8e 83       	std	Y+6, r24	; 0x06
    1efe:	8a 81       	ldd	r24, Y+2	; 0x02
    1f00:	90 e0       	ldi	r25, 0x00	; 0
    1f02:	df 91       	pop	r29
    1f04:	cf 91       	pop	r28
    1f06:	08 95       	ret
    1f08:	22 ff       	sbrs	r18, 2
    1f0a:	18 c0       	rjmp	.+48     	; 0x1f3c <fgetc+0x5c>
    1f0c:	e8 81       	ld	r30, Y
    1f0e:	f9 81       	ldd	r31, Y+1	; 0x01
    1f10:	80 81       	ld	r24, Z
    1f12:	08 2e       	mov	r0, r24
    1f14:	00 0c       	add	r0, r0
    1f16:	99 0b       	sbc	r25, r25
    1f18:	00 97       	sbiw	r24, 0x00	; 0
    1f1a:	29 f4       	brne	.+10     	; 0x1f26 <fgetc+0x46>
    1f1c:	20 62       	ori	r18, 0x20	; 32
    1f1e:	2b 83       	std	Y+3, r18	; 0x03
    1f20:	8f ef       	ldi	r24, 0xFF	; 255
    1f22:	9f ef       	ldi	r25, 0xFF	; 255
    1f24:	ee cf       	rjmp	.-36     	; 0x1f02 <fgetc+0x22>
    1f26:	31 96       	adiw	r30, 0x01	; 1
    1f28:	f9 83       	std	Y+1, r31	; 0x01
    1f2a:	e8 83       	st	Y, r30
    1f2c:	2e 81       	ldd	r18, Y+6	; 0x06
    1f2e:	3f 81       	ldd	r19, Y+7	; 0x07
    1f30:	2f 5f       	subi	r18, 0xFF	; 255
    1f32:	3f 4f       	sbci	r19, 0xFF	; 255
    1f34:	3f 83       	std	Y+7, r19	; 0x07
    1f36:	2e 83       	std	Y+6, r18	; 0x06
    1f38:	99 27       	eor	r25, r25
    1f3a:	e3 cf       	rjmp	.-58     	; 0x1f02 <fgetc+0x22>
    1f3c:	ea 85       	ldd	r30, Y+10	; 0x0a
    1f3e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1f40:	09 95       	icall
    1f42:	97 ff       	sbrs	r25, 7
    1f44:	f3 cf       	rjmp	.-26     	; 0x1f2c <fgetc+0x4c>
    1f46:	2b 81       	ldd	r18, Y+3	; 0x03
    1f48:	01 96       	adiw	r24, 0x01	; 1
    1f4a:	21 f0       	breq	.+8      	; 0x1f54 <fgetc+0x74>
    1f4c:	80 e2       	ldi	r24, 0x20	; 32
    1f4e:	82 2b       	or	r24, r18
    1f50:	8b 83       	std	Y+3, r24	; 0x03
    1f52:	e6 cf       	rjmp	.-52     	; 0x1f20 <fgetc+0x40>
    1f54:	80 e1       	ldi	r24, 0x10	; 16
    1f56:	fb cf       	rjmp	.-10     	; 0x1f4e <fgetc+0x6e>

00001f58 <fputc>:
    1f58:	0f 93       	push	r16
    1f5a:	1f 93       	push	r17
    1f5c:	cf 93       	push	r28
    1f5e:	df 93       	push	r29
    1f60:	18 2f       	mov	r17, r24
    1f62:	09 2f       	mov	r16, r25
    1f64:	eb 01       	movw	r28, r22
    1f66:	8b 81       	ldd	r24, Y+3	; 0x03
    1f68:	81 fd       	sbrc	r24, 1
    1f6a:	09 c0       	rjmp	.+18     	; 0x1f7e <fputc+0x26>
    1f6c:	1f ef       	ldi	r17, 0xFF	; 255
    1f6e:	0f ef       	ldi	r16, 0xFF	; 255
    1f70:	81 2f       	mov	r24, r17
    1f72:	90 2f       	mov	r25, r16
    1f74:	df 91       	pop	r29
    1f76:	cf 91       	pop	r28
    1f78:	1f 91       	pop	r17
    1f7a:	0f 91       	pop	r16
    1f7c:	08 95       	ret
    1f7e:	82 ff       	sbrs	r24, 2
    1f80:	14 c0       	rjmp	.+40     	; 0x1faa <fputc+0x52>
    1f82:	2e 81       	ldd	r18, Y+6	; 0x06
    1f84:	3f 81       	ldd	r19, Y+7	; 0x07
    1f86:	8c 81       	ldd	r24, Y+4	; 0x04
    1f88:	9d 81       	ldd	r25, Y+5	; 0x05
    1f8a:	28 17       	cp	r18, r24
    1f8c:	39 07       	cpc	r19, r25
    1f8e:	3c f4       	brge	.+14     	; 0x1f9e <fputc+0x46>
    1f90:	e8 81       	ld	r30, Y
    1f92:	f9 81       	ldd	r31, Y+1	; 0x01
    1f94:	cf 01       	movw	r24, r30
    1f96:	01 96       	adiw	r24, 0x01	; 1
    1f98:	99 83       	std	Y+1, r25	; 0x01
    1f9a:	88 83       	st	Y, r24
    1f9c:	10 83       	st	Z, r17
    1f9e:	8e 81       	ldd	r24, Y+6	; 0x06
    1fa0:	9f 81       	ldd	r25, Y+7	; 0x07
    1fa2:	01 96       	adiw	r24, 0x01	; 1
    1fa4:	9f 83       	std	Y+7, r25	; 0x07
    1fa6:	8e 83       	std	Y+6, r24	; 0x06
    1fa8:	e3 cf       	rjmp	.-58     	; 0x1f70 <fputc+0x18>
    1faa:	e8 85       	ldd	r30, Y+8	; 0x08
    1fac:	f9 85       	ldd	r31, Y+9	; 0x09
    1fae:	81 2f       	mov	r24, r17
    1fb0:	09 95       	icall
    1fb2:	89 2b       	or	r24, r25
    1fb4:	a1 f3       	breq	.-24     	; 0x1f9e <fputc+0x46>
    1fb6:	da cf       	rjmp	.-76     	; 0x1f6c <fputc+0x14>

00001fb8 <snprintf>:
    1fb8:	ae e0       	ldi	r26, 0x0E	; 14
    1fba:	b0 e0       	ldi	r27, 0x00	; 0
    1fbc:	e1 ee       	ldi	r30, 0xE1	; 225
    1fbe:	ff e0       	ldi	r31, 0x0F	; 15
    1fc0:	4a cf       	rjmp	.-364    	; 0x1e56 <__prologue_saves__+0x1c>
    1fc2:	0d 89       	ldd	r16, Y+21	; 0x15
    1fc4:	1e 89       	ldd	r17, Y+22	; 0x16
    1fc6:	8f 89       	ldd	r24, Y+23	; 0x17
    1fc8:	98 8d       	ldd	r25, Y+24	; 0x18
    1fca:	26 e0       	ldi	r18, 0x06	; 6
    1fcc:	2c 83       	std	Y+4, r18	; 0x04
    1fce:	1a 83       	std	Y+2, r17	; 0x02
    1fd0:	09 83       	std	Y+1, r16	; 0x01
    1fd2:	97 ff       	sbrs	r25, 7
    1fd4:	02 c0       	rjmp	.+4      	; 0x1fda <snprintf+0x22>
    1fd6:	80 e0       	ldi	r24, 0x00	; 0
    1fd8:	90 e8       	ldi	r25, 0x80	; 128
    1fda:	01 97       	sbiw	r24, 0x01	; 1
    1fdc:	9e 83       	std	Y+6, r25	; 0x06
    1fde:	8d 83       	std	Y+5, r24	; 0x05
    1fe0:	ae 01       	movw	r20, r28
    1fe2:	45 5e       	subi	r20, 0xE5	; 229
    1fe4:	5f 4f       	sbci	r21, 0xFF	; 255
    1fe6:	69 8d       	ldd	r22, Y+25	; 0x19
    1fe8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1fea:	ce 01       	movw	r24, r28
    1fec:	01 96       	adiw	r24, 0x01	; 1
    1fee:	60 dc       	rcall	.-1856   	; 0x18b0 <vfprintf>
    1ff0:	4d 81       	ldd	r20, Y+5	; 0x05
    1ff2:	5e 81       	ldd	r21, Y+6	; 0x06
    1ff4:	57 fd       	sbrc	r21, 7
    1ff6:	0a c0       	rjmp	.+20     	; 0x200c <snprintf+0x54>
    1ff8:	2f 81       	ldd	r18, Y+7	; 0x07
    1ffa:	38 85       	ldd	r19, Y+8	; 0x08
    1ffc:	42 17       	cp	r20, r18
    1ffe:	53 07       	cpc	r21, r19
    2000:	0c f4       	brge	.+2      	; 0x2004 <snprintf+0x4c>
    2002:	9a 01       	movw	r18, r20
    2004:	02 0f       	add	r16, r18
    2006:	13 1f       	adc	r17, r19
    2008:	f8 01       	movw	r30, r16
    200a:	10 82       	st	Z, r1
    200c:	2e 96       	adiw	r28, 0x0e	; 14
    200e:	e4 e0       	ldi	r30, 0x04	; 4
    2010:	3e cf       	rjmp	.-388    	; 0x1e8e <__epilogue_restores__+0x1c>

00002012 <ungetc>:
    2012:	fb 01       	movw	r30, r22
    2014:	23 81       	ldd	r18, Z+3	; 0x03
    2016:	20 ff       	sbrs	r18, 0
    2018:	11 c0       	rjmp	.+34     	; 0x203c <ungetc+0x2a>
    201a:	26 fd       	sbrc	r18, 6
    201c:	0f c0       	rjmp	.+30     	; 0x203c <ungetc+0x2a>
    201e:	8f 3f       	cpi	r24, 0xFF	; 255
    2020:	98 07       	cpc	r25, r24
    2022:	71 f0       	breq	.+28     	; 0x2040 <ungetc+0x2e>
    2024:	82 83       	std	Z+2, r24	; 0x02
    2026:	2f 7d       	andi	r18, 0xDF	; 223
    2028:	20 64       	ori	r18, 0x40	; 64
    202a:	23 83       	std	Z+3, r18	; 0x03
    202c:	26 81       	ldd	r18, Z+6	; 0x06
    202e:	37 81       	ldd	r19, Z+7	; 0x07
    2030:	21 50       	subi	r18, 0x01	; 1
    2032:	31 09       	sbc	r19, r1
    2034:	37 83       	std	Z+7, r19	; 0x07
    2036:	26 83       	std	Z+6, r18	; 0x06
    2038:	99 27       	eor	r25, r25
    203a:	08 95       	ret
    203c:	8f ef       	ldi	r24, 0xFF	; 255
    203e:	9f ef       	ldi	r25, 0xFF	; 255
    2040:	08 95       	ret

00002042 <__ultoa_invert>:
    2042:	fa 01       	movw	r30, r20
    2044:	aa 27       	eor	r26, r26
    2046:	28 30       	cpi	r18, 0x08	; 8
    2048:	51 f1       	breq	.+84     	; 0x209e <__ultoa_invert+0x5c>
    204a:	20 31       	cpi	r18, 0x10	; 16
    204c:	81 f1       	breq	.+96     	; 0x20ae <__ultoa_invert+0x6c>
    204e:	e8 94       	clt
    2050:	6f 93       	push	r22
    2052:	6e 7f       	andi	r22, 0xFE	; 254
    2054:	6e 5f       	subi	r22, 0xFE	; 254
    2056:	7f 4f       	sbci	r23, 0xFF	; 255
    2058:	8f 4f       	sbci	r24, 0xFF	; 255
    205a:	9f 4f       	sbci	r25, 0xFF	; 255
    205c:	af 4f       	sbci	r26, 0xFF	; 255
    205e:	b1 e0       	ldi	r27, 0x01	; 1
    2060:	3e d0       	rcall	.+124    	; 0x20de <__ultoa_invert+0x9c>
    2062:	b4 e0       	ldi	r27, 0x04	; 4
    2064:	3c d0       	rcall	.+120    	; 0x20de <__ultoa_invert+0x9c>
    2066:	67 0f       	add	r22, r23
    2068:	78 1f       	adc	r23, r24
    206a:	89 1f       	adc	r24, r25
    206c:	9a 1f       	adc	r25, r26
    206e:	a1 1d       	adc	r26, r1
    2070:	68 0f       	add	r22, r24
    2072:	79 1f       	adc	r23, r25
    2074:	8a 1f       	adc	r24, r26
    2076:	91 1d       	adc	r25, r1
    2078:	a1 1d       	adc	r26, r1
    207a:	6a 0f       	add	r22, r26
    207c:	71 1d       	adc	r23, r1
    207e:	81 1d       	adc	r24, r1
    2080:	91 1d       	adc	r25, r1
    2082:	a1 1d       	adc	r26, r1
    2084:	20 d0       	rcall	.+64     	; 0x20c6 <__ultoa_invert+0x84>
    2086:	09 f4       	brne	.+2      	; 0x208a <__ultoa_invert+0x48>
    2088:	68 94       	set
    208a:	3f 91       	pop	r19
    208c:	2a e0       	ldi	r18, 0x0A	; 10
    208e:	26 9f       	mul	r18, r22
    2090:	11 24       	eor	r1, r1
    2092:	30 19       	sub	r19, r0
    2094:	30 5d       	subi	r19, 0xD0	; 208
    2096:	31 93       	st	Z+, r19
    2098:	de f6       	brtc	.-74     	; 0x2050 <__ultoa_invert+0xe>
    209a:	cf 01       	movw	r24, r30
    209c:	08 95       	ret
    209e:	46 2f       	mov	r20, r22
    20a0:	47 70       	andi	r20, 0x07	; 7
    20a2:	40 5d       	subi	r20, 0xD0	; 208
    20a4:	41 93       	st	Z+, r20
    20a6:	b3 e0       	ldi	r27, 0x03	; 3
    20a8:	0f d0       	rcall	.+30     	; 0x20c8 <__ultoa_invert+0x86>
    20aa:	c9 f7       	brne	.-14     	; 0x209e <__ultoa_invert+0x5c>
    20ac:	f6 cf       	rjmp	.-20     	; 0x209a <__ultoa_invert+0x58>
    20ae:	46 2f       	mov	r20, r22
    20b0:	4f 70       	andi	r20, 0x0F	; 15
    20b2:	40 5d       	subi	r20, 0xD0	; 208
    20b4:	4a 33       	cpi	r20, 0x3A	; 58
    20b6:	18 f0       	brcs	.+6      	; 0x20be <__ultoa_invert+0x7c>
    20b8:	49 5d       	subi	r20, 0xD9	; 217
    20ba:	31 fd       	sbrc	r19, 1
    20bc:	40 52       	subi	r20, 0x20	; 32
    20be:	41 93       	st	Z+, r20
    20c0:	02 d0       	rcall	.+4      	; 0x20c6 <__ultoa_invert+0x84>
    20c2:	a9 f7       	brne	.-22     	; 0x20ae <__ultoa_invert+0x6c>
    20c4:	ea cf       	rjmp	.-44     	; 0x209a <__ultoa_invert+0x58>
    20c6:	b4 e0       	ldi	r27, 0x04	; 4
    20c8:	a6 95       	lsr	r26
    20ca:	97 95       	ror	r25
    20cc:	87 95       	ror	r24
    20ce:	77 95       	ror	r23
    20d0:	67 95       	ror	r22
    20d2:	ba 95       	dec	r27
    20d4:	c9 f7       	brne	.-14     	; 0x20c8 <__ultoa_invert+0x86>
    20d6:	00 97       	sbiw	r24, 0x00	; 0
    20d8:	61 05       	cpc	r22, r1
    20da:	71 05       	cpc	r23, r1
    20dc:	08 95       	ret
    20de:	9b 01       	movw	r18, r22
    20e0:	ac 01       	movw	r20, r24
    20e2:	0a 2e       	mov	r0, r26
    20e4:	06 94       	lsr	r0
    20e6:	57 95       	ror	r21
    20e8:	47 95       	ror	r20
    20ea:	37 95       	ror	r19
    20ec:	27 95       	ror	r18
    20ee:	ba 95       	dec	r27
    20f0:	c9 f7       	brne	.-14     	; 0x20e4 <__ultoa_invert+0xa2>
    20f2:	62 0f       	add	r22, r18
    20f4:	73 1f       	adc	r23, r19
    20f6:	84 1f       	adc	r24, r20
    20f8:	95 1f       	adc	r25, r21
    20fa:	a0 1d       	adc	r26, r0
    20fc:	08 95       	ret

000020fe <__ctype_isfalse>:
    20fe:	99 27       	eor	r25, r25
    2100:	88 27       	eor	r24, r24

00002102 <__ctype_istrue>:
    2102:	08 95       	ret

00002104 <_exit>:
    2104:	f8 94       	cli

00002106 <__stop_program>:
    2106:	ff cf       	rjmp	.-2      	; 0x2106 <__stop_program>

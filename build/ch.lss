
build/ch.elf: formato do arquivo elf32-avr

Seções:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000008e  00800100  000022be  00002352  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000022be  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000055e  0080018e  0080018e  000023e0  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  000023e0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000023f4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000760  00000000  00000000  00002434  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001af72  00000000  00000000  00002b94  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004c0f  00000000  00000000  0001db06  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000827c  00000000  00000000  00022715  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000014b4  00000000  00000000  0002a994  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000024b2  00000000  00000000  0002be48  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006c0b  00000000  00000000  0002e2fa  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000a80  00000000  00000000  00034f05  2**0
                  CONTENTS, READONLY, DEBUGGING

Desmontagem da seção .text:

00000000 <__vectors>:
       0:	44 c0       	rjmp	.+136    	; 0x8a <__ctors_end>
       2:	00 00       	nop
       4:	5f c0       	rjmp	.+190    	; 0xc4 <__bad_interrupt>
       6:	00 00       	nop
       8:	5d c0       	rjmp	.+186    	; 0xc4 <__bad_interrupt>
       a:	00 00       	nop
       c:	5b c0       	rjmp	.+182    	; 0xc4 <__bad_interrupt>
       e:	00 00       	nop
      10:	59 c0       	rjmp	.+178    	; 0xc4 <__bad_interrupt>
      12:	00 00       	nop
      14:	57 c0       	rjmp	.+174    	; 0xc4 <__bad_interrupt>
      16:	00 00       	nop
      18:	55 c0       	rjmp	.+170    	; 0xc4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	53 c0       	rjmp	.+166    	; 0xc4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	51 c0       	rjmp	.+162    	; 0xc4 <__bad_interrupt>
      22:	00 00       	nop
      24:	4f c0       	rjmp	.+158    	; 0xc4 <__bad_interrupt>
      26:	00 00       	nop
      28:	4d c0       	rjmp	.+154    	; 0xc4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4b c0       	rjmp	.+150    	; 0xc4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	49 c0       	rjmp	.+146    	; 0xc4 <__bad_interrupt>
      32:	00 00       	nop
      34:	47 c0       	rjmp	.+142    	; 0xc4 <__bad_interrupt>
      36:	00 00       	nop
      38:	6d c3       	rjmp	.+1754   	; 0x714 <__vector_14>
      3a:	00 00       	nop
      3c:	43 c0       	rjmp	.+134    	; 0xc4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	41 c0       	rjmp	.+130    	; 0xc4 <__bad_interrupt>
      42:	00 00       	nop
      44:	3f c0       	rjmp	.+126    	; 0xc4 <__bad_interrupt>
      46:	00 00       	nop
      48:	a0 c3       	rjmp	.+1856   	; 0x78a <__vector_18>
      4a:	00 00       	nop
      4c:	dc c3       	rjmp	.+1976   	; 0x806 <__vector_19>
      4e:	00 00       	nop
      50:	39 c0       	rjmp	.+114    	; 0xc4 <__bad_interrupt>
      52:	00 00       	nop
      54:	37 c0       	rjmp	.+110    	; 0xc4 <__bad_interrupt>
      56:	00 00       	nop
      58:	35 c0       	rjmp	.+106    	; 0xc4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	33 c0       	rjmp	.+102    	; 0xc4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	31 c0       	rjmp	.+98     	; 0xc4 <__bad_interrupt>
      62:	00 00       	nop
      64:	2f c0       	rjmp	.+94     	; 0xc4 <__bad_interrupt>
	...

00000068 <__trampolines_end>:
      68:	45 46       	sbci	r20, 0x65	; 101
      6a:	47 65       	ori	r20, 0x57	; 87
      6c:	66 67       	ori	r22, 0x76	; 118
	...

0000006f <__c.2210>:
      6f:	20 2b 2d 2e 30 31 32 33 34 35 36 37 38 39 68 00      +-.0123456789h.

0000007f <__c.2345>:
      7f:	63 64 69 6e 6f 70 73 75 78 58 00                    cdinopsuxX.

0000008a <__ctors_end>:
      8a:	11 24       	eor	r1, r1
      8c:	1f be       	out	0x3f, r1	; 63
      8e:	cf ef       	ldi	r28, 0xFF	; 255
      90:	d8 e0       	ldi	r29, 0x08	; 8
      92:	de bf       	out	0x3e, r29	; 62
      94:	cd bf       	out	0x3d, r28	; 61

00000096 <__do_copy_data>:
      96:	11 e0       	ldi	r17, 0x01	; 1
      98:	a0 e0       	ldi	r26, 0x00	; 0
      9a:	b1 e0       	ldi	r27, 0x01	; 1
      9c:	ee eb       	ldi	r30, 0xBE	; 190
      9e:	f2 e2       	ldi	r31, 0x22	; 34
      a0:	02 c0       	rjmp	.+4      	; 0xa6 <__do_copy_data+0x10>
      a2:	05 90       	lpm	r0, Z+
      a4:	0d 92       	st	X+, r0
      a6:	ae 38       	cpi	r26, 0x8E	; 142
      a8:	b1 07       	cpc	r27, r17
      aa:	d9 f7       	brne	.-10     	; 0xa2 <__do_copy_data+0xc>

000000ac <__do_clear_bss>:
      ac:	26 e0       	ldi	r18, 0x06	; 6
      ae:	ae e8       	ldi	r26, 0x8E	; 142
      b0:	b1 e0       	ldi	r27, 0x01	; 1
      b2:	01 c0       	rjmp	.+2      	; 0xb6 <.do_clear_bss_start>

000000b4 <.do_clear_bss_loop>:
      b4:	1d 92       	st	X+, r1

000000b6 <.do_clear_bss_start>:
      b6:	ac 3e       	cpi	r26, 0xEC	; 236
      b8:	b2 07       	cpc	r27, r18
      ba:	e1 f7       	brne	.-8      	; 0xb4 <.do_clear_bss_loop>
      bc:	0e 94 01 0c 	call	0x1802	; 0x1802 <main>
      c0:	0c 94 5d 11 	jmp	0x22ba	; 0x22ba <_exit>

000000c4 <__bad_interrupt>:
      c4:	9d cf       	rjmp	.-198    	; 0x0 <__vectors>

000000c6 <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
      c6:	f3 d2       	rcall	.+1510   	; 0x6ae <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
#else
  palInit(&pal_default_config);
      c8:	85 e1       	ldi	r24, 0x15	; 21
      ca:	91 e0       	ldi	r25, 0x01	; 1
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
      cc:	f1 d2       	rcall	.+1506   	; 0x6b0 <_pal_lld_init>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
      ce:	74 d2       	rcall	.+1256   	; 0x5b8 <sdInit>
      d0:	ea d2       	rcall	.+1492   	; 0x6a6 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
      d2:	00 c0       	rjmp	.+0      	; 0xd4 <stInit>

000000d4 <stInit>:

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
      d4:	4a c3       	rjmp	.+1684   	; 0x76a <st_lld_init>

000000d6 <iq_read>:
  if ((wr > (size_t)0) && (nfy != NULL)) {
    nfy(oqp);
  }

  return wr;
}
      d6:	af 92       	push	r10
      d8:	bf 92       	push	r11
      da:	cf 92       	push	r12
      dc:	df 92       	push	r13
      de:	ef 92       	push	r14
      e0:	ff 92       	push	r15
      e2:	0f 93       	push	r16
      e4:	1f 93       	push	r17
      e6:	cf 93       	push	r28
      e8:	df 93       	push	r29
      ea:	ec 01       	movw	r28, r24
      ec:	6b 01       	movw	r12, r22
      ee:	8a 01       	movw	r16, r20
      f0:	8c 81       	ldd	r24, Y+4	; 0x04
      f2:	9d 81       	ldd	r25, Y+5	; 0x05
      f4:	84 17       	cp	r24, r20
      f6:	95 07       	cpc	r25, r21
      f8:	10 f4       	brcc	.+4      	; 0xfe <iq_read+0x28>
      fa:	0c 81       	ldd	r16, Y+4	; 0x04
      fc:	1d 81       	ldd	r17, Y+5	; 0x05
      fe:	6c 85       	ldd	r22, Y+12	; 0x0c
     100:	7d 85       	ldd	r23, Y+13	; 0x0d
     102:	e8 84       	ldd	r14, Y+8	; 0x08
     104:	f9 84       	ldd	r15, Y+9	; 0x09
     106:	e6 1a       	sub	r14, r22
     108:	f7 0a       	sbc	r15, r23
     10a:	0e 15       	cp	r16, r14
     10c:	1f 05       	cpc	r17, r15
     10e:	98 f1       	brcs	.+102    	; 0x176 <iq_read+0xa0>
     110:	e0 16       	cp	r14, r16
     112:	f1 06       	cpc	r15, r17
     114:	d0 f0       	brcs	.+52     	; 0x14a <iq_read+0x74>
     116:	a8 01       	movw	r20, r16
     118:	c6 01       	movw	r24, r12
     11a:	0e 94 6f 10 	call	0x20de	; 0x20de <memcpy>
     11e:	8e 81       	ldd	r24, Y+6	; 0x06
     120:	9f 81       	ldd	r25, Y+7	; 0x07
     122:	9d 87       	std	Y+13, r25	; 0x0d
     124:	8c 87       	std	Y+12, r24	; 0x0c
     126:	8c 81       	ldd	r24, Y+4	; 0x04
     128:	9d 81       	ldd	r25, Y+5	; 0x05
     12a:	80 1b       	sub	r24, r16
     12c:	91 0b       	sbc	r25, r17
     12e:	9d 83       	std	Y+5, r25	; 0x05
     130:	8c 83       	std	Y+4, r24	; 0x04
     132:	c8 01       	movw	r24, r16
     134:	df 91       	pop	r29
     136:	cf 91       	pop	r28
     138:	1f 91       	pop	r17
     13a:	0f 91       	pop	r16
     13c:	ff 90       	pop	r15
     13e:	ef 90       	pop	r14
     140:	df 90       	pop	r13
     142:	cf 90       	pop	r12
     144:	bf 90       	pop	r11
     146:	af 90       	pop	r10
     148:	08 95       	ret
     14a:	a7 01       	movw	r20, r14
     14c:	c6 01       	movw	r24, r12
     14e:	0e 94 6f 10 	call	0x20de	; 0x20de <memcpy>
     152:	58 01       	movw	r10, r16
     154:	ae 18       	sub	r10, r14
     156:	bf 08       	sbc	r11, r15
     158:	6e 81       	ldd	r22, Y+6	; 0x06
     15a:	7f 81       	ldd	r23, Y+7	; 0x07
     15c:	a5 01       	movw	r20, r10
     15e:	c6 01       	movw	r24, r12
     160:	8e 0d       	add	r24, r14
     162:	9f 1d       	adc	r25, r15
     164:	0e 94 6f 10 	call	0x20de	; 0x20de <memcpy>
     168:	4e 81       	ldd	r20, Y+6	; 0x06
     16a:	5f 81       	ldd	r21, Y+7	; 0x07
     16c:	4a 0d       	add	r20, r10
     16e:	5b 1d       	adc	r21, r11
     170:	5d 87       	std	Y+13, r21	; 0x0d
     172:	4c 87       	std	Y+12, r20	; 0x0c
     174:	d8 cf       	rjmp	.-80     	; 0x126 <iq_read+0x50>
     176:	a8 01       	movw	r20, r16
     178:	c6 01       	movw	r24, r12
     17a:	0e 94 6f 10 	call	0x20de	; 0x20de <memcpy>
     17e:	8c 85       	ldd	r24, Y+12	; 0x0c
     180:	9d 85       	ldd	r25, Y+13	; 0x0d
     182:	80 0f       	add	r24, r16
     184:	91 1f       	adc	r25, r17
     186:	9d 87       	std	Y+13, r25	; 0x0d
     188:	8c 87       	std	Y+12, r24	; 0x0c
     18a:	cd cf       	rjmp	.-102    	; 0x126 <iq_read+0x50>

0000018c <oq_write>:
     18c:	af 92       	push	r10
     18e:	bf 92       	push	r11
     190:	cf 92       	push	r12
     192:	df 92       	push	r13
     194:	ef 92       	push	r14
     196:	ff 92       	push	r15
     198:	0f 93       	push	r16
     19a:	1f 93       	push	r17
     19c:	cf 93       	push	r28
     19e:	df 93       	push	r29
     1a0:	ec 01       	movw	r28, r24
     1a2:	6b 01       	movw	r12, r22
     1a4:	8a 01       	movw	r16, r20
     1a6:	8c 81       	ldd	r24, Y+4	; 0x04
     1a8:	9d 81       	ldd	r25, Y+5	; 0x05
     1aa:	84 17       	cp	r24, r20
     1ac:	95 07       	cpc	r25, r21
     1ae:	10 f4       	brcc	.+4      	; 0x1b4 <oq_write+0x28>
     1b0:	0c 81       	ldd	r16, Y+4	; 0x04
     1b2:	1d 81       	ldd	r17, Y+5	; 0x05
     1b4:	8a 85       	ldd	r24, Y+10	; 0x0a
     1b6:	9b 85       	ldd	r25, Y+11	; 0x0b
     1b8:	e8 84       	ldd	r14, Y+8	; 0x08
     1ba:	f9 84       	ldd	r15, Y+9	; 0x09
     1bc:	e8 1a       	sub	r14, r24
     1be:	f9 0a       	sbc	r15, r25
     1c0:	0e 15       	cp	r16, r14
     1c2:	1f 05       	cpc	r17, r15
     1c4:	98 f1       	brcs	.+102    	; 0x22c <oq_write+0xa0>
     1c6:	e0 16       	cp	r14, r16
     1c8:	f1 06       	cpc	r15, r17
     1ca:	d0 f0       	brcs	.+52     	; 0x200 <oq_write+0x74>
     1cc:	a8 01       	movw	r20, r16
     1ce:	b6 01       	movw	r22, r12
     1d0:	0e 94 6f 10 	call	0x20de	; 0x20de <memcpy>
     1d4:	8e 81       	ldd	r24, Y+6	; 0x06
     1d6:	9f 81       	ldd	r25, Y+7	; 0x07
     1d8:	9b 87       	std	Y+11, r25	; 0x0b
     1da:	8a 87       	std	Y+10, r24	; 0x0a
     1dc:	8c 81       	ldd	r24, Y+4	; 0x04
     1de:	9d 81       	ldd	r25, Y+5	; 0x05
     1e0:	80 1b       	sub	r24, r16
     1e2:	91 0b       	sbc	r25, r17
     1e4:	9d 83       	std	Y+5, r25	; 0x05
     1e6:	8c 83       	std	Y+4, r24	; 0x04
     1e8:	c8 01       	movw	r24, r16
     1ea:	df 91       	pop	r29
     1ec:	cf 91       	pop	r28
     1ee:	1f 91       	pop	r17
     1f0:	0f 91       	pop	r16
     1f2:	ff 90       	pop	r15
     1f4:	ef 90       	pop	r14
     1f6:	df 90       	pop	r13
     1f8:	cf 90       	pop	r12
     1fa:	bf 90       	pop	r11
     1fc:	af 90       	pop	r10
     1fe:	08 95       	ret
     200:	a7 01       	movw	r20, r14
     202:	b6 01       	movw	r22, r12
     204:	0e 94 6f 10 	call	0x20de	; 0x20de <memcpy>
     208:	58 01       	movw	r10, r16
     20a:	ae 18       	sub	r10, r14
     20c:	bf 08       	sbc	r11, r15
     20e:	b6 01       	movw	r22, r12
     210:	6e 0d       	add	r22, r14
     212:	7f 1d       	adc	r23, r15
     214:	a5 01       	movw	r20, r10
     216:	8e 81       	ldd	r24, Y+6	; 0x06
     218:	9f 81       	ldd	r25, Y+7	; 0x07
     21a:	0e 94 6f 10 	call	0x20de	; 0x20de <memcpy>
     21e:	4e 81       	ldd	r20, Y+6	; 0x06
     220:	5f 81       	ldd	r21, Y+7	; 0x07
     222:	4a 0d       	add	r20, r10
     224:	5b 1d       	adc	r21, r11
     226:	5b 87       	std	Y+11, r21	; 0x0b
     228:	4a 87       	std	Y+10, r20	; 0x0a
     22a:	d8 cf       	rjmp	.-80     	; 0x1dc <oq_write+0x50>
     22c:	a8 01       	movw	r20, r16
     22e:	b6 01       	movw	r22, r12
     230:	0e 94 6f 10 	call	0x20de	; 0x20de <memcpy>
     234:	8a 85       	ldd	r24, Y+10	; 0x0a
     236:	9b 85       	ldd	r25, Y+11	; 0x0b
     238:	80 0f       	add	r24, r16
     23a:	91 1f       	adc	r25, r17
     23c:	9b 87       	std	Y+11, r25	; 0x0b
     23e:	8a 87       	std	Y+10, r24	; 0x0a
     240:	cd cf       	rjmp	.-102    	; 0x1dc <oq_write+0x50>

00000242 <iqObjectInit>:
     242:	0f 93       	push	r16
     244:	1f 93       	push	r17
     246:	fc 01       	movw	r30, r24
     248:	91 83       	std	Z+1, r25	; 0x01
     24a:	80 83       	st	Z, r24
     24c:	93 83       	std	Z+3, r25	; 0x03
     24e:	82 83       	std	Z+2, r24	; 0x02
     250:	15 82       	std	Z+5, r1	; 0x05
     252:	14 82       	std	Z+4, r1	; 0x04
     254:	77 83       	std	Z+7, r23	; 0x07
     256:	66 83       	std	Z+6, r22	; 0x06
     258:	75 87       	std	Z+13, r23	; 0x0d
     25a:	64 87       	std	Z+12, r22	; 0x0c
     25c:	73 87       	std	Z+11, r23	; 0x0b
     25e:	62 87       	std	Z+10, r22	; 0x0a
     260:	64 0f       	add	r22, r20
     262:	75 1f       	adc	r23, r21
     264:	71 87       	std	Z+9, r23	; 0x09
     266:	60 87       	std	Z+8, r22	; 0x08
     268:	37 87       	std	Z+15, r19	; 0x0f
     26a:	26 87       	std	Z+14, r18	; 0x0e
     26c:	11 8b       	std	Z+17, r17	; 0x11
     26e:	00 8b       	std	Z+16, r16	; 0x10
     270:	1f 91       	pop	r17
     272:	0f 91       	pop	r16
     274:	08 95       	ret

00000276 <iqPutI>:
     276:	fc 01       	movw	r30, r24
     278:	a2 85       	ldd	r26, Z+10	; 0x0a
     27a:	b3 85       	ldd	r27, Z+11	; 0x0b
     27c:	84 85       	ldd	r24, Z+12	; 0x0c
     27e:	95 85       	ldd	r25, Z+13	; 0x0d
     280:	a8 17       	cp	r26, r24
     282:	b9 07       	cpc	r27, r25
     284:	e1 f0       	breq	.+56     	; 0x2be <iqPutI+0x48>
     286:	84 81       	ldd	r24, Z+4	; 0x04
     288:	95 81       	ldd	r25, Z+5	; 0x05
     28a:	01 96       	adiw	r24, 0x01	; 1
     28c:	95 83       	std	Z+5, r25	; 0x05
     28e:	84 83       	std	Z+4, r24	; 0x04
     290:	cd 01       	movw	r24, r26
     292:	01 96       	adiw	r24, 0x01	; 1
     294:	93 87       	std	Z+11, r25	; 0x0b
     296:	82 87       	std	Z+10, r24	; 0x0a
     298:	6c 93       	st	X, r22
     29a:	22 85       	ldd	r18, Z+10	; 0x0a
     29c:	33 85       	ldd	r19, Z+11	; 0x0b
     29e:	80 85       	ldd	r24, Z+8	; 0x08
     2a0:	91 85       	ldd	r25, Z+9	; 0x09
     2a2:	28 17       	cp	r18, r24
     2a4:	39 07       	cpc	r19, r25
     2a6:	20 f0       	brcs	.+8      	; 0x2b0 <iqPutI+0x3a>
     2a8:	86 81       	ldd	r24, Z+6	; 0x06
     2aa:	97 81       	ldd	r25, Z+7	; 0x07
     2ac:	93 87       	std	Z+11, r25	; 0x0b
     2ae:	82 87       	std	Z+10, r24	; 0x0a
     2b0:	cf 01       	movw	r24, r30
     2b2:	70 e0       	ldi	r23, 0x00	; 0
     2b4:	60 e0       	ldi	r22, 0x00	; 0
     2b6:	2e d7       	rcall	.+3676   	; 0x1114 <chThdDequeueNextI>
     2b8:	90 e0       	ldi	r25, 0x00	; 0
     2ba:	80 e0       	ldi	r24, 0x00	; 0
     2bc:	08 95       	ret
     2be:	84 81       	ldd	r24, Z+4	; 0x04
     2c0:	95 81       	ldd	r25, Z+5	; 0x05
     2c2:	89 2b       	or	r24, r25
     2c4:	01 f3       	breq	.-64     	; 0x286 <iqPutI+0x10>
     2c6:	8f ef       	ldi	r24, 0xFF	; 255
     2c8:	9f ef       	ldi	r25, 0xFF	; 255
     2ca:	08 95       	ret

000002cc <iqGetTimeout>:
     2cc:	0f 93       	push	r16
     2ce:	1f 93       	push	r17
     2d0:	cf 93       	push	r28
     2d2:	df 93       	push	r29
     2d4:	ec 01       	movw	r28, r24
     2d6:	8b 01       	movw	r16, r22
     2d8:	f8 94       	cli
     2da:	05 c0       	rjmp	.+10     	; 0x2e6 <iqGetTimeout+0x1a>
     2dc:	b8 01       	movw	r22, r16
     2de:	ce 01       	movw	r24, r28
     2e0:	fc d6       	rcall	.+3576   	; 0x10da <chThdEnqueueTimeoutS>
     2e2:	97 fd       	sbrc	r25, 7
     2e4:	27 c0       	rjmp	.+78     	; 0x334 <iqGetTimeout+0x68>
     2e6:	8c 81       	ldd	r24, Y+4	; 0x04
     2e8:	9d 81       	ldd	r25, Y+5	; 0x05
     2ea:	89 2b       	or	r24, r25
     2ec:	b9 f3       	breq	.-18     	; 0x2dc <iqGetTimeout+0x10>
     2ee:	8c 81       	ldd	r24, Y+4	; 0x04
     2f0:	9d 81       	ldd	r25, Y+5	; 0x05
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	9d 83       	std	Y+5, r25	; 0x05
     2f6:	8c 83       	std	Y+4, r24	; 0x04
     2f8:	ec 85       	ldd	r30, Y+12	; 0x0c
     2fa:	fd 85       	ldd	r31, Y+13	; 0x0d
     2fc:	cf 01       	movw	r24, r30
     2fe:	01 96       	adiw	r24, 0x01	; 1
     300:	9d 87       	std	Y+13, r25	; 0x0d
     302:	8c 87       	std	Y+12, r24	; 0x0c
     304:	10 81       	ld	r17, Z
     306:	28 85       	ldd	r18, Y+8	; 0x08
     308:	39 85       	ldd	r19, Y+9	; 0x09
     30a:	82 17       	cp	r24, r18
     30c:	93 07       	cpc	r25, r19
     30e:	20 f0       	brcs	.+8      	; 0x318 <iqGetTimeout+0x4c>
     310:	8e 81       	ldd	r24, Y+6	; 0x06
     312:	9f 81       	ldd	r25, Y+7	; 0x07
     314:	9d 87       	std	Y+13, r25	; 0x0d
     316:	8c 87       	std	Y+12, r24	; 0x0c
     318:	ee 85       	ldd	r30, Y+14	; 0x0e
     31a:	ff 85       	ldd	r31, Y+15	; 0x0f
     31c:	30 97       	sbiw	r30, 0x00	; 0
     31e:	11 f0       	breq	.+4      	; 0x324 <iqGetTimeout+0x58>
     320:	ce 01       	movw	r24, r28
     322:	09 95       	icall
     324:	78 94       	sei
     326:	81 2f       	mov	r24, r17
     328:	90 e0       	ldi	r25, 0x00	; 0
     32a:	df 91       	pop	r29
     32c:	cf 91       	pop	r28
     32e:	1f 91       	pop	r17
     330:	0f 91       	pop	r16
     332:	08 95       	ret
     334:	78 94       	sei
     336:	df 91       	pop	r29
     338:	cf 91       	pop	r28
     33a:	1f 91       	pop	r17
     33c:	0f 91       	pop	r16
     33e:	08 95       	ret

00000340 <iqReadTimeout>:
     340:	6f 92       	push	r6
     342:	7f 92       	push	r7
     344:	8f 92       	push	r8
     346:	9f 92       	push	r9
     348:	af 92       	push	r10
     34a:	bf 92       	push	r11
     34c:	cf 92       	push	r12
     34e:	df 92       	push	r13
     350:	ef 92       	push	r14
     352:	ff 92       	push	r15
     354:	0f 93       	push	r16
     356:	1f 93       	push	r17
     358:	cf 93       	push	r28
     35a:	df 93       	push	r29
     35c:	6c 01       	movw	r12, r24
     35e:	7b 01       	movw	r14, r22
     360:	4a 01       	movw	r8, r20
     362:	39 01       	movw	r6, r18
     364:	fc 01       	movw	r30, r24
     366:	a6 84       	ldd	r10, Z+14	; 0x0e
     368:	b7 84       	ldd	r11, Z+15	; 0x0f
     36a:	f8 94       	cli
     36c:	41 15       	cp	r20, r1
     36e:	51 05       	cpc	r21, r1
     370:	b9 f0       	breq	.+46     	; 0x3a0 <iqReadTimeout+0x60>
     372:	8a 01       	movw	r16, r20
     374:	a8 01       	movw	r20, r16
     376:	b7 01       	movw	r22, r14
     378:	c6 01       	movw	r24, r12
     37a:	ad de       	rcall	.-678    	; 0xd6 <iq_read>
     37c:	ec 01       	movw	r28, r24
     37e:	89 2b       	or	r24, r25
     380:	01 f1       	breq	.+64     	; 0x3c2 <iqReadTimeout+0x82>
     382:	a1 14       	cp	r10, r1
     384:	b1 04       	cpc	r11, r1
     386:	19 f0       	breq	.+6      	; 0x38e <iqReadTimeout+0x4e>
     388:	c6 01       	movw	r24, r12
     38a:	f5 01       	movw	r30, r10
     38c:	09 95       	icall
     38e:	78 94       	sei
     390:	0c 1b       	sub	r16, r28
     392:	1d 0b       	sbc	r17, r29
     394:	ec 0e       	add	r14, r28
     396:	fd 1e       	adc	r15, r29
     398:	f8 94       	cli
     39a:	01 15       	cp	r16, r1
     39c:	11 05       	cpc	r17, r1
     39e:	51 f7       	brne	.-44     	; 0x374 <iqReadTimeout+0x34>
     3a0:	c4 01       	movw	r24, r8
     3a2:	78 94       	sei
     3a4:	df 91       	pop	r29
     3a6:	cf 91       	pop	r28
     3a8:	1f 91       	pop	r17
     3aa:	0f 91       	pop	r16
     3ac:	ff 90       	pop	r15
     3ae:	ef 90       	pop	r14
     3b0:	df 90       	pop	r13
     3b2:	cf 90       	pop	r12
     3b4:	bf 90       	pop	r11
     3b6:	af 90       	pop	r10
     3b8:	9f 90       	pop	r9
     3ba:	8f 90       	pop	r8
     3bc:	7f 90       	pop	r7
     3be:	6f 90       	pop	r6
     3c0:	08 95       	ret
     3c2:	b3 01       	movw	r22, r6
     3c4:	c6 01       	movw	r24, r12
     3c6:	89 d6       	rcall	.+3346   	; 0x10da <chThdEnqueueTimeoutS>
     3c8:	89 2b       	or	r24, r25
     3ca:	a1 f2       	breq	.-88     	; 0x374 <iqReadTimeout+0x34>
     3cc:	c4 01       	movw	r24, r8
     3ce:	80 1b       	sub	r24, r16
     3d0:	91 0b       	sbc	r25, r17
     3d2:	e7 cf       	rjmp	.-50     	; 0x3a2 <iqReadTimeout+0x62>

000003d4 <oqObjectInit>:
     3d4:	0f 93       	push	r16
     3d6:	1f 93       	push	r17
     3d8:	fc 01       	movw	r30, r24
     3da:	91 83       	std	Z+1, r25	; 0x01
     3dc:	80 83       	st	Z, r24
     3de:	93 83       	std	Z+3, r25	; 0x03
     3e0:	82 83       	std	Z+2, r24	; 0x02
     3e2:	55 83       	std	Z+5, r21	; 0x05
     3e4:	44 83       	std	Z+4, r20	; 0x04
     3e6:	77 83       	std	Z+7, r23	; 0x07
     3e8:	66 83       	std	Z+6, r22	; 0x06
     3ea:	75 87       	std	Z+13, r23	; 0x0d
     3ec:	64 87       	std	Z+12, r22	; 0x0c
     3ee:	73 87       	std	Z+11, r23	; 0x0b
     3f0:	62 87       	std	Z+10, r22	; 0x0a
     3f2:	64 0f       	add	r22, r20
     3f4:	75 1f       	adc	r23, r21
     3f6:	71 87       	std	Z+9, r23	; 0x09
     3f8:	60 87       	std	Z+8, r22	; 0x08
     3fa:	37 87       	std	Z+15, r19	; 0x0f
     3fc:	26 87       	std	Z+14, r18	; 0x0e
     3fe:	11 8b       	std	Z+17, r17	; 0x11
     400:	00 8b       	std	Z+16, r16	; 0x10
     402:	1f 91       	pop	r17
     404:	0f 91       	pop	r16
     406:	08 95       	ret

00000408 <oqPutTimeout>:
     408:	ff 92       	push	r15
     40a:	0f 93       	push	r16
     40c:	1f 93       	push	r17
     40e:	cf 93       	push	r28
     410:	df 93       	push	r29
     412:	ec 01       	movw	r28, r24
     414:	f6 2e       	mov	r15, r22
     416:	8a 01       	movw	r16, r20
     418:	f8 94       	cli
     41a:	05 c0       	rjmp	.+10     	; 0x426 <oqPutTimeout+0x1e>
     41c:	b8 01       	movw	r22, r16
     41e:	ce 01       	movw	r24, r28
     420:	5c d6       	rcall	.+3256   	; 0x10da <chThdEnqueueTimeoutS>
     422:	97 fd       	sbrc	r25, 7
     424:	2a c0       	rjmp	.+84     	; 0x47a <oqPutTimeout+0x72>
     426:	8c 81       	ldd	r24, Y+4	; 0x04
     428:	9d 81       	ldd	r25, Y+5	; 0x05
     42a:	89 2b       	or	r24, r25
     42c:	b9 f3       	breq	.-18     	; 0x41c <oqPutTimeout+0x14>
     42e:	8c 81       	ldd	r24, Y+4	; 0x04
     430:	9d 81       	ldd	r25, Y+5	; 0x05
     432:	01 97       	sbiw	r24, 0x01	; 1
     434:	9d 83       	std	Y+5, r25	; 0x05
     436:	8c 83       	std	Y+4, r24	; 0x04
     438:	ea 85       	ldd	r30, Y+10	; 0x0a
     43a:	fb 85       	ldd	r31, Y+11	; 0x0b
     43c:	cf 01       	movw	r24, r30
     43e:	01 96       	adiw	r24, 0x01	; 1
     440:	9b 87       	std	Y+11, r25	; 0x0b
     442:	8a 87       	std	Y+10, r24	; 0x0a
     444:	f0 82       	st	Z, r15
     446:	2a 85       	ldd	r18, Y+10	; 0x0a
     448:	3b 85       	ldd	r19, Y+11	; 0x0b
     44a:	88 85       	ldd	r24, Y+8	; 0x08
     44c:	99 85       	ldd	r25, Y+9	; 0x09
     44e:	28 17       	cp	r18, r24
     450:	39 07       	cpc	r19, r25
     452:	20 f0       	brcs	.+8      	; 0x45c <oqPutTimeout+0x54>
     454:	8e 81       	ldd	r24, Y+6	; 0x06
     456:	9f 81       	ldd	r25, Y+7	; 0x07
     458:	9b 87       	std	Y+11, r25	; 0x0b
     45a:	8a 87       	std	Y+10, r24	; 0x0a
     45c:	ee 85       	ldd	r30, Y+14	; 0x0e
     45e:	ff 85       	ldd	r31, Y+15	; 0x0f
     460:	30 97       	sbiw	r30, 0x00	; 0
     462:	11 f0       	breq	.+4      	; 0x468 <oqPutTimeout+0x60>
     464:	ce 01       	movw	r24, r28
     466:	09 95       	icall
     468:	78 94       	sei
     46a:	90 e0       	ldi	r25, 0x00	; 0
     46c:	80 e0       	ldi	r24, 0x00	; 0
     46e:	df 91       	pop	r29
     470:	cf 91       	pop	r28
     472:	1f 91       	pop	r17
     474:	0f 91       	pop	r16
     476:	ff 90       	pop	r15
     478:	08 95       	ret
     47a:	78 94       	sei
     47c:	df 91       	pop	r29
     47e:	cf 91       	pop	r28
     480:	1f 91       	pop	r17
     482:	0f 91       	pop	r16
     484:	ff 90       	pop	r15
     486:	08 95       	ret

00000488 <oqGetI>:
     488:	cf 93       	push	r28
     48a:	fc 01       	movw	r30, r24
     48c:	a4 85       	ldd	r26, Z+12	; 0x0c
     48e:	b5 85       	ldd	r27, Z+13	; 0x0d
     490:	82 85       	ldd	r24, Z+10	; 0x0a
     492:	93 85       	ldd	r25, Z+11	; 0x0b
     494:	8a 17       	cp	r24, r26
     496:	9b 07       	cpc	r25, r27
     498:	e1 f0       	breq	.+56     	; 0x4d2 <oqGetI+0x4a>
     49a:	84 81       	ldd	r24, Z+4	; 0x04
     49c:	95 81       	ldd	r25, Z+5	; 0x05
     49e:	01 96       	adiw	r24, 0x01	; 1
     4a0:	95 83       	std	Z+5, r25	; 0x05
     4a2:	84 83       	std	Z+4, r24	; 0x04
     4a4:	cd 01       	movw	r24, r26
     4a6:	01 96       	adiw	r24, 0x01	; 1
     4a8:	95 87       	std	Z+13, r25	; 0x0d
     4aa:	84 87       	std	Z+12, r24	; 0x0c
     4ac:	cc 91       	ld	r28, X
     4ae:	20 85       	ldd	r18, Z+8	; 0x08
     4b0:	31 85       	ldd	r19, Z+9	; 0x09
     4b2:	82 17       	cp	r24, r18
     4b4:	93 07       	cpc	r25, r19
     4b6:	40 f4       	brcc	.+16     	; 0x4c8 <oqGetI+0x40>
     4b8:	cf 01       	movw	r24, r30
     4ba:	70 e0       	ldi	r23, 0x00	; 0
     4bc:	60 e0       	ldi	r22, 0x00	; 0
     4be:	2a d6       	rcall	.+3156   	; 0x1114 <chThdDequeueNextI>
     4c0:	8c 2f       	mov	r24, r28
     4c2:	90 e0       	ldi	r25, 0x00	; 0
     4c4:	cf 91       	pop	r28
     4c6:	08 95       	ret
     4c8:	86 81       	ldd	r24, Z+6	; 0x06
     4ca:	97 81       	ldd	r25, Z+7	; 0x07
     4cc:	95 87       	std	Z+13, r25	; 0x0d
     4ce:	84 87       	std	Z+12, r24	; 0x0c
     4d0:	f3 cf       	rjmp	.-26     	; 0x4b8 <oqGetI+0x30>
     4d2:	84 81       	ldd	r24, Z+4	; 0x04
     4d4:	95 81       	ldd	r25, Z+5	; 0x05
     4d6:	89 2b       	or	r24, r25
     4d8:	01 f3       	breq	.-64     	; 0x49a <oqGetI+0x12>
     4da:	8f ef       	ldi	r24, 0xFF	; 255
     4dc:	9f ef       	ldi	r25, 0xFF	; 255
     4de:	cf 91       	pop	r28
     4e0:	08 95       	ret

000004e2 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
     4e2:	6f 92       	push	r6
     4e4:	7f 92       	push	r7
     4e6:	8f 92       	push	r8
     4e8:	9f 92       	push	r9
     4ea:	af 92       	push	r10
     4ec:	bf 92       	push	r11
     4ee:	cf 92       	push	r12
     4f0:	df 92       	push	r13
     4f2:	ef 92       	push	r14
     4f4:	ff 92       	push	r15
     4f6:	0f 93       	push	r16
     4f8:	1f 93       	push	r17
     4fa:	cf 93       	push	r28
     4fc:	df 93       	push	r29
     4fe:	6c 01       	movw	r12, r24
     500:	7b 01       	movw	r14, r22
     502:	4a 01       	movw	r8, r20
     504:	39 01       	movw	r6, r18
  qnotify_t nfy = oqp->q_notify;
     506:	fc 01       	movw	r30, r24
     508:	a6 84       	ldd	r10, Z+14	; 0x0e
     50a:	b7 84       	ldd	r11, Z+15	; 0x0f
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
     50c:	f8 94       	cli

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
     50e:	41 15       	cp	r20, r1
     510:	51 05       	cpc	r21, r1
     512:	b9 f0       	breq	.+46     	; 0x542 <oqWriteTimeout+0x60>
     514:	8a 01       	movw	r16, r20
    size_t done;

    done = oq_write(oqp, bp, n);
     516:	a8 01       	movw	r20, r16
     518:	b7 01       	movw	r22, r14
     51a:	c6 01       	movw	r24, r12
     51c:	37 de       	rcall	.-914    	; 0x18c <oq_write>
     51e:	ec 01       	movw	r28, r24
    if (done == (size_t)0) {
     520:	89 2b       	or	r24, r25
     522:	01 f1       	breq	.+64     	; 0x564 <oqWriteTimeout+0x82>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
     524:	a1 14       	cp	r10, r1
     526:	b1 04       	cpc	r11, r1
     528:	19 f0       	breq	.+6      	; 0x530 <oqWriteTimeout+0x4e>
        nfy(oqp);
     52a:	c6 01       	movw	r24, r12
     52c:	f5 01       	movw	r30, r10
     52e:	09 95       	icall
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
     530:	78 94       	sei
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
     532:	0c 1b       	sub	r16, r28
     534:	1d 0b       	sbc	r17, r29
      bp += done;
     536:	ec 0e       	add	r14, r28
     538:	fd 1e       	adc	r15, r29
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
     53a:	f8 94       	cli

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
     53c:	01 15       	cp	r16, r1
     53e:	11 05       	cpc	r17, r1
     540:	51 f7       	brne	.-44     	; 0x516 <oqWriteTimeout+0x34>
     542:	c4 01       	movw	r24, r8
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
     544:	78 94       	sei
    }
  }

  osalSysUnlock();
  return max - n;
}
     546:	df 91       	pop	r29
     548:	cf 91       	pop	r28
     54a:	1f 91       	pop	r17
     54c:	0f 91       	pop	r16
     54e:	ff 90       	pop	r15
     550:	ef 90       	pop	r14
     552:	df 90       	pop	r13
     554:	cf 90       	pop	r12
     556:	bf 90       	pop	r11
     558:	af 90       	pop	r10
     55a:	9f 90       	pop	r9
     55c:	8f 90       	pop	r8
     55e:	7f 90       	pop	r7
     560:	6f 90       	pop	r6
     562:	08 95       	ret
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {

  return chThdEnqueueTimeoutS(tqp, timeout);
     564:	b3 01       	movw	r22, r6
     566:	c6 01       	movw	r24, r12
     568:	b8 d5       	rcall	.+2928   	; 0x10da <chThdEnqueueTimeoutS>
    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
     56a:	89 2b       	or	r24, r25
     56c:	a1 f2       	breq	.-88     	; 0x516 <oqWriteTimeout+0x34>
     56e:	c4 01       	movw	r24, r8
     570:	80 1b       	sub	r24, r16
     572:	91 0b       	sbc	r25, r17
     574:	e7 cf       	rjmp	.-50     	; 0x544 <oqWriteTimeout+0x62>

00000576 <_readt>:
  oqResetI(&sdp->oqueue);
  iqResetI(&sdp->iqueue);
  osalOsRescheduleS();

  osalSysUnlock();
}
     576:	05 96       	adiw	r24, 0x05	; 5
     578:	e3 ce       	rjmp	.-570    	; 0x340 <iqReadTimeout>

0000057a <_read>:
     57a:	2f ef       	ldi	r18, 0xFF	; 255
     57c:	3f ef       	ldi	r19, 0xFF	; 255
     57e:	05 96       	adiw	r24, 0x05	; 5
     580:	df ce       	rjmp	.-578    	; 0x340 <iqReadTimeout>

00000582 <_writet>:
     582:	47 96       	adiw	r24, 0x17	; 23
     584:	ae cf       	rjmp	.-164    	; 0x4e2 <oqWriteTimeout>

00000586 <_write>:
     586:	2f ef       	ldi	r18, 0xFF	; 255
     588:	3f ef       	ldi	r19, 0xFF	; 255
     58a:	47 96       	adiw	r24, 0x17	; 23
     58c:	aa cf       	rjmp	.-172    	; 0x4e2 <oqWriteTimeout>

0000058e <_gett>:
     58e:	05 96       	adiw	r24, 0x05	; 5
     590:	9d ce       	rjmp	.-710    	; 0x2cc <iqGetTimeout>

00000592 <_get>:
     592:	6f ef       	ldi	r22, 0xFF	; 255
     594:	7f ef       	ldi	r23, 0xFF	; 255
     596:	05 96       	adiw	r24, 0x05	; 5
     598:	99 ce       	rjmp	.-718    	; 0x2cc <iqGetTimeout>

0000059a <_putt>:
     59a:	47 96       	adiw	r24, 0x17	; 23
     59c:	35 cf       	rjmp	.-406    	; 0x408 <oqPutTimeout>

0000059e <_put>:
     59e:	4f ef       	ldi	r20, 0xFF	; 255
     5a0:	5f ef       	ldi	r21, 0xFF	; 255
     5a2:	47 96       	adiw	r24, 0x17	; 23
     5a4:	31 cf       	rjmp	.-414    	; 0x408 <oqPutTimeout>

000005a6 <_ctl>:
     5a6:	61 30       	cpi	r22, 0x01	; 1
     5a8:	71 05       	cpc	r23, r1
     5aa:	19 f0       	breq	.+6      	; 0x5b2 <_ctl+0xc>
     5ac:	8c ee       	ldi	r24, 0xEC	; 236
     5ae:	9f ef       	ldi	r25, 0xFF	; 255
     5b0:	08 95       	ret
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	80 e0       	ldi	r24, 0x00	; 0
     5b6:	08 95       	ret

000005b8 <sdInit>:
     5b8:	5d c1       	rjmp	.+698    	; 0x874 <sd_lld_init>

000005ba <sdObjectInit>:
     5ba:	ef 92       	push	r14
     5bc:	ff 92       	push	r15
     5be:	0f 93       	push	r16
     5c0:	1f 93       	push	r17
     5c2:	cf 93       	push	r28
     5c4:	df 93       	push	r29
     5c6:	ec 01       	movw	r28, r24
     5c8:	9b 01       	movw	r18, r22
     5ca:	7a 01       	movw	r14, r20
     5cc:	fc 01       	movw	r30, r24
     5ce:	81 e0       	ldi	r24, 0x01	; 1
     5d0:	91 e0       	ldi	r25, 0x01	; 1
     5d2:	81 93       	st	Z+, r24
     5d4:	91 93       	st	Z+, r25
     5d6:	fb 83       	std	Y+3, r31	; 0x03
     5d8:	ea 83       	std	Y+2, r30	; 0x02
     5da:	81 e0       	ldi	r24, 0x01	; 1
     5dc:	8c 83       	std	Y+4, r24	; 0x04
     5de:	be 01       	movw	r22, r28
     5e0:	67 5d       	subi	r22, 0xD7	; 215
     5e2:	7f 4f       	sbci	r23, 0xFF	; 255
     5e4:	8e 01       	movw	r16, r28
     5e6:	40 e1       	ldi	r20, 0x10	; 16
     5e8:	50 e0       	ldi	r21, 0x00	; 0
     5ea:	ce 01       	movw	r24, r28
     5ec:	05 96       	adiw	r24, 0x05	; 5
     5ee:	29 de       	rcall	.-942    	; 0x242 <iqObjectInit>
     5f0:	be 01       	movw	r22, r28
     5f2:	67 5c       	subi	r22, 0xC7	; 199
     5f4:	7f 4f       	sbci	r23, 0xFF	; 255
     5f6:	97 01       	movw	r18, r14
     5f8:	40 e1       	ldi	r20, 0x10	; 16
     5fa:	50 e0       	ldi	r21, 0x00	; 0
     5fc:	ce 01       	movw	r24, r28
     5fe:	47 96       	adiw	r24, 0x17	; 23
     600:	e9 de       	rcall	.-558    	; 0x3d4 <oqObjectInit>
     602:	df 91       	pop	r29
     604:	cf 91       	pop	r28
     606:	1f 91       	pop	r17
     608:	0f 91       	pop	r16
     60a:	ff 90       	pop	r15
     60c:	ef 90       	pop	r14
     60e:	08 95       	ret

00000610 <sdStart>:
     610:	cf 93       	push	r28
     612:	df 93       	push	r29
     614:	ec 01       	movw	r28, r24
     616:	f8 94       	cli
     618:	34 d1       	rcall	.+616    	; 0x882 <sd_lld_start>
     61a:	82 e0       	ldi	r24, 0x02	; 2
     61c:	8c 83       	std	Y+4, r24	; 0x04
     61e:	78 94       	sei
     620:	90 e0       	ldi	r25, 0x00	; 0
     622:	80 e0       	ldi	r24, 0x00	; 0
     624:	df 91       	pop	r29
     626:	cf 91       	pop	r28
     628:	08 95       	ret

0000062a <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
     62a:	1f 93       	push	r17
     62c:	cf 93       	push	r28
     62e:	df 93       	push	r29
     630:	ec 01       	movw	r28, r24
     632:	16 2f       	mov	r17, r22

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
     634:	89 85       	ldd	r24, Y+9	; 0x09
     636:	9a 85       	ldd	r25, Y+10	; 0x0a
     638:	89 2b       	or	r24, r25
     63a:	51 f0       	breq	.+20     	; 0x650 <sdIncomingDataI+0x26>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
     63c:	61 2f       	mov	r22, r17
     63e:	ce 01       	movw	r24, r28
     640:	05 96       	adiw	r24, 0x05	; 5
     642:	19 de       	rcall	.-974    	; 0x276 <iqPutI>
     644:	97 fd       	sbrc	r25, 7
     646:	0e c0       	rjmp	.+28     	; 0x664 <sdIncomingDataI+0x3a>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
     648:	df 91       	pop	r29
     64a:	cf 91       	pop	r28
     64c:	1f 91       	pop	r17
     64e:	08 95       	ret
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
     650:	64 e0       	ldi	r22, 0x04	; 4
     652:	ce 01       	movw	r24, r28
     654:	02 96       	adiw	r24, 0x02	; 2
     656:	67 d7       	rcall	.+3790   	; 0x1526 <chEvtBroadcastFlagsI>
  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
     658:	61 2f       	mov	r22, r17
     65a:	ce 01       	movw	r24, r28
     65c:	05 96       	adiw	r24, 0x05	; 5
     65e:	0b de       	rcall	.-1002   	; 0x276 <iqPutI>
     660:	97 ff       	sbrs	r25, 7
     662:	f2 cf       	rjmp	.-28     	; 0x648 <sdIncomingDataI+0x1e>
     664:	60 e0       	ldi	r22, 0x00	; 0
     666:	ce 01       	movw	r24, r28
     668:	02 96       	adiw	r24, 0x02	; 2
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
     66a:	df 91       	pop	r29
     66c:	cf 91       	pop	r28
     66e:	1f 91       	pop	r17
     670:	5a c7       	rjmp	.+3764   	; 0x1526 <chEvtBroadcastFlagsI>

00000672 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
     672:	0f 93       	push	r16
     674:	1f 93       	push	r17
     676:	cf 93       	push	r28
     678:	df 93       	push	r29
     67a:	8c 01       	movw	r16, r24
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
     67c:	47 96       	adiw	r24, 0x17	; 23
     67e:	04 df       	rcall	.-504    	; 0x488 <oqGetI>
     680:	ec 01       	movw	r28, r24
  if (b < MSG_OK)
     682:	97 fd       	sbrc	r25, 7
     684:	06 c0       	rjmp	.+12     	; 0x692 <sdRequestDataI+0x20>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
  return b;
}
     686:	ce 01       	movw	r24, r28
     688:	df 91       	pop	r29
     68a:	cf 91       	pop	r28
     68c:	1f 91       	pop	r17
     68e:	0f 91       	pop	r16
     690:	08 95       	ret
     692:	68 e0       	ldi	r22, 0x08	; 8
     694:	c8 01       	movw	r24, r16
     696:	02 96       	adiw	r24, 0x02	; 2
     698:	46 d7       	rcall	.+3724   	; 0x1526 <chEvtBroadcastFlagsI>
     69a:	ce 01       	movw	r24, r28
     69c:	df 91       	pop	r29
     69e:	cf 91       	pop	r28
     6a0:	1f 91       	pop	r17
     6a2:	0f 91       	pop	r16
     6a4:	08 95       	ret

000006a6 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  EICRA  = 0x00;
     6a6:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <__TEXT_REGION_LENGTH__+0x7f8069>
  EIMSK  = 0x00;
     6aa:	1d ba       	out	0x1d, r1	; 29

}
     6ac:	08 95       	ret

000006ae <hal_lld_init>:
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
}
     6ae:	08 95       	ret

000006b0 <_pal_lld_init>:
 *
 * @param[in] config    the AVR ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
     6b0:	fc 01       	movw	r30, r24
  PORTA = config->porta.out;
  DDRA = config->porta.dir;
#endif

#if defined(PORTB) || defined(__DOXYGEN__)
  PORTB = config->portb.out;
     6b2:	80 81       	ld	r24, Z
     6b4:	85 b9       	out	0x05, r24	; 5
  DDRB = config->portb.dir;
     6b6:	81 81       	ldd	r24, Z+1	; 0x01
     6b8:	84 b9       	out	0x04, r24	; 4
#endif

#if defined(PORTC) || defined(__DOXYGEN__)
  PORTC = config->portc.out;
     6ba:	82 81       	ldd	r24, Z+2	; 0x02
     6bc:	88 b9       	out	0x08, r24	; 8
  DDRC = config->portc.dir;
     6be:	83 81       	ldd	r24, Z+3	; 0x03
     6c0:	87 b9       	out	0x07, r24	; 7
#endif

#if defined(PORTD) || defined(__DOXYGEN__)
  PORTD = config->portd.out;
     6c2:	84 81       	ldd	r24, Z+4	; 0x04
     6c4:	8b b9       	out	0x0b, r24	; 11
  DDRD = config->portd.dir;
     6c6:	85 81       	ldd	r24, Z+5	; 0x05
     6c8:	8a b9       	out	0x0a, r24	; 10

#if defined(PORTL) || defined(__DOXYGEN__)
  PORTL = config->portl.out;
  DDRL = config->portl.dir;
#endif
}
     6ca:	08 95       	ret

000006cc <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
     6cc:	fc 01       	movw	r30, r24

  switch (mode) {
     6ce:	42 30       	cpi	r20, 0x02	; 2
     6d0:	c9 f0       	breq	.+50     	; 0x704 <_pal_lld_setgroupmode+0x38>
     6d2:	98 f0       	brcs	.+38     	; 0x6fa <_pal_lld_setgroupmode+0x2e>
     6d4:	45 30       	cpi	r20, 0x05	; 5
     6d6:	b1 f0       	breq	.+44     	; 0x704 <_pal_lld_setgroupmode+0x38>
     6d8:	46 30       	cpi	r20, 0x06	; 6
     6da:	21 f4       	brne	.+8      	; 0x6e4 <_pal_lld_setgroupmode+0x18>
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
    port->out |= mask;
    break;
  case PAL_MODE_OUTPUT_PUSHPULL:
    port->dir |= mask;
     6dc:	81 81       	ldd	r24, Z+1	; 0x01
     6de:	68 2b       	or	r22, r24
     6e0:	61 83       	std	Z+1, r22	; 0x01
    break;
  }
}
     6e2:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
     6e4:	43 30       	cpi	r20, 0x03	; 3
     6e6:	e9 f7       	brne	.-6      	; 0x6e2 <_pal_lld_setgroupmode+0x16>
    port->dir &= ~mask;
    port->out &= ~mask;
    break;
  case PAL_MODE_UNCONNECTED:
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
     6e8:	91 81       	ldd	r25, Z+1	; 0x01
     6ea:	86 2f       	mov	r24, r22
     6ec:	80 95       	com	r24
     6ee:	89 23       	and	r24, r25
     6f0:	81 83       	std	Z+1, r24	; 0x01
    port->out |= mask;
     6f2:	82 81       	ldd	r24, Z+2	; 0x02
     6f4:	68 2b       	or	r22, r24
     6f6:	62 83       	std	Z+2, r22	; 0x02
    break;
     6f8:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
     6fa:	44 23       	and	r20, r20
     6fc:	19 f0       	breq	.+6      	; 0x704 <_pal_lld_setgroupmode+0x38>
     6fe:	41 30       	cpi	r20, 0x01	; 1
     700:	99 f3       	breq	.-26     	; 0x6e8 <_pal_lld_setgroupmode+0x1c>
     702:	08 95       	ret
  case PAL_MODE_RESET:
  case PAL_MODE_INPUT:
  case PAL_MODE_INPUT_ANALOG:
    port->dir &= ~mask;
     704:	81 81       	ldd	r24, Z+1	; 0x01
     706:	60 95       	com	r22
     708:	86 23       	and	r24, r22
     70a:	81 83       	std	Z+1, r24	; 0x01
    port->out &= ~mask;
     70c:	82 81       	ldd	r24, Z+2	; 0x02
     70e:	68 23       	and	r22, r24
     710:	62 83       	std	Z+2, r22	; 0x02
    break;
     712:	08 95       	ret

00000714 <__vector_14>:
#if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined(__DOXYGEN__)

/**
 * @brief Timer handler for periodic mode.
 */
OSAL_IRQ_HANDLER(AVR_TIMER_VECT) {
     714:	1f 92       	push	r1
     716:	0f 92       	push	r0
     718:	0f b6       	in	r0, 0x3f	; 63
     71a:	0f 92       	push	r0
     71c:	11 24       	eor	r1, r1
     71e:	2f 93       	push	r18
     720:	3f 93       	push	r19
     722:	4f 93       	push	r20
     724:	5f 93       	push	r21
     726:	6f 93       	push	r22
     728:	7f 93       	push	r23
     72a:	8f 93       	push	r24
     72c:	9f 93       	push	r25
     72e:	af 93       	push	r26
     730:	bf 93       	push	r27
     732:	ef 93       	push	r30
     734:	ff 93       	push	r31

  OSAL_IRQ_PROLOGUE();
     736:	81 e0       	ldi	r24, 0x01	; 1
     738:	80 93 eb 06 	sts	0x06EB, r24	; 0x8006eb <__avr_in_isr>
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
     73c:	f3 d0       	rcall	.+486    	; 0x924 <chSysTimerHandlerI>

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
     73e:	10 92 eb 06 	sts	0x06EB, r1	; 0x8006eb <__avr_in_isr>
     742:	de d2       	rcall	.+1468   	; 0xd00 <chSchIsPreemptionRequired>
     744:	81 11       	cpse	r24, r1
     746:	ec d2       	rcall	.+1496   	; 0xd20 <chSchDoPreemption>
}
     748:	ff 91       	pop	r31
     74a:	ef 91       	pop	r30
     74c:	bf 91       	pop	r27
     74e:	af 91       	pop	r26
     750:	9f 91       	pop	r25
     752:	8f 91       	pop	r24
     754:	7f 91       	pop	r23
     756:	6f 91       	pop	r22
     758:	5f 91       	pop	r21
     75a:	4f 91       	pop	r20
     75c:	3f 91       	pop	r19
     75e:	2f 91       	pop	r18
     760:	0f 90       	pop	r0
     762:	0f be       	out	0x3f, r0	; 63
     764:	0f 90       	pop	r0
     766:	1f 90       	pop	r1
     768:	18 95       	reti

0000076a <st_lld_init>:

  /*
   * Periodic mode uses Timer 0 (8 bit).
   */
#if defined(TCCR0B) /* Timer has multiple output comparators.               */
  TCCR0A  = (1 << WGM01) | (0 << WGM00) |                /* CTC mode.       */
     76a:	82 e0       	ldi	r24, 0x02	; 2
     76c:	84 bd       	out	0x24, r24	; 36
            (0 << COM0A1) | (0 << COM0A0) |              /* OC0A disabled.  */
            (0 << COM0B1) | (0 << COM0B0);               /* OC0B disabled.  */
  TCCR0B  = (0 << WGM02) | AVR_TIMER_PRESCALER_BITS;     /* CTC mode.       */
     76e:	85 bd       	out	0x25, r24	; 37
  OCR0A   = AVR_TIMER_COUNTER - 1;
     770:	9f e7       	ldi	r25, 0x7F	; 127
     772:	97 bd       	out	0x27, r25	; 39
  TCNT0   = 0;                                           /* Reset counter.  */
     774:	16 bc       	out	0x26, r1	; 38
  TIFR0   = (1 << OCF0A);                                /* Reset pending.  */
     776:	85 bb       	out	0x15, r24	; 21
  TIMSK0  = (1 << OCIE0A);                               /* IRQ on compare. */
     778:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7f806e>
#else
  #error "Neither TCCR0A nor TCCR0 registers are defined"
#endif

#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
     77c:	08 95       	ret

0000077e <notify1>:

#if AVR_SERIAL_USE_USART0 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  UCSR0B |= (1 << UDRIE0);
     77e:	e1 ec       	ldi	r30, 0xC1	; 193
     780:	f0 e0       	ldi	r31, 0x00	; 0
     782:	80 81       	ld	r24, Z
     784:	80 62       	ori	r24, 0x20	; 32
     786:	80 83       	st	Z, r24
}
     788:	08 95       	ret

0000078a <__vector_18>:
/**
 * @brief   USART0 RX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_RX_VECT) {
     78a:	1f 92       	push	r1
     78c:	0f 92       	push	r0
     78e:	0f b6       	in	r0, 0x3f	; 63
     790:	0f 92       	push	r0
     792:	11 24       	eor	r1, r1
     794:	2f 93       	push	r18
     796:	3f 93       	push	r19
     798:	4f 93       	push	r20
     79a:	5f 93       	push	r21
     79c:	6f 93       	push	r22
     79e:	7f 93       	push	r23
     7a0:	8f 93       	push	r24
     7a2:	9f 93       	push	r25
     7a4:	af 93       	push	r26
     7a6:	bf 93       	push	r27
     7a8:	ef 93       	push	r30
     7aa:	ff 93       	push	r31
  uint8_t sra;

  OSAL_IRQ_PROLOGUE();
     7ac:	81 e0       	ldi	r24, 0x01	; 1
     7ae:	80 93 eb 06 	sts	0x06EB, r24	; 0x8006eb <__avr_in_isr>

  sra = UCSR0A;
     7b2:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
     7b6:	98 2f       	mov	r25, r24
     7b8:	9c 71       	andi	r25, 0x1C	; 28
     7ba:	41 f0       	breq	.+16     	; 0x7cc <__vector_18+0x42>
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    sts |= SD_PARITY_ERROR;
     7bc:	60 e2       	ldi	r22, 0x20	; 32
  }
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
     7be:	82 ff       	sbrs	r24, 2
     7c0:	60 e0       	ldi	r22, 0x00	; 0
    sts |= SD_PARITY_ERROR;
  if (sra & fe)
     7c2:	84 fd       	sbrc	r24, 4
     7c4:	1e c0       	rjmp	.+60     	; 0x802 <__DATA_REGION_LENGTH__+0x2>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
     7c6:	8a e5       	ldi	r24, 0x5A	; 90
     7c8:	96 e0       	ldi	r25, 0x06	; 6
     7ca:	ad d6       	rcall	.+3418   	; 0x1526 <chEvtBroadcastFlagsI>

  sra = UCSR0A;
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
    set_error(sra, &SD1);
  osalSysLockFromISR();
  sdIncomingDataI(&SD1, UDR0);
     7cc:	60 91 c6 00 	lds	r22, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
     7d0:	88 e5       	ldi	r24, 0x58	; 88
     7d2:	96 e0       	ldi	r25, 0x06	; 6
     7d4:	2a df       	rcall	.-428    	; 0x62a <sdIncomingDataI>
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
     7d6:	10 92 eb 06 	sts	0x06EB, r1	; 0x8006eb <__avr_in_isr>
     7da:	92 d2       	rcall	.+1316   	; 0xd00 <chSchIsPreemptionRequired>
     7dc:	81 11       	cpse	r24, r1
     7de:	a0 d2       	rcall	.+1344   	; 0xd20 <chSchDoPreemption>
}
     7e0:	ff 91       	pop	r31
     7e2:	ef 91       	pop	r30
     7e4:	bf 91       	pop	r27
     7e6:	af 91       	pop	r26
     7e8:	9f 91       	pop	r25
     7ea:	8f 91       	pop	r24
     7ec:	7f 91       	pop	r23
     7ee:	6f 91       	pop	r22
     7f0:	5f 91       	pop	r21
     7f2:	4f 91       	pop	r20
     7f4:	3f 91       	pop	r19
     7f6:	2f 91       	pop	r18
     7f8:	0f 90       	pop	r0
     7fa:	0f be       	out	0x3f, r0	; 63
     7fc:	0f 90       	pop	r0
     7fe:	1f 90       	pop	r1
     800:	18 95       	reti
  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    sts |= SD_PARITY_ERROR;
  if (sra & fe)
    sts |= SD_FRAMING_ERROR;
     802:	60 64       	ori	r22, 0x40	; 64
     804:	e0 cf       	rjmp	.-64     	; 0x7c6 <__vector_18+0x3c>

00000806 <__vector_19>:
/**
 * @brief   USART0 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_TX_VECT) {
     806:	1f 92       	push	r1
     808:	0f 92       	push	r0
     80a:	0f b6       	in	r0, 0x3f	; 63
     80c:	0f 92       	push	r0
     80e:	11 24       	eor	r1, r1
     810:	2f 93       	push	r18
     812:	3f 93       	push	r19
     814:	4f 93       	push	r20
     816:	5f 93       	push	r21
     818:	6f 93       	push	r22
     81a:	7f 93       	push	r23
     81c:	8f 93       	push	r24
     81e:	9f 93       	push	r25
     820:	af 93       	push	r26
     822:	bf 93       	push	r27
     824:	ef 93       	push	r30
     826:	ff 93       	push	r31
  msg_t b;

  OSAL_IRQ_PROLOGUE();
     828:	81 e0       	ldi	r24, 0x01	; 1
     82a:	80 93 eb 06 	sts	0x06EB, r24	; 0x8006eb <__avr_in_isr>

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
     82e:	88 e5       	ldi	r24, 0x58	; 88
     830:	96 e0       	ldi	r25, 0x06	; 6
     832:	1f df       	rcall	.-450    	; 0x672 <sdRequestDataI>
  osalSysUnlockFromISR();
  if (b < MSG_OK)
     834:	97 fd       	sbrc	r25, 7
     836:	18 c0       	rjmp	.+48     	; 0x868 <__vector_19+0x62>
    UCSR0B &= ~(1 << UDRIE0);
  else
    UDR0 = b;
     838:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>

  OSAL_IRQ_EPILOGUE();
     83c:	10 92 eb 06 	sts	0x06EB, r1	; 0x8006eb <__avr_in_isr>
     840:	5f d2       	rcall	.+1214   	; 0xd00 <chSchIsPreemptionRequired>
     842:	81 11       	cpse	r24, r1
     844:	6d d2       	rcall	.+1242   	; 0xd20 <chSchDoPreemption>
}
     846:	ff 91       	pop	r31
     848:	ef 91       	pop	r30
     84a:	bf 91       	pop	r27
     84c:	af 91       	pop	r26
     84e:	9f 91       	pop	r25
     850:	8f 91       	pop	r24
     852:	7f 91       	pop	r23
     854:	6f 91       	pop	r22
     856:	5f 91       	pop	r21
     858:	4f 91       	pop	r20
     85a:	3f 91       	pop	r19
     85c:	2f 91       	pop	r18
     85e:	0f 90       	pop	r0
     860:	0f be       	out	0x3f, r0	; 63
     862:	0f 90       	pop	r0
     864:	1f 90       	pop	r1
     866:	18 95       	reti

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
  osalSysUnlockFromISR();
  if (b < MSG_OK)
    UCSR0B &= ~(1 << UDRIE0);
     868:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     86c:	8f 7d       	andi	r24, 0xDF	; 223
     86e:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     872:	e4 cf       	rjmp	.-56     	; 0x83c <__vector_19+0x36>

00000874 <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if AVR_SERIAL_USE_USART0
  sdObjectInit(&SD1, NULL, notify1);
     874:	4f eb       	ldi	r20, 0xBF	; 191
     876:	53 e0       	ldi	r21, 0x03	; 3
     878:	70 e0       	ldi	r23, 0x00	; 0
     87a:	60 e0       	ldi	r22, 0x00	; 0
     87c:	88 e5       	ldi	r24, 0x58	; 88
     87e:	96 e0       	ldi	r25, 0x06	; 6
     880:	9c ce       	rjmp	.-712    	; 0x5ba <sdObjectInit>

00000882 <sd_lld_start>:
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
     882:	61 15       	cp	r22, r1
     884:	71 05       	cpc	r23, r1
     886:	21 f0       	breq	.+8      	; 0x890 <sd_lld_start+0xe>
    config = &default_config;

#if AVR_SERIAL_USE_USART0
  if (&SD1 == sdp) {
     888:	88 55       	subi	r24, 0x58	; 88
     88a:	96 40       	sbci	r25, 0x06	; 6
     88c:	89 f0       	breq	.+34     	; 0x8b0 <sd_lld_start+0x2e>
  if (&SD2 == sdp) {
    usart1_init(config);
    return;
  }
#endif
}
     88e:	08 95       	ret

  if (config == NULL)
    config = &default_config;

#if AVR_SERIAL_USE_USART0
  if (&SD1 == sdp) {
     890:	88 55       	subi	r24, 0x58	; 88
     892:	96 40       	sbci	r25, 0x06	; 6
     894:	e1 f7       	brne	.-8      	; 0x88e <sd_lld_start+0xc>
 */
static void usart0_init(const SerialConfig *config) {

  uint8_t ucsr0c;

  UBRR0L = config->sc_brr;
     896:	83 e3       	ldi	r24, 0x33	; 51
     898:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
  UBRR0H = (config->sc_brr >> 8) & 0x0f;
     89c:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
  UCSR0A = (1 << U2X0);
     8a0:	82 e0       	ldi	r24, 0x02	; 2
     8a2:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
     8a6:	88 e9       	ldi	r24, 0x98	; 152
     8a8:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
    UCSR0B |= (1 << UCSZ02);
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_8:
  default:
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
     8ac:	86 e0       	ldi	r24, 0x06	; 6
     8ae:	1c c0       	rjmp	.+56     	; 0x8e8 <sd_lld_start+0x66>
 */
static void usart0_init(const SerialConfig *config) {

  uint8_t ucsr0c;

  UBRR0L = config->sc_brr;
     8b0:	fb 01       	movw	r30, r22
     8b2:	80 81       	ld	r24, Z
     8b4:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
  UBRR0H = (config->sc_brr >> 8) & 0x0f;
     8b8:	81 81       	ldd	r24, Z+1	; 0x01
     8ba:	8f 70       	andi	r24, 0x0F	; 15
     8bc:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
  UCSR0A = (1 << U2X0);
     8c0:	82 e0       	ldi	r24, 0x02	; 2
     8c2:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
     8c6:	88 e9       	ldi	r24, 0x98	; 152
     8c8:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
  switch (config->sc_bits_per_char) {
     8cc:	82 81       	ldd	r24, Z+2	; 0x02
     8ce:	81 30       	cpi	r24, 0x01	; 1
     8d0:	91 f0       	breq	.+36     	; 0x8f6 <sd_lld_start+0x74>
     8d2:	78 f0       	brcs	.+30     	; 0x8f2 <sd_lld_start+0x70>
     8d4:	82 30       	cpi	r24, 0x02	; 2
     8d6:	59 f0       	breq	.+22     	; 0x8ee <sd_lld_start+0x6c>
     8d8:	84 30       	cpi	r24, 0x04	; 4
     8da:	41 f7       	brne	.-48     	; 0x8ac <sd_lld_start+0x2a>
    break;
  case USART_CHAR_SIZE_7:
    ucsr0c = (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_9:
    UCSR0B |= (1 << UCSZ02);
     8dc:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     8e0:	84 60       	ori	r24, 0x04	; 4
     8e2:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
     8e6:	86 e0       	ldi	r24, 0x06	; 6
  }

#if defined(__AVR_ATmega162__)
  UCSR0C = (1 << URSEL0) | ucsr0c;
#else
  UCSR0C = ucsr0c;
     8e8:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
     8ec:	08 95       	ret
    break;
  case USART_CHAR_SIZE_6:
    ucsr0c = (1 << UCSZ00);
    break;
  case USART_CHAR_SIZE_7:
    ucsr0c = (1 << UCSZ01);
     8ee:	84 e0       	ldi	r24, 0x04	; 4
     8f0:	fb cf       	rjmp	.-10     	; 0x8e8 <sd_lld_start+0x66>
  UBRR0H = (config->sc_brr >> 8) & 0x0f;
  UCSR0A = (1 << U2X0);
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
  switch (config->sc_bits_per_char) {
  case USART_CHAR_SIZE_5:
    ucsr0c = 0;
     8f2:	80 e0       	ldi	r24, 0x00	; 0
     8f4:	f9 cf       	rjmp	.-14     	; 0x8e8 <sd_lld_start+0x66>
    break;
  case USART_CHAR_SIZE_6:
    ucsr0c = (1 << UCSZ00);
     8f6:	82 e0       	ldi	r24, 0x02	; 2
     8f8:	f7 cf       	rjmp	.-18     	; 0x8e8 <sd_lld_start+0x66>

000008fa <chSysInit>:
  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    ch_delta_list_t *dlp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
     8fa:	cf 93       	push	r28
     8fc:	df 93       	push	r29
     8fe:	c1 ea       	ldi	r28, 0xA1	; 161
     900:	d6 e0       	ldi	r29, 0x06	; 6
     902:	81 e0       	ldi	r24, 0x01	; 1
     904:	88 83       	st	Y, r24
     906:	1a 82       	std	Y+2, r1	; 0x02
     908:	19 82       	std	Y+1, r1	; 0x01
     90a:	32 d6       	rcall	.+3172   	; 0x1570 <__core_init>
     90c:	61 d6       	rcall	.+3266   	; 0x15d0 <__heap_init>
     90e:	6e e1       	ldi	r22, 0x1E	; 30
     910:	71 e0       	ldi	r23, 0x01	; 1
     912:	84 ea       	ldi	r24, 0xA4	; 164
     914:	96 e0       	ldi	r25, 0x06	; 6
     916:	53 d2       	rcall	.+1190   	; 0xdbe <chInstanceObjectInit>
     918:	82 e0       	ldi	r24, 0x02	; 2
     91a:	88 83       	st	Y, r24
     91c:	78 94       	sei
     91e:	df 91       	pop	r29
     920:	cf 91       	pop	r28
     922:	08 95       	ret

00000924 <chSysTimerHandlerI>:
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
     924:	68 c0       	rjmp	.+208    	; 0x9f6 <chVTDoTickI>

00000926 <chVTDoSetI>:
  } while (dlp != &vtlp->dlist);

  chDbgAssert(false, "timer not in list");

  return (sysinterval_t)-1;
}
     926:	cf 93       	push	r28
     928:	df 93       	push	r29
     92a:	dc 01       	movw	r26, r24
     92c:	19 96       	adiw	r26, 0x09	; 9
     92e:	3c 93       	st	X, r19
     930:	2e 93       	st	-X, r18
     932:	18 97       	sbiw	r26, 0x08	; 8
     934:	17 96       	adiw	r26, 0x07	; 7
     936:	5c 93       	st	X, r21
     938:	4e 93       	st	-X, r20
     93a:	16 97       	sbiw	r26, 0x06	; 6
     93c:	1b 96       	adiw	r26, 0x0b	; 11
     93e:	1c 92       	st	X, r1
     940:	1e 92       	st	-X, r1
     942:	1a 97       	sbiw	r26, 0x0a	; 10
     944:	e0 91 ab 06 	lds	r30, 0x06AB	; 0x8006ab <ch0+0x7>
     948:	f0 91 ac 06 	lds	r31, 0x06AC	; 0x8006ac <ch0+0x8>
     94c:	24 81       	ldd	r18, Z+4	; 0x04
     94e:	35 81       	ldd	r19, Z+5	; 0x05
     950:	26 17       	cp	r18, r22
     952:	37 07       	cpc	r19, r23
     954:	50 f4       	brcc	.+20     	; 0x96a <chVTDoSetI+0x44>
     956:	62 1b       	sub	r22, r18
     958:	73 0b       	sbc	r23, r19
     95a:	01 90       	ld	r0, Z+
     95c:	f0 81       	ld	r31, Z
     95e:	e0 2d       	mov	r30, r0
     960:	24 81       	ldd	r18, Z+4	; 0x04
     962:	35 81       	ldd	r19, Z+5	; 0x05
     964:	26 17       	cp	r18, r22
     966:	37 07       	cpc	r19, r23
     968:	b0 f3       	brcs	.-20     	; 0x956 <chVTDoSetI+0x30>
     96a:	15 96       	adiw	r26, 0x05	; 5
     96c:	7c 93       	st	X, r23
     96e:	6e 93       	st	-X, r22
     970:	14 97       	sbiw	r26, 0x04	; 4
     972:	11 96       	adiw	r26, 0x01	; 1
     974:	fc 93       	st	X, r31
     976:	ee 93       	st	-X, r30
     978:	c2 81       	ldd	r28, Z+2	; 0x02
     97a:	d3 81       	ldd	r29, Z+3	; 0x03
     97c:	13 96       	adiw	r26, 0x03	; 3
     97e:	dc 93       	st	X, r29
     980:	ce 93       	st	-X, r28
     982:	12 97       	sbiw	r26, 0x02	; 2
     984:	b9 83       	std	Y+1, r27	; 0x01
     986:	a8 83       	st	Y, r26
     988:	b3 83       	std	Z+3, r27	; 0x03
     98a:	a2 83       	std	Z+2, r26	; 0x02
     98c:	84 81       	ldd	r24, Z+4	; 0x04
     98e:	95 81       	ldd	r25, Z+5	; 0x05
     990:	86 1b       	sub	r24, r22
     992:	97 0b       	sbc	r25, r23
     994:	95 83       	std	Z+5, r25	; 0x05
     996:	84 83       	std	Z+4, r24	; 0x04
     998:	8f ef       	ldi	r24, 0xFF	; 255
     99a:	9f ef       	ldi	r25, 0xFF	; 255
     99c:	90 93 b0 06 	sts	0x06B0, r25	; 0x8006b0 <ch0+0xc>
     9a0:	80 93 af 06 	sts	0x06AF, r24	; 0x8006af <ch0+0xb>
     9a4:	df 91       	pop	r29
     9a6:	cf 91       	pop	r28
     9a8:	08 95       	ret

000009aa <chVTDoResetI>:
     9aa:	cf 93       	push	r28
     9ac:	df 93       	push	r29
     9ae:	fc 01       	movw	r30, r24
     9b0:	a0 81       	ld	r26, Z
     9b2:	b1 81       	ldd	r27, Z+1	; 0x01
     9b4:	14 96       	adiw	r26, 0x04	; 4
     9b6:	8d 91       	ld	r24, X+
     9b8:	9c 91       	ld	r25, X
     9ba:	15 97       	sbiw	r26, 0x05	; 5
     9bc:	24 81       	ldd	r18, Z+4	; 0x04
     9be:	35 81       	ldd	r19, Z+5	; 0x05
     9c0:	82 0f       	add	r24, r18
     9c2:	93 1f       	adc	r25, r19
     9c4:	15 96       	adiw	r26, 0x05	; 5
     9c6:	9c 93       	st	X, r25
     9c8:	8e 93       	st	-X, r24
     9ca:	14 97       	sbiw	r26, 0x04	; 4
     9cc:	c2 81       	ldd	r28, Z+2	; 0x02
     9ce:	d3 81       	ldd	r29, Z+3	; 0x03
     9d0:	b9 83       	std	Y+1, r27	; 0x01
     9d2:	a8 83       	st	Y, r26
     9d4:	a0 81       	ld	r26, Z
     9d6:	b1 81       	ldd	r27, Z+1	; 0x01
     9d8:	13 96       	adiw	r26, 0x03	; 3
     9da:	dc 93       	st	X, r29
     9dc:	ce 93       	st	-X, r28
     9de:	12 97       	sbiw	r26, 0x02	; 2
     9e0:	11 82       	std	Z+1, r1	; 0x01
     9e2:	10 82       	st	Z, r1
     9e4:	8f ef       	ldi	r24, 0xFF	; 255
     9e6:	9f ef       	ldi	r25, 0xFF	; 255
     9e8:	90 93 b0 06 	sts	0x06B0, r25	; 0x8006b0 <ch0+0xc>
     9ec:	80 93 af 06 	sts	0x06AF, r24	; 0x8006af <ch0+0xb>
     9f0:	df 91       	pop	r29
     9f2:	cf 91       	pop	r28
     9f4:	08 95       	ret

000009f6 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
     9f6:	0f 93       	push	r16
     9f8:	1f 93       	push	r17
     9fa:	cf 93       	push	r28
     9fc:	df 93       	push	r29
  virtual_timers_list_t *vtlp = &currcore->vtlist;

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime++;
     9fe:	80 91 b1 06 	lds	r24, 0x06B1	; 0x8006b1 <ch0+0xd>
     a02:	90 91 b2 06 	lds	r25, 0x06B2	; 0x8006b2 <ch0+0xe>
     a06:	01 96       	adiw	r24, 0x01	; 1
     a08:	90 93 b2 06 	sts	0x06B2, r25	; 0x8006b2 <ch0+0xe>
     a0c:	80 93 b1 06 	sts	0x06B1, r24	; 0x8006b1 <ch0+0xd>
 *
 * @notapi
 */
static inline bool ch_dlist_notempty(ch_delta_list_t *dlhp) {

  return (bool)(dlhp != dlhp->next);
     a10:	c0 91 ab 06 	lds	r28, 0x06AB	; 0x8006ab <ch0+0x7>
     a14:	d0 91 ac 06 	lds	r29, 0x06AC	; 0x8006ac <ch0+0x8>
  if (ch_dlist_notempty(&vtlp->dlist)) {
     a18:	86 e0       	ldi	r24, 0x06	; 6
     a1a:	cb 3a       	cpi	r28, 0xAB	; 171
     a1c:	d8 07       	cpc	r29, r24
     a1e:	41 f1       	breq	.+80     	; 0xa70 <chVTDoTickI+0x7a>
    /* The list is not empty, processing elements on top.*/
    --vtlp->dlist.next->delta;
     a20:	8c 81       	ldd	r24, Y+4	; 0x04
     a22:	9d 81       	ldd	r25, Y+5	; 0x05
     a24:	01 97       	sbiw	r24, 0x01	; 1
     a26:	9d 83       	std	Y+5, r25	; 0x05
     a28:	8c 83       	std	Y+4, r24	; 0x04
  dlp->delta -= delta;

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
     a2a:	0f ef       	ldi	r16, 0xFF	; 255
     a2c:	1f ef       	ldi	r17, 0xFF	; 255
    while (vtlp->dlist.next->delta == (sysinterval_t)0) {
     a2e:	1e c0       	rjmp	.+60     	; 0xa6c <chVTDoTickI+0x76>
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {

  dlp->prev->next = dlp->next;
     a30:	ea 81       	ldd	r30, Y+2	; 0x02
     a32:	fb 81       	ldd	r31, Y+3	; 0x03
     a34:	88 81       	ld	r24, Y
     a36:	99 81       	ldd	r25, Y+1	; 0x01
     a38:	91 83       	std	Z+1, r25	; 0x01
     a3a:	80 83       	st	Z, r24
  dlp->next->prev = dlp->prev;
     a3c:	a8 81       	ld	r26, Y
     a3e:	b9 81       	ldd	r27, Y+1	; 0x01
     a40:	13 96       	adiw	r26, 0x03	; 3
     a42:	fc 93       	st	X, r31
     a44:	ee 93       	st	-X, r30
     a46:	12 97       	sbiw	r26, 0x02	; 2
      /* Triggered timer.*/
      vtp = (virtual_timer_t *)vtlp->dlist.next;

      /* Removing the element from the delta list, marking it as not armed.*/
      (void) ch_dlist_dequeue(&vtp->dlist);
      vtp->dlist.next = NULL;
     a48:	19 82       	std	Y+1, r1	; 0x01
     a4a:	18 82       	st	Y, r1

      chSysUnlockFromISR();
      vtp->func(vtp, vtp->par);
     a4c:	68 85       	ldd	r22, Y+8	; 0x08
     a4e:	79 85       	ldd	r23, Y+9	; 0x09
     a50:	ee 81       	ldd	r30, Y+6	; 0x06
     a52:	ff 81       	ldd	r31, Y+7	; 0x07
     a54:	ce 01       	movw	r24, r28
     a56:	09 95       	icall
      chSysLockFromISR();

      /* If a reload is defined the timer needs to be restarted.*/
      if (vtp->reload > (sysinterval_t)0) {
     a58:	8a 85       	ldd	r24, Y+10	; 0x0a
     a5a:	9b 85       	ldd	r25, Y+11	; 0x0b
     a5c:	00 97       	sbiw	r24, 0x00	; 0
     a5e:	69 f4       	brne	.+26     	; 0xa7a <chVTDoTickI+0x84>
     a60:	c0 91 ab 06 	lds	r28, 0x06AB	; 0x8006ab <ch0+0x7>
     a64:	d0 91 ac 06 	lds	r29, 0x06AC	; 0x8006ac <ch0+0x8>
     a68:	8c 81       	ldd	r24, Y+4	; 0x04
     a6a:	9d 81       	ldd	r25, Y+5	; 0x05
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime++;
  if (ch_dlist_notempty(&vtlp->dlist)) {
    /* The list is not empty, processing elements on top.*/
    --vtlp->dlist.next->delta;
    while (vtlp->dlist.next->delta == (sysinterval_t)0) {
     a6c:	89 2b       	or	r24, r25
     a6e:	01 f3       	breq	.-64     	; 0xa30 <chVTDoTickI+0x3a>
  vtp->dlist.delta -= nowdelta;

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     a70:	df 91       	pop	r29
     a72:	cf 91       	pop	r28
     a74:	1f 91       	pop	r17
     a76:	0f 91       	pop	r16
     a78:	08 95       	ret
     a7a:	e0 91 ab 06 	lds	r30, 0x06AB	; 0x8006ab <ch0+0x7>
     a7e:	f0 91 ac 06 	lds	r31, 0x06AC	; 0x8006ac <ch0+0x8>
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
     a82:	24 81       	ldd	r18, Z+4	; 0x04
     a84:	35 81       	ldd	r19, Z+5	; 0x05
     a86:	28 17       	cp	r18, r24
     a88:	39 07       	cpc	r19, r25
     a8a:	50 f4       	brcc	.+20     	; 0xaa0 <chVTDoTickI+0xaa>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
     a8c:	82 1b       	sub	r24, r18
     a8e:	93 0b       	sbc	r25, r19
    dlp = dlp->next;
     a90:	01 90       	ld	r0, Z+
     a92:	f0 81       	ld	r31, Z
     a94:	e0 2d       	mov	r30, r0
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
     a96:	24 81       	ldd	r18, Z+4	; 0x04
     a98:	35 81       	ldd	r19, Z+5	; 0x05
     a9a:	28 17       	cp	r18, r24
     a9c:	39 07       	cpc	r19, r25
     a9e:	b0 f3       	brcs	.-20     	; 0xa8c <chVTDoTickI+0x96>
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {

  dlp->delta      = delta;
     aa0:	9d 83       	std	Y+5, r25	; 0x05
     aa2:	8c 83       	std	Y+4, r24	; 0x04
  dlp->next       = dlhp;
     aa4:	f9 83       	std	Y+1, r31	; 0x01
     aa6:	e8 83       	st	Y, r30
  dlp->prev       = dlp->next->prev;
     aa8:	a2 81       	ldd	r26, Z+2	; 0x02
     aaa:	b3 81       	ldd	r27, Z+3	; 0x03
     aac:	bb 83       	std	Y+3, r27	; 0x03
     aae:	aa 83       	std	Y+2, r26	; 0x02
  dlp->prev->next = dlp;
     ab0:	cd 93       	st	X+, r28
     ab2:	dc 93       	st	X, r29
  dlhp->prev      = dlp;
     ab4:	d3 83       	std	Z+3, r29	; 0x03
     ab6:	c2 83       	std	Z+2, r28	; 0x02

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
     ab8:	24 81       	ldd	r18, Z+4	; 0x04
     aba:	35 81       	ldd	r19, Z+5	; 0x05
     abc:	28 1b       	sub	r18, r24
     abe:	39 0b       	sbc	r19, r25
     ac0:	35 83       	std	Z+5, r19	; 0x05
     ac2:	24 83       	std	Z+4, r18	; 0x04

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
     ac4:	10 93 b0 06 	sts	0x06B0, r17	; 0x8006b0 <ch0+0xc>
     ac8:	00 93 af 06 	sts	0x06AF, r16	; 0x8006af <ch0+0xb>
     acc:	c9 cf       	rjmp	.-110    	; 0xa60 <chVTDoTickI+0x6a>

00000ace <__sch_wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
     ace:	cf 93       	push	r28
     ad0:	df 93       	push	r29
     ad2:	db 01       	movw	r26, r22
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
     ad4:	1f 96       	adiw	r26, 0x0f	; 15
     ad6:	8c 91       	ld	r24, X
     ad8:	1f 97       	sbiw	r26, 0x0f	; 15
     ada:	84 30       	cpi	r24, 0x04	; 4
     adc:	f1 f1       	breq	.+124    	; 0xb5a <__sch_wakeup+0x8c>
     ade:	80 f5       	brcc	.+96     	; 0xb40 <__sch_wakeup+0x72>
     ae0:	88 23       	and	r24, r24
     ae2:	59 f1       	breq	.+86     	; 0xb3a <__sch_wakeup+0x6c>
     ae4:	83 30       	cpi	r24, 0x03	; 3
     ae6:	31 f4       	brne	.+12     	; 0xaf4 <__sch_wakeup+0x26>
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
     ae8:	52 96       	adiw	r26, 0x12	; 18
     aea:	ed 91       	ld	r30, X+
     aec:	fc 91       	ld	r31, X
     aee:	53 97       	sbiw	r26, 0x13	; 19
     af0:	11 82       	std	Z+1, r1	; 0x01
     af2:	10 82       	st	Z, r1
    /* Any other state, nothing to do.*/
    break;
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
     af4:	8f ef       	ldi	r24, 0xFF	; 255
     af6:	9f ef       	ldi	r25, 0xFF	; 255
     af8:	53 96       	adiw	r26, 0x13	; 19
     afa:	9c 93       	st	X, r25
     afc:	8e 93       	st	-X, r24
     afe:	52 97       	sbiw	r26, 0x12	; 18

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     b00:	1f 96       	adiw	r26, 0x0f	; 15
     b02:	1c 92       	st	X, r1
     b04:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     b06:	1b 96       	adiw	r26, 0x0b	; 11
     b08:	ed 91       	ld	r30, X+
     b0a:	fc 91       	ld	r31, X
     b0c:	1c 97       	sbiw	r26, 0x0c	; 12
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio >= p->prio));
     b0e:	14 96       	adiw	r26, 0x04	; 4
     b10:	9c 91       	ld	r25, X
     b12:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     b14:	01 90       	ld	r0, Z+
     b16:	f0 81       	ld	r31, Z
     b18:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     b1a:	84 81       	ldd	r24, Z+4	; 0x04
     b1c:	89 17       	cp	r24, r25
     b1e:	d0 f7       	brcc	.-12     	; 0xb14 <__sch_wakeup+0x46>

  /* Insertion on prev.*/
  p->next       = pqp;
     b20:	11 96       	adiw	r26, 0x01	; 1
     b22:	fc 93       	st	X, r31
     b24:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     b26:	c2 81       	ldd	r28, Z+2	; 0x02
     b28:	d3 81       	ldd	r29, Z+3	; 0x03
     b2a:	13 96       	adiw	r26, 0x03	; 3
     b2c:	dc 93       	st	X, r29
     b2e:	ce 93       	st	-X, r28
     b30:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     b32:	b9 83       	std	Y+1, r27	; 0x01
     b34:	a8 83       	st	Y, r26
  pqp->prev     = p;
     b36:	b3 83       	std	Z+3, r27	; 0x03
     b38:	a2 83       	std	Z+2, r26	; 0x02
  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
  chSysUnlockFromISR();

  return;
}
     b3a:	df 91       	pop	r29
     b3c:	cf 91       	pop	r28
     b3e:	08 95       	ret
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
     b40:	87 30       	cpi	r24, 0x07	; 7
     b42:	59 f0       	breq	.+22     	; 0xb5a <__sch_wakeup+0x8c>
     b44:	8c 30       	cpi	r24, 0x0C	; 12
     b46:	49 f0       	breq	.+18     	; 0xb5a <__sch_wakeup+0x8c>
     b48:	85 30       	cpi	r24, 0x05	; 5
     b4a:	a1 f6       	brne	.-88     	; 0xaf4 <__sch_wakeup+0x26>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
     b4c:	52 96       	adiw	r26, 0x12	; 18
     b4e:	ed 91       	ld	r30, X+
     b50:	fc 91       	ld	r31, X
     b52:	53 97       	sbiw	r26, 0x13	; 19
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
     b54:	84 81       	ldd	r24, Z+4	; 0x04
     b56:	8f 5f       	subi	r24, 0xFF	; 255
     b58:	84 83       	std	Z+4, r24	; 0x04
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {

  p->prev->next = p->next;
     b5a:	12 96       	adiw	r26, 0x02	; 2
     b5c:	ed 91       	ld	r30, X+
     b5e:	fc 91       	ld	r31, X
     b60:	13 97       	sbiw	r26, 0x03	; 3
     b62:	8d 91       	ld	r24, X+
     b64:	9c 91       	ld	r25, X
     b66:	11 97       	sbiw	r26, 0x01	; 1
     b68:	91 83       	std	Z+1, r25	; 0x01
     b6a:	80 83       	st	Z, r24
  p->next->prev = p->prev;
     b6c:	cd 91       	ld	r28, X+
     b6e:	dc 91       	ld	r29, X
     b70:	11 97       	sbiw	r26, 0x01	; 1
     b72:	fb 83       	std	Y+3, r31	; 0x03
     b74:	ea 83       	std	Y+2, r30	; 0x02
     b76:	be cf       	rjmp	.-132    	; 0xaf4 <__sch_wakeup+0x26>

00000b78 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
     b78:	cf 93       	push	r28
     b7a:	df 93       	push	r29
     b7c:	dc 01       	movw	r26, r24

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     b7e:	1f 96       	adiw	r26, 0x0f	; 15
     b80:	1c 92       	st	X, r1
     b82:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     b84:	1b 96       	adiw	r26, 0x0b	; 11
     b86:	ed 91       	ld	r30, X+
     b88:	fc 91       	ld	r31, X
     b8a:	1c 97       	sbiw	r26, 0x0c	; 12
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio >= p->prio));
     b8c:	14 96       	adiw	r26, 0x04	; 4
     b8e:	8c 91       	ld	r24, X
     b90:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     b92:	01 90       	ld	r0, Z+
     b94:	f0 81       	ld	r31, Z
     b96:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     b98:	94 81       	ldd	r25, Z+4	; 0x04
     b9a:	98 17       	cp	r25, r24
     b9c:	d0 f7       	brcc	.-12     	; 0xb92 <chSchReadyI+0x1a>

  /* Insertion on prev.*/
  p->next       = pqp;
     b9e:	11 96       	adiw	r26, 0x01	; 1
     ba0:	fc 93       	st	X, r31
     ba2:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     ba4:	c2 81       	ldd	r28, Z+2	; 0x02
     ba6:	d3 81       	ldd	r29, Z+3	; 0x03
     ba8:	13 96       	adiw	r26, 0x03	; 3
     baa:	dc 93       	st	X, r29
     bac:	ce 93       	st	-X, r28
     bae:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     bb0:	b9 83       	std	Y+1, r27	; 0x01
     bb2:	a8 83       	st	Y, r26
  pqp->prev     = p;
     bb4:	b3 83       	std	Z+3, r27	; 0x03
     bb6:	a2 83       	std	Z+2, r26	; 0x02
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
}
     bb8:	cd 01       	movw	r24, r26
     bba:	df 91       	pop	r29
     bbc:	cf 91       	pop	r28
     bbe:	08 95       	ret

00000bc0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
     bc0:	cf 93       	push	r28
     bc2:	df 93       	push	r29
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     bc4:	e4 ea       	ldi	r30, 0xA4	; 164
     bc6:	f6 e0       	ldi	r31, 0x06	; 6
     bc8:	65 81       	ldd	r22, Z+5	; 0x05
     bca:	76 81       	ldd	r23, Z+6	; 0x06

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
  chDbgAssert(otp->owner == oip, "invalid core");

  /* New state.*/
  otp->state = newstate;
     bcc:	db 01       	movw	r26, r22
     bce:	1f 96       	adiw	r26, 0x0f	; 15
     bd0:	8c 93       	st	X, r24
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
     bd2:	80 81       	ld	r24, Z
     bd4:	91 81       	ldd	r25, Z+1	; 0x01

  pqp->next       = p->next;
     bd6:	ec 01       	movw	r28, r24
     bd8:	a8 81       	ld	r26, Y
     bda:	b9 81       	ldd	r27, Y+1	; 0x01
     bdc:	b1 83       	std	Z+1, r27	; 0x01
     bde:	a0 83       	st	Z, r26
  pqp->next->prev = pqp;
     be0:	13 96       	adiw	r26, 0x03	; 3
     be2:	fc 93       	st	X, r31
     be4:	ee 93       	st	-X, r30
     be6:	12 97       	sbiw	r26, 0x02	; 2
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
     be8:	21 e0       	ldi	r18, 0x01	; 1
     bea:	2f 87       	std	Y+15, r18	; 0x0f
  __instance_set_currthread(oip, ntp);
     bec:	96 83       	std	Z+6, r25	; 0x06
     bee:	85 83       	std	Z+5, r24	; 0x05
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
     bf0:	fc d4       	rcall	.+2552   	; 0x15ea <_port_switch>
}
     bf2:	df 91       	pop	r29
     bf4:	cf 91       	pop	r28
     bf6:	08 95       	ret

00000bf8 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
     bf8:	ff 92       	push	r15
     bfa:	0f 93       	push	r16
     bfc:	1f 93       	push	r17
     bfe:	cf 93       	push	r28
     c00:	df 93       	push	r29
     c02:	cd b7       	in	r28, 0x3d	; 61
     c04:	de b7       	in	r29, 0x3e	; 62
     c06:	2c 97       	sbiw	r28, 0x0c	; 12
     c08:	0f b6       	in	r0, 0x3f	; 63
     c0a:	f8 94       	cli
     c0c:	de bf       	out	0x3e, r29	; 62
     c0e:	0f be       	out	0x3f, r0	; 63
     c10:	cd bf       	out	0x3d, r28	; 61
     c12:	f8 2e       	mov	r15, r24
  thread_t *tp = __instance_get_currthread(currcore);
     c14:	00 91 a9 06 	lds	r16, 0x06A9	; 0x8006a9 <ch0+0x5>
     c18:	10 91 aa 06 	lds	r17, 0x06AA	; 0x8006aa <ch0+0x6>

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
     c1c:	6f 3f       	cpi	r22, 0xFF	; 255
     c1e:	76 07       	cpc	r23, r22
     c20:	f1 f0       	breq	.+60     	; 0xc5e <chSchGoSleepTimeoutS+0x66>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
     c22:	98 01       	movw	r18, r16
     c24:	47 e6       	ldi	r20, 0x67	; 103
     c26:	55 e0       	ldi	r21, 0x05	; 5
     c28:	ce 01       	movw	r24, r28
     c2a:	01 96       	adiw	r24, 0x01	; 1
     c2c:	7c de       	rcall	.-776    	; 0x926 <chVTDoSetI>
    chSchGoSleepS(newstate);
     c2e:	8f 2d       	mov	r24, r15
     c30:	c7 df       	rcall	.-114    	; 0xbc0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
     c32:	89 81       	ldd	r24, Y+1	; 0x01
     c34:	9a 81       	ldd	r25, Y+2	; 0x02
     c36:	89 2b       	or	r24, r25
     c38:	19 f0       	breq	.+6      	; 0xc40 <chSchGoSleepTimeoutS+0x48>
      chVTDoResetI(&vt);
     c3a:	ce 01       	movw	r24, r28
     c3c:	01 96       	adiw	r24, 0x01	; 1
     c3e:	b5 de       	rcall	.-662    	; 0x9aa <chVTDoResetI>
  else {
    chSchGoSleepS(newstate);
  }

  return tp->u.rdymsg;
}
     c40:	f8 01       	movw	r30, r16
     c42:	82 89       	ldd	r24, Z+18	; 0x12
     c44:	93 89       	ldd	r25, Z+19	; 0x13
     c46:	2c 96       	adiw	r28, 0x0c	; 12
     c48:	0f b6       	in	r0, 0x3f	; 63
     c4a:	f8 94       	cli
     c4c:	de bf       	out	0x3e, r29	; 62
     c4e:	0f be       	out	0x3f, r0	; 63
     c50:	cd bf       	out	0x3d, r28	; 61
     c52:	df 91       	pop	r29
     c54:	cf 91       	pop	r28
     c56:	1f 91       	pop	r17
     c58:	0f 91       	pop	r16
     c5a:	ff 90       	pop	r15
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
     c5c:	08 95       	ret
     c5e:	8f 2d       	mov	r24, r15
     c60:	af df       	rcall	.-162    	; 0xbc0 <chSchGoSleepS>
     c62:	ee cf       	rjmp	.-36     	; 0xc40 <chSchGoSleepTimeoutS+0x48>

00000c64 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
     c64:	cf 93       	push	r28
     c66:	df 93       	push	r29
     c68:	dc 01       	movw	r26, r24
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     c6a:	c0 91 a9 06 	lds	r28, 0x06A9	; 0x8006a9 <ch0+0x5>
     c6e:	d0 91 aa 06 	lds	r29, 0x06AA	; 0x8006aa <ch0+0x6>
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
     c72:	53 96       	adiw	r26, 0x13	; 19
     c74:	7c 93       	st	X, r23
     c76:	6e 93       	st	-X, r22
     c78:	52 97       	sbiw	r26, 0x12	; 18
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
     c7a:	14 96       	adiw	r26, 0x04	; 4
     c7c:	2c 91       	ld	r18, X
     c7e:	14 97       	sbiw	r26, 0x04	; 4
     c80:	9c 81       	ldd	r25, Y+4	; 0x04
     c82:	92 17       	cp	r25, r18
     c84:	e8 f0       	brcs	.+58     	; 0xcc0 <chSchWakeupS+0x5c>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     c86:	1f 96       	adiw	r26, 0x0f	; 15
     c88:	1c 92       	st	X, r1
     c8a:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     c8c:	1b 96       	adiw	r26, 0x0b	; 11
     c8e:	ed 91       	ld	r30, X+
     c90:	fc 91       	ld	r31, X
     c92:	1c 97       	sbiw	r26, 0x0c	; 12
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     c94:	01 90       	ld	r0, Z+
     c96:	f0 81       	ld	r31, Z
     c98:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     c9a:	84 81       	ldd	r24, Z+4	; 0x04
     c9c:	82 17       	cp	r24, r18
     c9e:	d0 f7       	brcc	.-12     	; 0xc94 <chSchWakeupS+0x30>

  /* Insertion on prev.*/
  p->next       = pqp;
     ca0:	11 96       	adiw	r26, 0x01	; 1
     ca2:	fc 93       	st	X, r31
     ca4:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     ca6:	c2 81       	ldd	r28, Z+2	; 0x02
     ca8:	d3 81       	ldd	r29, Z+3	; 0x03
     caa:	13 96       	adiw	r26, 0x03	; 3
     cac:	dc 93       	st	X, r29
     cae:	ce 93       	st	-X, r28
     cb0:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     cb2:	b9 83       	std	Y+1, r27	; 0x01
     cb4:	a8 83       	st	Y, r26
  pqp->prev     = p;
     cb6:	b3 83       	std	Z+3, r27	; 0x03
     cb8:	a2 83       	std	Z+2, r26	; 0x02
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
     cba:	df 91       	pop	r29
     cbc:	cf 91       	pop	r28
     cbe:	08 95       	ret

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     cc0:	1f 86       	std	Y+15, r1	; 0x0f

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
     cc2:	eb 85       	ldd	r30, Y+11	; 0x0b
     cc4:	fc 85       	ldd	r31, Y+12	; 0x0c
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     cc6:	01 90       	ld	r0, Z+
     cc8:	f0 81       	ld	r31, Z
     cca:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio > p->prio));
     ccc:	84 81       	ldd	r24, Z+4	; 0x04
     cce:	98 17       	cp	r25, r24
     cd0:	d0 f3       	brcs	.-12     	; 0xcc6 <chSchWakeupS+0x62>
     cd2:	cd 01       	movw	r24, r26

  /* Insertion on prev.*/
  p->next       = pqp;
     cd4:	f9 83       	std	Y+1, r31	; 0x01
     cd6:	e8 83       	st	Y, r30
  p->prev       = pqp->prev;
     cd8:	a2 81       	ldd	r26, Z+2	; 0x02
     cda:	b3 81       	ldd	r27, Z+3	; 0x03
     cdc:	bb 83       	std	Y+3, r27	; 0x03
     cde:	aa 83       	std	Y+2, r26	; 0x02
  p->prev->next = p;
     ce0:	cd 93       	st	X+, r28
     ce2:	dc 93       	st	X, r29
  pqp->prev     = p;
     ce4:	d3 83       	std	Z+3, r29	; 0x03
     ce6:	c2 83       	std	Z+2, r28	; 0x02
    if (otp->hdr.pqueue.prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    ntp->state = CH_STATE_CURRENT;
     ce8:	21 e0       	ldi	r18, 0x01	; 1
     cea:	fc 01       	movw	r30, r24
     cec:	27 87       	std	Z+15, r18	; 0x0f
    __instance_set_currthread(oip, ntp);
     cee:	90 93 aa 06 	sts	0x06AA, r25	; 0x8006aa <ch0+0x6>
     cf2:	80 93 a9 06 	sts	0x06A9, r24	; 0x8006a9 <ch0+0x5>

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
     cf6:	be 01       	movw	r22, r28
     cf8:	78 d4       	rcall	.+2288   	; 0x15ea <_port_switch>
  }
}
     cfa:	df 91       	pop	r29
     cfc:	cf 91       	pop	r28
     cfe:	08 95       	ret

00000d00 <chSchIsPreemptionRequired>:
 */
bool chSchIsPreemptionRequired(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
     d00:	a0 91 a4 06 	lds	r26, 0x06A4	; 0x8006a4 <ch0>
     d04:	b0 91 a5 06 	lds	r27, 0x06A5	; 0x8006a5 <ch0+0x1>
  tprio_t p2 = tp->hdr.pqueue.prio;
     d08:	e0 91 a9 06 	lds	r30, 0x06A9	; 0x8006a9 <ch0+0x5>
     d0c:	f0 91 aa 06 	lds	r31, 0x06AA	; 0x8006aa <ch0+0x6>
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
     d10:	81 e0       	ldi	r24, 0x01	; 1
     d12:	14 96       	adiw	r26, 0x04	; 4
     d14:	2c 91       	ld	r18, X
     d16:	94 81       	ldd	r25, Z+4	; 0x04
     d18:	92 17       	cp	r25, r18
     d1a:	08 f0       	brcs	.+2      	; 0xd1e <chSchIsPreemptionRequired+0x1e>
     d1c:	80 e0       	ldi	r24, 0x00	; 0
#endif
}
     d1e:	08 95       	ret

00000d20 <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
     d20:	cf 93       	push	r28
     d22:	df 93       	push	r29
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     d24:	a0 91 a9 06 	lds	r26, 0x06A9	; 0x8006a9 <ch0+0x5>
     d28:	b0 91 aa 06 	lds	r27, 0x06AA	; 0x8006aa <ch0+0x6>
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
     d2c:	40 91 a4 06 	lds	r20, 0x06A4	; 0x8006a4 <ch0>
     d30:	50 91 a5 06 	lds	r21, 0x06A5	; 0x8006a5 <ch0+0x1>

  pqp->next       = p->next;
     d34:	ea 01       	movw	r28, r20
     d36:	e8 81       	ld	r30, Y
     d38:	f9 81       	ldd	r31, Y+1	; 0x01
     d3a:	f0 93 a5 06 	sts	0x06A5, r31	; 0x8006a5 <ch0+0x1>
     d3e:	e0 93 a4 06 	sts	0x06A4, r30	; 0x8006a4 <ch0>
  pqp->next->prev = pqp;
     d42:	84 ea       	ldi	r24, 0xA4	; 164
     d44:	96 e0       	ldi	r25, 0x06	; 6
     d46:	93 83       	std	Z+3, r25	; 0x03
     d48:	82 83       	std	Z+2, r24	; 0x02
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
     d4a:	81 e0       	ldi	r24, 0x01	; 1
     d4c:	8f 87       	std	Y+15, r24	; 0x0f
  __instance_set_currthread(oip, ntp);
     d4e:	50 93 aa 06 	sts	0x06AA, r21	; 0x8006aa <ch0+0x6>
     d52:	40 93 a9 06 	sts	0x06A9, r20	; 0x8006a9 <ch0+0x5>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     d56:	1f 96       	adiw	r26, 0x0f	; 15
     d58:	1c 92       	st	X, r1
     d5a:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
     d5c:	1b 96       	adiw	r26, 0x0b	; 11
     d5e:	ed 91       	ld	r30, X+
     d60:	fc 91       	ld	r31, X
     d62:	1c 97       	sbiw	r26, 0x0c	; 12
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio > p->prio));
     d64:	14 96       	adiw	r26, 0x04	; 4
     d66:	2c 91       	ld	r18, X
     d68:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     d6a:	01 90       	ld	r0, Z+
     d6c:	f0 81       	ld	r31, Z
     d6e:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio > p->prio));
     d70:	94 81       	ldd	r25, Z+4	; 0x04
     d72:	29 17       	cp	r18, r25
     d74:	d0 f3       	brcs	.-12     	; 0xd6a <chSchDoPreemption+0x4a>

  /* Insertion on prev.*/
  p->next       = pqp;
     d76:	11 96       	adiw	r26, 0x01	; 1
     d78:	fc 93       	st	X, r31
     d7a:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     d7c:	82 81       	ldd	r24, Z+2	; 0x02
     d7e:	93 81       	ldd	r25, Z+3	; 0x03
     d80:	13 96       	adiw	r26, 0x03	; 3
     d82:	9c 93       	st	X, r25
     d84:	8e 93       	st	-X, r24
     d86:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     d88:	ec 01       	movw	r28, r24
     d8a:	b9 83       	std	Y+1, r27	; 0x01
     d8c:	a8 83       	st	Y, r26
  pqp->prev     = p;
     d8e:	b3 83       	std	Z+3, r27	; 0x03
     d90:	a2 83       	std	Z+2, r26	; 0x02
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
     d92:	bd 01       	movw	r22, r26
     d94:	ca 01       	movw	r24, r20
     d96:	29 d4       	rcall	.+2130   	; 0x15ea <_port_switch>
}
     d98:	df 91       	pop	r29
     d9a:	cf 91       	pop	r28
     d9c:	08 95       	ret

00000d9e <chSchRescheduleS>:

  chDbgCheckClassS();

  /* Note, we are favoring the path where the reschedule is necessary
     because higher priority threads are ready.*/
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
     d9e:	a0 91 a4 06 	lds	r26, 0x06A4	; 0x8006a4 <ch0>
     da2:	b0 91 a5 06 	lds	r27, 0x06A5	; 0x8006a5 <ch0+0x1>
     da6:	e0 91 a9 06 	lds	r30, 0x06A9	; 0x8006a9 <ch0+0x5>
     daa:	f0 91 aa 06 	lds	r31, 0x06AA	; 0x8006aa <ch0+0x6>
     dae:	14 96       	adiw	r26, 0x04	; 4
     db0:	9c 91       	ld	r25, X
     db2:	84 81       	ldd	r24, Z+4	; 0x04
     db4:	89 17       	cp	r24, r25
     db6:	08 f0       	brcs	.+2      	; 0xdba <chSchRescheduleS+0x1c>
    __sch_reschedule_ahead();
  }
}
     db8:	08 95       	ret
  chDbgCheckClassS();

  /* Note, we are favoring the path where the reschedule is necessary
     because higher priority threads are ready.*/
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
    __sch_reschedule_ahead();
     dba:	b2 cf       	rjmp	.-156    	; 0xd20 <chSchDoPreemption>

00000dbc <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
     dbc:	ff cf       	rjmp	.-2      	; 0xdbc <__idle_thread>

00000dbe <chInstanceObjectInit>:
 * @param[in] oicp      pointer to the @p os_instance_config_t structure
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
     dbe:	df 92       	push	r13
     dc0:	ef 92       	push	r14
     dc2:	ff 92       	push	r15
     dc4:	0f 93       	push	r16
     dc6:	1f 93       	push	r17
     dc8:	cf 93       	push	r28
     dca:	df 93       	push	r29
     dcc:	cd b7       	in	r28, 0x3d	; 61
     dce:	de b7       	in	r29, 0x3e	; 62
     dd0:	2b 97       	sbiw	r28, 0x0b	; 11
     dd2:	0f b6       	in	r0, 0x3f	; 63
     dd4:	f8 94       	cli
     dd6:	de bf       	out	0x3e, r29	; 62
     dd8:	0f be       	out	0x3f, r0	; 63
     dda:	cd bf       	out	0x3d, r28	; 61
     ddc:	8c 01       	movw	r16, r24
     dde:	7b 01       	movw	r14, r22
  core_id = port_get_core_id();
#else
  core_id = 0U;
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
     de0:	90 93 a3 06 	sts	0x06A3, r25	; 0x8006a3 <ch_system+0x2>
     de4:	80 93 a2 06 	sts	0x06A2, r24	; 0x8006a2 <ch_system+0x1>

  /* Core associated to this instance.*/
  oip->core_id = core_id;
     de8:	fc 01       	movw	r30, r24
     dea:	14 8e       	std	Z+28, r1	; 0x1c
     dec:	13 8e       	std	Z+27, r1	; 0x1b

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
     dee:	72 a3       	std	Z+34, r23	; 0x22
     df0:	61 a3       	std	Z+33, r22	; 0x21

  /* Port initialization for the current instance.*/
  port_init(oip);
     df2:	dd 24       	eor	r13, r13
     df4:	d3 94       	inc	r13
     df6:	d0 92 eb 06 	sts	0x06EB, r13	; 0x8006eb <__avr_in_isr>
 *
 * @notapi
 */
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {

  pqp->next = pqp;
     dfa:	91 83       	std	Z+1, r25	; 0x01
     dfc:	80 83       	st	Z, r24
  pqp->prev = pqp;
     dfe:	93 83       	std	Z+3, r25	; 0x03
     e00:	82 83       	std	Z+2, r24	; 0x02
  pqp->prio = (tprio_t)0;
     e02:	14 82       	std	Z+4, r1	; 0x04
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {

  ch_queue_init(&rp->queue);
     e04:	47 96       	adiw	r24, 0x17	; 23
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
     e06:	90 8f       	std	Z+24, r25	; 0x18
     e08:	87 8b       	std	Z+23, r24	; 0x17
  qp->prev = qp;
     e0a:	92 8f       	std	Z+26, r25	; 0x1a
     e0c:	81 8f       	std	Z+25, r24	; 0x19
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {

  rfcup->mask = (rfcu_mask_t)0;
     e0e:	15 8e       	std	Z+29, r1	; 0x1d
     e10:	16 8e       	std	Z+30, r1	; 0x1e
     e12:	17 8e       	std	Z+31, r1	; 0x1f
     e14:	10 a2       	std	Z+32, r1	; 0x20
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {

  ch_dlist_init(&vtlp->dlist);
     e16:	40 97       	sbiw	r24, 0x10	; 16
 *
 * @notapi
 */
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {

  dlhp->next  = dlhp;
     e18:	90 87       	std	Z+8, r25	; 0x08
     e1a:	87 83       	std	Z+7, r24	; 0x07
  dlhp->prev  = dlhp;
     e1c:	92 87       	std	Z+10, r25	; 0x0a
     e1e:	81 87       	std	Z+9, r24	; 0x09
  dlhp->delta = (sysinterval_t)-1;
     e20:	8f ef       	ldi	r24, 0xFF	; 255
     e22:	9f ef       	ldi	r25, 0xFF	; 255
     e24:	94 87       	std	Z+12, r25	; 0x0c
     e26:	83 87       	std	Z+11, r24	; 0x0b
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
     e28:	16 86       	std	Z+14, r1	; 0x0e
     e2a:	15 86       	std	Z+13, r1	; 0x0d
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return currcore->vtlist.systime;
     e2c:	20 91 b1 06 	lds	r18, 0x06B1	; 0x8006b1 <ch0+0xd>
     e30:	30 91 b2 06 	lds	r19, 0x06B2	; 0x8006b2 <ch0+0xe>
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
     e34:	27 87       	std	Z+15, r18	; 0x0f
     e36:	30 8b       	std	Z+16, r19	; 0x10
     e38:	11 8a       	std	Z+17, r1	; 0x11
     e3a:	12 8a       	std	Z+18, r1	; 0x12
     e3c:	13 8a       	std	Z+19, r1	; 0x13
     e3e:	14 8a       	std	Z+20, r1	; 0x14
     e40:	15 8a       	std	Z+21, r1	; 0x15
     e42:	16 8a       	std	Z+22, r1	; 0x16
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {

  sdp->panic_msg = NULL;
     e44:	ef 5b       	subi	r30, 0xBF	; 191
     e46:	ff 4f       	sbci	r31, 0xFF	; 255
     e48:	11 82       	std	Z+1, r1	; 0x01
     e4a:	10 82       	st	Z, r1
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
     e4c:	b8 01       	movw	r22, r16
     e4e:	6d 5d       	subi	r22, 0xDD	; 221
     e50:	7f 4f       	sbci	r23, 0xFF	; 255
     e52:	20 e8       	ldi	r18, 0x80	; 128
     e54:	40 e3       	ldi	r20, 0x30	; 48
     e56:	51 e0       	ldi	r21, 0x01	; 1
     e58:	c8 01       	movw	r24, r16
     e5a:	2a d0       	rcall	.+84     	; 0xeb0 <__thd_object_init>
     e5c:	f8 01       	movw	r30, r16
     e5e:	96 83       	std	Z+6, r25	; 0x06
     e60:	85 83       	std	Z+5, r24	; 0x05
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
     e62:	fc 01       	movw	r30, r24
     e64:	d7 86       	std	Z+15, r13	; 0x0f
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
     e66:	84 e2       	ldi	r24, 0x24	; 36
     e68:	91 e0       	ldi	r25, 0x01	; 1
     e6a:	9a 83       	std	Y+2, r25	; 0x02
     e6c:	89 83       	std	Y+1, r24	; 0x01
     e6e:	f7 01       	movw	r30, r14
     e70:	82 81       	ldd	r24, Z+2	; 0x02
     e72:	93 81       	ldd	r25, Z+3	; 0x03
     e74:	9c 83       	std	Y+4, r25	; 0x04
     e76:	8b 83       	std	Y+3, r24	; 0x03
     e78:	84 81       	ldd	r24, Z+4	; 0x04
     e7a:	95 81       	ldd	r25, Z+5	; 0x05
     e7c:	9e 83       	std	Y+6, r25	; 0x06
     e7e:	8d 83       	std	Y+5, r24	; 0x05
     e80:	df 82       	std	Y+7, r13	; 0x07
     e82:	8e ed       	ldi	r24, 0xDE	; 222
     e84:	96 e0       	ldi	r25, 0x06	; 6
     e86:	99 87       	std	Y+9, r25	; 0x09
     e88:	88 87       	std	Y+8, r24	; 0x08
     e8a:	1b 86       	std	Y+11, r1	; 0x0b
     e8c:	1a 86       	std	Y+10, r1	; 0x0a
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
     e8e:	ce 01       	movw	r24, r28
     e90:	01 96       	adiw	r24, 0x01	; 1
     e92:	9e d0       	rcall	.+316    	; 0xfd0 <chThdCreateI>
  }
#endif
}
     e94:	2b 96       	adiw	r28, 0x0b	; 11
     e96:	0f b6       	in	r0, 0x3f	; 63
     e98:	f8 94       	cli
     e9a:	de bf       	out	0x3e, r29	; 62
     e9c:	0f be       	out	0x3f, r0	; 63
     e9e:	cd bf       	out	0x3d, r28	; 61
     ea0:	df 91       	pop	r29
     ea2:	cf 91       	pop	r28
     ea4:	1f 91       	pop	r17
     ea6:	0f 91       	pop	r16
     ea8:	ff 90       	pop	r15
     eaa:	ef 90       	pop	r14
     eac:	df 90       	pop	r13
     eae:	08 95       	ret

00000eb0 <__thd_object_init>:
void chThdResume(thread_reference_t *trp, msg_t msg) {

  chSysLock();
  chThdResumeS(trp, msg);
  chSysUnlock();
}
     eb0:	cf 93       	push	r28
     eb2:	df 93       	push	r29
     eb4:	fb 01       	movw	r30, r22
     eb6:	24 83       	std	Z+4, r18	; 0x04
     eb8:	32 e0       	ldi	r19, 0x02	; 2
     eba:	37 87       	std	Z+15, r19	; 0x0f
     ebc:	10 8a       	std	Z+16, r1	; 0x10
     ebe:	94 87       	std	Z+12, r25	; 0x0c
     ec0:	83 87       	std	Z+11, r24	; 0x0b
     ec2:	25 8f       	std	Z+29, r18	; 0x1d
     ec4:	14 8e       	std	Z+28, r1	; 0x1c
     ec6:	13 8e       	std	Z+27, r1	; 0x1b
     ec8:	12 8e       	std	Z+26, r1	; 0x1a
     eca:	21 e0       	ldi	r18, 0x01	; 1
     ecc:	21 8b       	std	Z+17, r18	; 0x11
     ece:	56 87       	std	Z+14, r21	; 0x0e
     ed0:	45 87       	std	Z+13, r20	; 0x0d
     ed2:	9b 01       	movw	r18, r22
     ed4:	29 5f       	subi	r18, 0xF9	; 249
     ed6:	3f 4f       	sbci	r19, 0xFF	; 255
     ed8:	ac 01       	movw	r20, r24
     eda:	49 5e       	subi	r20, 0xE9	; 233
     edc:	5f 4f       	sbci	r21, 0xFF	; 255
     ede:	50 87       	std	Z+8, r21	; 0x08
     ee0:	47 83       	std	Z+7, r20	; 0x07
     ee2:	ec 01       	movw	r28, r24
     ee4:	a9 8d       	ldd	r26, Y+25	; 0x19
     ee6:	ba 8d       	ldd	r27, Y+26	; 0x1a
     ee8:	b2 87       	std	Z+10, r27	; 0x0a
     eea:	a1 87       	std	Z+9, r26	; 0x09
     eec:	2d 93       	st	X+, r18
     eee:	3c 93       	st	X, r19
     ef0:	3a 8f       	std	Y+26, r19	; 0x1a
     ef2:	29 8f       	std	Y+25, r18	; 0x19
     ef4:	cb 01       	movw	r24, r22
     ef6:	44 96       	adiw	r24, 0x14	; 20
     ef8:	95 8b       	std	Z+21, r25	; 0x15
     efa:	84 8b       	std	Z+20, r24	; 0x14
     efc:	02 96       	adiw	r24, 0x02	; 2
     efe:	97 8b       	std	Z+23, r25	; 0x17
     f00:	86 8b       	std	Z+22, r24	; 0x16
     f02:	91 8f       	std	Z+25, r25	; 0x19
     f04:	80 8f       	std	Z+24, r24	; 0x18
     f06:	cb 01       	movw	r24, r22
     f08:	df 91       	pop	r29
     f0a:	cf 91       	pop	r28
     f0c:	08 95       	ret

00000f0e <chThdCreateSuspendedI>:
     f0e:	cf 93       	push	r28
     f10:	df 93       	push	r29
     f12:	dc 01       	movw	r26, r24
     f14:	14 96       	adiw	r26, 0x04	; 4
     f16:	2d 91       	ld	r18, X+
     f18:	3c 91       	ld	r19, X
     f1a:	15 97       	sbiw	r26, 0x05	; 5
     f1c:	f9 01       	movw	r30, r18
     f1e:	7e 97       	sbiw	r30, 0x1e	; 30
     f20:	e9 01       	movw	r28, r18
     f22:	e3 97       	sbiw	r28, 0x33	; 51
     f24:	d6 83       	std	Z+6, r29	; 0x06
     f26:	c5 83       	std	Z+5, r28	; 0x05
     f28:	17 96       	adiw	r26, 0x07	; 7
     f2a:	9c 91       	ld	r25, X
     f2c:	17 97       	sbiw	r26, 0x07	; 7
     f2e:	18 96       	adiw	r26, 0x08	; 8
     f30:	8c 91       	ld	r24, X
     f32:	18 97       	sbiw	r26, 0x08	; 8
     f34:	9a 8b       	std	Y+18, r25	; 0x12
     f36:	89 8b       	std	Y+17, r24	; 0x11
     f38:	19 96       	adiw	r26, 0x09	; 9
     f3a:	9c 91       	ld	r25, X
     f3c:	19 97       	sbiw	r26, 0x09	; 9
     f3e:	1a 96       	adiw	r26, 0x0a	; 10
     f40:	8c 91       	ld	r24, X
     f42:	1a 97       	sbiw	r26, 0x0a	; 10
     f44:	98 8b       	std	Y+16, r25	; 0x10
     f46:	8f 87       	std	Y+15, r24	; 0x0f
     f48:	84 e2       	ldi	r24, 0x24	; 36
     f4a:	9b e0       	ldi	r25, 0x0B	; 11
     f4c:	9b 8b       	std	Y+19, r25	; 0x13
     f4e:	8c 8b       	std	Y+20, r24	; 0x14
     f50:	16 96       	adiw	r26, 0x06	; 6
     f52:	8c 91       	ld	r24, X
     f54:	16 97       	sbiw	r26, 0x06	; 6
     f56:	4d 91       	ld	r20, X+
     f58:	5c 91       	ld	r21, X
     f5a:	84 83       	std	Z+4, r24	; 0x04
     f5c:	92 e0       	ldi	r25, 0x02	; 2
     f5e:	97 87       	std	Z+15, r25	; 0x0f
     f60:	10 8a       	std	Z+16, r1	; 0x10
     f62:	64 ea       	ldi	r22, 0xA4	; 164
     f64:	76 e0       	ldi	r23, 0x06	; 6
     f66:	74 87       	std	Z+12, r23	; 0x0c
     f68:	63 87       	std	Z+11, r22	; 0x0b
     f6a:	85 8f       	std	Z+29, r24	; 0x1d
     f6c:	14 8e       	std	Z+28, r1	; 0x1c
     f6e:	13 8e       	std	Z+27, r1	; 0x1b
     f70:	12 8e       	std	Z+26, r1	; 0x1a
     f72:	81 e0       	ldi	r24, 0x01	; 1
     f74:	81 8b       	std	Z+17, r24	; 0x11
     f76:	56 87       	std	Z+14, r21	; 0x0e
     f78:	45 87       	std	Z+13, r20	; 0x0d
     f7a:	d9 01       	movw	r26, r18
     f7c:	57 97       	sbiw	r26, 0x17	; 23
     f7e:	8b eb       	ldi	r24, 0xBB	; 187
     f80:	96 e0       	ldi	r25, 0x06	; 6
     f82:	11 96       	adiw	r26, 0x01	; 1
     f84:	9c 93       	st	X, r25
     f86:	8e 93       	st	-X, r24
     f88:	eb 01       	movw	r28, r22
     f8a:	89 8d       	ldd	r24, Y+25	; 0x19
     f8c:	9a 8d       	ldd	r25, Y+26	; 0x1a
     f8e:	13 96       	adiw	r26, 0x03	; 3
     f90:	9c 93       	st	X, r25
     f92:	8e 93       	st	-X, r24
     f94:	12 97       	sbiw	r26, 0x02	; 2
     f96:	ec 01       	movw	r28, r24
     f98:	b9 83       	std	Y+1, r27	; 0x01
     f9a:	a8 83       	st	Y, r26
     f9c:	eb 01       	movw	r28, r22
     f9e:	ba 8f       	std	Y+26, r27	; 0x1a
     fa0:	a9 8f       	std	Y+25, r26	; 0x19
     fa2:	1d 96       	adiw	r26, 0x0d	; 13
     fa4:	0b 2e       	mov	r0, r27
     fa6:	11 96       	adiw	r26, 0x01	; 1
     fa8:	0c 92       	st	X, r0
     faa:	11 97       	sbiw	r26, 0x01	; 1
     fac:	ac 93       	st	X, r26
     fae:	12 96       	adiw	r26, 0x02	; 2
     fb0:	0b 2e       	mov	r0, r27
     fb2:	11 96       	adiw	r26, 0x01	; 1
     fb4:	0c 92       	st	X, r0
     fb6:	11 97       	sbiw	r26, 0x01	; 1
     fb8:	ac 93       	st	X, r26
     fba:	0a 2e       	mov	r0, r26
     fbc:	1b 2e       	mov	r1, r27
     fbe:	13 96       	adiw	r26, 0x03	; 3
     fc0:	1c 92       	st	X, r1
     fc2:	0e 92       	st	-X, r0
     fc4:	11 24       	eor	r1, r1
     fc6:	12 97       	sbiw	r26, 0x02	; 2
     fc8:	cf 01       	movw	r24, r30
     fca:	df 91       	pop	r29
     fcc:	cf 91       	pop	r28
     fce:	08 95       	ret

00000fd0 <chThdCreateI>:
     fd0:	9e df       	rcall	.-196    	; 0xf0e <chThdCreateSuspendedI>
     fd2:	d2 cd       	rjmp	.-1116   	; 0xb78 <chSchReadyI>

00000fd4 <chThdCreateStatic>:
     fd4:	0f 93       	push	r16
     fd6:	1f 93       	push	r17
     fd8:	cf 93       	push	r28
     fda:	df 93       	push	r29
     fdc:	f8 94       	cli
     fde:	6e 51       	subi	r22, 0x1E	; 30
     fe0:	71 09       	sbc	r23, r1
     fe2:	ec 01       	movw	r28, r24
     fe4:	c6 0f       	add	r28, r22
     fe6:	d7 1f       	adc	r29, r23
     fe8:	fe 01       	movw	r30, r28
     fea:	75 97       	sbiw	r30, 0x15	; 21
     fec:	fe 83       	std	Y+6, r31	; 0x06
     fee:	ed 83       	std	Y+5, r30	; 0x05
     ff0:	22 8b       	std	Z+18, r18	; 0x12
     ff2:	31 8b       	std	Z+17, r19	; 0x11
     ff4:	00 8b       	std	Z+16, r16	; 0x10
     ff6:	17 87       	std	Z+15, r17	; 0x0f
     ff8:	84 e2       	ldi	r24, 0x24	; 36
     ffa:	9b e0       	ldi	r25, 0x0B	; 11
     ffc:	93 8b       	std	Z+19, r25	; 0x13
     ffe:	84 8b       	std	Z+20, r24	; 0x14
    1000:	4c 83       	std	Y+4, r20	; 0x04
    1002:	82 e0       	ldi	r24, 0x02	; 2
    1004:	8f 87       	std	Y+15, r24	; 0x0f
    1006:	18 8a       	std	Y+16, r1	; 0x10
    1008:	e4 ea       	ldi	r30, 0xA4	; 164
    100a:	f6 e0       	ldi	r31, 0x06	; 6
    100c:	fc 87       	std	Y+12, r31	; 0x0c
    100e:	eb 87       	std	Y+11, r30	; 0x0b
    1010:	4d 8f       	std	Y+29, r20	; 0x1d
    1012:	1c 8e       	std	Y+28, r1	; 0x1c
    1014:	1b 8e       	std	Y+27, r1	; 0x1b
    1016:	1a 8e       	std	Y+26, r1	; 0x1a
    1018:	81 e0       	ldi	r24, 0x01	; 1
    101a:	89 8b       	std	Y+17, r24	; 0x11
    101c:	89 e2       	ldi	r24, 0x29	; 41
    101e:	91 e0       	ldi	r25, 0x01	; 1
    1020:	9e 87       	std	Y+14, r25	; 0x0e
    1022:	8d 87       	std	Y+13, r24	; 0x0d
    1024:	ce 01       	movw	r24, r28
    1026:	07 96       	adiw	r24, 0x07	; 7
    1028:	2b eb       	ldi	r18, 0xBB	; 187
    102a:	36 e0       	ldi	r19, 0x06	; 6
    102c:	38 87       	std	Y+8, r19	; 0x08
    102e:	2f 83       	std	Y+7, r18	; 0x07
    1030:	a1 8d       	ldd	r26, Z+25	; 0x19
    1032:	b2 8d       	ldd	r27, Z+26	; 0x1a
    1034:	ba 87       	std	Y+10, r27	; 0x0a
    1036:	a9 87       	std	Y+9, r26	; 0x09
    1038:	8d 93       	st	X+, r24
    103a:	9c 93       	st	X, r25
    103c:	92 8f       	std	Z+26, r25	; 0x1a
    103e:	81 8f       	std	Z+25, r24	; 0x19
    1040:	0d 96       	adiw	r24, 0x0d	; 13
    1042:	9d 8b       	std	Y+21, r25	; 0x15
    1044:	8c 8b       	std	Y+20, r24	; 0x14
    1046:	02 96       	adiw	r24, 0x02	; 2
    1048:	9f 8b       	std	Y+23, r25	; 0x17
    104a:	8e 8b       	std	Y+22, r24	; 0x16
    104c:	99 8f       	std	Y+25, r25	; 0x19
    104e:	88 8f       	std	Y+24, r24	; 0x18
    1050:	70 e0       	ldi	r23, 0x00	; 0
    1052:	60 e0       	ldi	r22, 0x00	; 0
    1054:	ce 01       	movw	r24, r28
    1056:	06 de       	rcall	.-1012   	; 0xc64 <chSchWakeupS>
    1058:	78 94       	sei
    105a:	ce 01       	movw	r24, r28
    105c:	df 91       	pop	r29
    105e:	cf 91       	pop	r28
    1060:	1f 91       	pop	r17
    1062:	0f 91       	pop	r16
    1064:	08 95       	ret

00001066 <chThdExitS>:
    1066:	0f 93       	push	r16
    1068:	1f 93       	push	r17
    106a:	cf 93       	push	r28
    106c:	df 93       	push	r29
    106e:	c0 91 a9 06 	lds	r28, 0x06A9	; 0x8006a9 <ch0+0x5>
    1072:	d0 91 aa 06 	lds	r29, 0x06AA	; 0x8006aa <ch0+0x6>
    1076:	9b 8b       	std	Y+19, r25	; 0x13
    1078:	8a 8b       	std	Y+18, r24	; 0x12
    107a:	8e 01       	movw	r16, r28
    107c:	0c 5e       	subi	r16, 0xEC	; 236
    107e:	1f 4f       	sbci	r17, 0xFF	; 255
    1080:	8c 89       	ldd	r24, Y+20	; 0x14
    1082:	9d 89       	ldd	r25, Y+21	; 0x15
    1084:	08 17       	cp	r16, r24
    1086:	19 07       	cpc	r17, r25
    1088:	59 f0       	breq	.+22     	; 0x10a0 <chThdExitS+0x3a>
    108a:	fc 01       	movw	r30, r24
    108c:	20 81       	ld	r18, Z
    108e:	31 81       	ldd	r19, Z+1	; 0x01
    1090:	3d 8b       	std	Y+21, r19	; 0x15
    1092:	2c 8b       	std	Y+20, r18	; 0x14
    1094:	71 dd       	rcall	.-1310   	; 0xb78 <chSchReadyI>
    1096:	8c 89       	ldd	r24, Y+20	; 0x14
    1098:	9d 89       	ldd	r25, Y+21	; 0x15
    109a:	80 17       	cp	r24, r16
    109c:	91 07       	cpc	r25, r17
    109e:	a9 f7       	brne	.-22     	; 0x108a <chThdExitS+0x24>
    10a0:	89 89       	ldd	r24, Y+17	; 0x11
    10a2:	81 11       	cpse	r24, r1
    10a4:	0c c0       	rjmp	.+24     	; 0x10be <chThdExitS+0x58>
    10a6:	e9 85       	ldd	r30, Y+9	; 0x09
    10a8:	fa 85       	ldd	r31, Y+10	; 0x0a
    10aa:	8f 81       	ldd	r24, Y+7	; 0x07
    10ac:	98 85       	ldd	r25, Y+8	; 0x08
    10ae:	91 83       	std	Z+1, r25	; 0x01
    10b0:	80 83       	st	Z, r24
    10b2:	af 81       	ldd	r26, Y+7	; 0x07
    10b4:	b8 85       	ldd	r27, Y+8	; 0x08
    10b6:	13 96       	adiw	r26, 0x03	; 3
    10b8:	fc 93       	st	X, r31
    10ba:	ee 93       	st	-X, r30
    10bc:	12 97       	sbiw	r26, 0x02	; 2
    10be:	8f e0       	ldi	r24, 0x0F	; 15
    10c0:	df 91       	pop	r29
    10c2:	cf 91       	pop	r28
    10c4:	1f 91       	pop	r17
    10c6:	0f 91       	pop	r16
    10c8:	7b cd       	rjmp	.-1290   	; 0xbc0 <chSchGoSleepS>

000010ca <chThdExit>:
    10ca:	f8 94       	cli
    10cc:	cc cf       	rjmp	.-104    	; 0x1066 <chThdExitS>

000010ce <chThdSleep>:
    10ce:	f8 94       	cli
    10d0:	bc 01       	movw	r22, r24
    10d2:	88 e0       	ldi	r24, 0x08	; 8
    10d4:	91 dd       	rcall	.-1246   	; 0xbf8 <chSchGoSleepTimeoutS>
    10d6:	78 94       	sei
    10d8:	08 95       	ret

000010da <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
    10da:	cf 93       	push	r28
    10dc:	df 93       	push	r29
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
    10de:	e0 91 a9 06 	lds	r30, 0x06A9	; 0x8006a9 <ch0+0x5>
    10e2:	f0 91 aa 06 	lds	r31, 0x06AA	; 0x8006aa <ch0+0x6>
  thread_t *currtp = chThdGetSelfX();

  if (unlikely(TIME_IMMEDIATE == timeout)) {
    10e6:	61 15       	cp	r22, r1
    10e8:	71 05       	cpc	r23, r1
    10ea:	79 f0       	breq	.+30     	; 0x110a <chThdEnqueueTimeoutS+0x30>
 *
 * @notapi
 */
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {

  p->next       = qp;
    10ec:	91 83       	std	Z+1, r25	; 0x01
    10ee:	80 83       	st	Z, r24
  p->prev       = qp->prev;
    10f0:	ec 01       	movw	r28, r24
    10f2:	aa 81       	ldd	r26, Y+2	; 0x02
    10f4:	bb 81       	ldd	r27, Y+3	; 0x03
    10f6:	b3 83       	std	Z+3, r27	; 0x03
    10f8:	a2 83       	std	Z+2, r26	; 0x02
  p->prev->next = p;
    10fa:	ed 93       	st	X+, r30
    10fc:	fc 93       	st	X, r31
  qp->prev      = p;
    10fe:	fb 83       	std	Y+3, r31	; 0x03
    1100:	ea 83       	std	Y+2, r30	; 0x02
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    1102:	84 e0       	ldi	r24, 0x04	; 4
}
    1104:	df 91       	pop	r29
    1106:	cf 91       	pop	r28
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    1108:	77 cd       	rjmp	.-1298   	; 0xbf8 <chSchGoSleepTimeoutS>
}
    110a:	8f ef       	ldi	r24, 0xFF	; 255
    110c:	9f ef       	ldi	r25, 0xFF	; 255
    110e:	df 91       	pop	r29
    1110:	cf 91       	pop	r28
    1112:	08 95       	ret

00001114 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    1114:	cf 93       	push	r28
    1116:	df 93       	push	r29
    1118:	fc 01       	movw	r30, r24
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    111a:	80 81       	ld	r24, Z
    111c:	91 81       	ldd	r25, Z+1	; 0x01

  if (ch_queue_notempty(&tqp->queue)) {
    111e:	e8 17       	cp	r30, r24
    1120:	f9 07       	cpc	r31, r25
    1122:	71 f0       	breq	.+28     	; 0x1140 <chThdDequeueNextI+0x2c>
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;

  qp->next       = p->next;
    1124:	ec 01       	movw	r28, r24
    1126:	a8 81       	ld	r26, Y
    1128:	b9 81       	ldd	r27, Y+1	; 0x01
    112a:	b1 83       	std	Z+1, r27	; 0x01
    112c:	a0 83       	st	Z, r26
  qp->next->prev = qp;
    112e:	13 96       	adiw	r26, 0x03	; 3
    1130:	fc 93       	st	X, r31
    1132:	ee 93       	st	-X, r30
    1134:	12 97       	sbiw	r26, 0x02	; 2

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
    1136:	7b 8b       	std	Y+19, r23	; 0x13
    1138:	6a 8b       	std	Y+18, r22	; 0x12
    chThdDoDequeueNextI(tqp, msg);
  }
}
    113a:	df 91       	pop	r29
    113c:	cf 91       	pop	r28
  (void) chSchReadyI(tp);
    113e:	1c cd       	rjmp	.-1480   	; 0xb78 <chSchReadyI>
    1140:	df 91       	pop	r29
    1142:	cf 91       	pop	r28
    1144:	08 95       	ret

00001146 <chMtxObjectInit>:
  mp->cnt++;
#endif
  mp->owner = currtp;
  mp->next = currtp->mtxlist;
  currtp->mtxlist = mp;
  return true;
    1146:	fc 01       	movw	r30, r24
    1148:	91 83       	std	Z+1, r25	; 0x01
    114a:	80 83       	st	Z, r24
    114c:	93 83       	std	Z+3, r25	; 0x03
    114e:	82 83       	std	Z+2, r24	; 0x02
    1150:	15 82       	std	Z+5, r1	; 0x05
    1152:	14 82       	std	Z+4, r1	; 0x04
    1154:	08 95       	ret

00001156 <chMtxLockS>:
    1156:	0f 93       	push	r16
    1158:	1f 93       	push	r17
    115a:	cf 93       	push	r28
    115c:	df 93       	push	r29
    115e:	ec 01       	movw	r28, r24
    1160:	00 91 a9 06 	lds	r16, 0x06A9	; 0x8006a9 <ch0+0x5>
    1164:	10 91 aa 06 	lds	r17, 0x06AA	; 0x8006aa <ch0+0x6>
    1168:	ec 81       	ldd	r30, Y+4	; 0x04
    116a:	fd 81       	ldd	r31, Y+5	; 0x05
    116c:	30 97       	sbiw	r30, 0x00	; 0
    116e:	09 f4       	brne	.+2      	; 0x1172 <chMtxLockS+0x1c>
    1170:	7e c0       	rjmp	.+252    	; 0x126e <chMtxLockS+0x118>
    1172:	d8 01       	movw	r26, r16
    1174:	14 96       	adiw	r26, 0x04	; 4
    1176:	8c 91       	ld	r24, X
    1178:	94 81       	ldd	r25, Z+4	; 0x04
    117a:	98 17       	cp	r25, r24
    117c:	50 f4       	brcc	.+20     	; 0x1192 <chMtxLockS+0x3c>
    117e:	84 83       	std	Z+4, r24	; 0x04
    1180:	87 85       	ldd	r24, Z+15	; 0x0f
    1182:	86 30       	cpi	r24, 0x06	; 6
    1184:	09 f4       	brne	.+2      	; 0x1188 <chMtxLockS+0x32>
    1186:	85 c0       	rjmp	.+266    	; 0x1292 <chMtxLockS+0x13c>
    1188:	87 30       	cpi	r24, 0x07	; 7
    118a:	71 f1       	breq	.+92     	; 0x11e8 <chMtxLockS+0x92>
    118c:	88 23       	and	r24, r24
    118e:	09 f4       	brne	.+2      	; 0x1192 <chMtxLockS+0x3c>
    1190:	5b c0       	rjmp	.+182    	; 0x1248 <chMtxLockS+0xf2>
    1192:	9e 01       	movw	r18, r28
    1194:	fe 01       	movw	r30, r28
    1196:	07 c0       	rjmp	.+14     	; 0x11a6 <chMtxLockS+0x50>
    1198:	94 81       	ldd	r25, Z+4	; 0x04
    119a:	d8 01       	movw	r26, r16
    119c:	14 96       	adiw	r26, 0x04	; 4
    119e:	8c 91       	ld	r24, X
    11a0:	98 17       	cp	r25, r24
    11a2:	08 f4       	brcc	.+2      	; 0x11a6 <chMtxLockS+0x50>
    11a4:	62 c0       	rjmp	.+196    	; 0x126a <chMtxLockS+0x114>
    11a6:	01 90       	ld	r0, Z+
    11a8:	f0 81       	ld	r31, Z
    11aa:	e0 2d       	mov	r30, r0
    11ac:	ce 17       	cp	r28, r30
    11ae:	df 07       	cpc	r29, r31
    11b0:	99 f7       	brne	.-26     	; 0x1198 <chMtxLockS+0x42>
    11b2:	f8 01       	movw	r30, r16
    11b4:	31 83       	std	Z+1, r19	; 0x01
    11b6:	20 83       	st	Z, r18
    11b8:	d9 01       	movw	r26, r18
    11ba:	12 96       	adiw	r26, 0x02	; 2
    11bc:	ed 91       	ld	r30, X+
    11be:	fc 91       	ld	r31, X
    11c0:	d8 01       	movw	r26, r16
    11c2:	13 96       	adiw	r26, 0x03	; 3
    11c4:	fc 93       	st	X, r31
    11c6:	ee 93       	st	-X, r30
    11c8:	12 97       	sbiw	r26, 0x02	; 2
    11ca:	11 83       	std	Z+1, r17	; 0x01
    11cc:	00 83       	st	Z, r16
    11ce:	f9 01       	movw	r30, r18
    11d0:	13 83       	std	Z+3, r17	; 0x03
    11d2:	02 83       	std	Z+2, r16	; 0x02
    11d4:	53 96       	adiw	r26, 0x13	; 19
    11d6:	dc 93       	st	X, r29
    11d8:	ce 93       	st	-X, r28
    11da:	52 97       	sbiw	r26, 0x12	; 18
    11dc:	86 e0       	ldi	r24, 0x06	; 6
    11de:	df 91       	pop	r29
    11e0:	cf 91       	pop	r28
    11e2:	1f 91       	pop	r17
    11e4:	0f 91       	pop	r16
    11e6:	ec cc       	rjmp	.-1576   	; 0xbc0 <chSchGoSleepS>
    11e8:	22 81       	ldd	r18, Z+2	; 0x02
    11ea:	33 81       	ldd	r19, Z+3	; 0x03
    11ec:	80 81       	ld	r24, Z
    11ee:	91 81       	ldd	r25, Z+1	; 0x01
    11f0:	d9 01       	movw	r26, r18
    11f2:	8d 93       	st	X+, r24
    11f4:	9c 93       	st	X, r25
    11f6:	80 81       	ld	r24, Z
    11f8:	91 81       	ldd	r25, Z+1	; 0x01
    11fa:	dc 01       	movw	r26, r24
    11fc:	13 96       	adiw	r26, 0x03	; 3
    11fe:	3c 93       	st	X, r19
    1200:	2e 93       	st	-X, r18
    1202:	12 97       	sbiw	r26, 0x02	; 2
    1204:	22 89       	ldd	r18, Z+18	; 0x12
    1206:	33 89       	ldd	r19, Z+19	; 0x13
    1208:	d9 01       	movw	r26, r18
    120a:	07 c0       	rjmp	.+14     	; 0x121a <chMtxLockS+0xc4>
    120c:	14 96       	adiw	r26, 0x04	; 4
    120e:	9c 91       	ld	r25, X
    1210:	14 97       	sbiw	r26, 0x04	; 4
    1212:	84 81       	ldd	r24, Z+4	; 0x04
    1214:	98 17       	cp	r25, r24
    1216:	08 f4       	brcc	.+2      	; 0x121a <chMtxLockS+0xc4>
    1218:	78 c0       	rjmp	.+240    	; 0x130a <chMtxLockS+0x1b4>
    121a:	0d 90       	ld	r0, X+
    121c:	bc 91       	ld	r27, X
    121e:	a0 2d       	mov	r26, r0
    1220:	2a 17       	cp	r18, r26
    1222:	3b 07       	cpc	r19, r27
    1224:	99 f7       	brne	.-26     	; 0x120c <chMtxLockS+0xb6>
    1226:	31 83       	std	Z+1, r19	; 0x01
    1228:	20 83       	st	Z, r18
    122a:	d9 01       	movw	r26, r18
    122c:	12 96       	adiw	r26, 0x02	; 2
    122e:	8d 91       	ld	r24, X+
    1230:	9c 91       	ld	r25, X
    1232:	93 83       	std	Z+3, r25	; 0x03
    1234:	82 83       	std	Z+2, r24	; 0x02
    1236:	dc 01       	movw	r26, r24
    1238:	ed 93       	st	X+, r30
    123a:	fc 93       	st	X, r31
    123c:	d9 01       	movw	r26, r18
    123e:	13 96       	adiw	r26, 0x03	; 3
    1240:	fc 93       	st	X, r31
    1242:	ee 93       	st	-X, r30
    1244:	12 97       	sbiw	r26, 0x02	; 2
    1246:	a5 cf       	rjmp	.-182    	; 0x1192 <chMtxLockS+0x3c>
    1248:	22 81       	ldd	r18, Z+2	; 0x02
    124a:	33 81       	ldd	r19, Z+3	; 0x03
    124c:	80 81       	ld	r24, Z
    124e:	91 81       	ldd	r25, Z+1	; 0x01
    1250:	d9 01       	movw	r26, r18
    1252:	8d 93       	st	X+, r24
    1254:	9c 93       	st	X, r25
    1256:	80 81       	ld	r24, Z
    1258:	91 81       	ldd	r25, Z+1	; 0x01
    125a:	dc 01       	movw	r26, r24
    125c:	13 96       	adiw	r26, 0x03	; 3
    125e:	3c 93       	st	X, r19
    1260:	2e 93       	st	-X, r18
    1262:	12 97       	sbiw	r26, 0x02	; 2
    1264:	cf 01       	movw	r24, r30
    1266:	88 dc       	rcall	.-1776   	; 0xb78 <chSchReadyI>
    1268:	94 cf       	rjmp	.-216    	; 0x1192 <chMtxLockS+0x3c>
    126a:	9f 01       	movw	r18, r30
    126c:	a2 cf       	rjmp	.-188    	; 0x11b2 <chMtxLockS+0x5c>
    126e:	1d 83       	std	Y+5, r17	; 0x05
    1270:	0c 83       	std	Y+4, r16	; 0x04
    1272:	d8 01       	movw	r26, r16
    1274:	5b 96       	adiw	r26, 0x1b	; 27
    1276:	8d 91       	ld	r24, X+
    1278:	9c 91       	ld	r25, X
    127a:	5c 97       	sbiw	r26, 0x1c	; 28
    127c:	9f 83       	std	Y+7, r25	; 0x07
    127e:	8e 83       	std	Y+6, r24	; 0x06
    1280:	5c 96       	adiw	r26, 0x1c	; 28
    1282:	dc 93       	st	X, r29
    1284:	ce 93       	st	-X, r28
    1286:	5b 97       	sbiw	r26, 0x1b	; 27
    1288:	df 91       	pop	r29
    128a:	cf 91       	pop	r28
    128c:	1f 91       	pop	r17
    128e:	0f 91       	pop	r16
    1290:	08 95       	ret
    1292:	22 81       	ldd	r18, Z+2	; 0x02
    1294:	33 81       	ldd	r19, Z+3	; 0x03
    1296:	80 81       	ld	r24, Z
    1298:	91 81       	ldd	r25, Z+1	; 0x01
    129a:	d9 01       	movw	r26, r18
    129c:	8d 93       	st	X+, r24
    129e:	9c 93       	st	X, r25
    12a0:	80 81       	ld	r24, Z
    12a2:	91 81       	ldd	r25, Z+1	; 0x01
    12a4:	dc 01       	movw	r26, r24
    12a6:	13 96       	adiw	r26, 0x03	; 3
    12a8:	3c 93       	st	X, r19
    12aa:	2e 93       	st	-X, r18
    12ac:	12 97       	sbiw	r26, 0x02	; 2
    12ae:	22 89       	ldd	r18, Z+18	; 0x12
    12b0:	33 89       	ldd	r19, Z+19	; 0x13
    12b2:	d9 01       	movw	r26, r18
    12b4:	06 c0       	rjmp	.+12     	; 0x12c2 <chMtxLockS+0x16c>
    12b6:	14 96       	adiw	r26, 0x04	; 4
    12b8:	9c 91       	ld	r25, X
    12ba:	14 97       	sbiw	r26, 0x04	; 4
    12bc:	84 81       	ldd	r24, Z+4	; 0x04
    12be:	98 17       	cp	r25, r24
    12c0:	30 f1       	brcs	.+76     	; 0x130e <chMtxLockS+0x1b8>
    12c2:	0d 90       	ld	r0, X+
    12c4:	bc 91       	ld	r27, X
    12c6:	a0 2d       	mov	r26, r0
    12c8:	2a 17       	cp	r18, r26
    12ca:	3b 07       	cpc	r19, r27
    12cc:	a1 f7       	brne	.-24     	; 0x12b6 <chMtxLockS+0x160>
    12ce:	31 83       	std	Z+1, r19	; 0x01
    12d0:	20 83       	st	Z, r18
    12d2:	d9 01       	movw	r26, r18
    12d4:	12 96       	adiw	r26, 0x02	; 2
    12d6:	8d 91       	ld	r24, X+
    12d8:	9c 91       	ld	r25, X
    12da:	93 83       	std	Z+3, r25	; 0x03
    12dc:	82 83       	std	Z+2, r24	; 0x02
    12de:	dc 01       	movw	r26, r24
    12e0:	ed 93       	st	X+, r30
    12e2:	fc 93       	st	X, r31
    12e4:	d9 01       	movw	r26, r18
    12e6:	13 96       	adiw	r26, 0x03	; 3
    12e8:	fc 93       	st	X, r31
    12ea:	ee 93       	st	-X, r30
    12ec:	12 97       	sbiw	r26, 0x02	; 2
    12ee:	02 88       	ldd	r0, Z+18	; 0x12
    12f0:	f3 89       	ldd	r31, Z+19	; 0x13
    12f2:	e0 2d       	mov	r30, r0
    12f4:	04 80       	ldd	r0, Z+4	; 0x04
    12f6:	f5 81       	ldd	r31, Z+5	; 0x05
    12f8:	e0 2d       	mov	r30, r0
    12fa:	d8 01       	movw	r26, r16
    12fc:	14 96       	adiw	r26, 0x04	; 4
    12fe:	8c 91       	ld	r24, X
    1300:	94 81       	ldd	r25, Z+4	; 0x04
    1302:	98 17       	cp	r25, r24
    1304:	08 f4       	brcc	.+2      	; 0x1308 <chMtxLockS+0x1b2>
    1306:	3b cf       	rjmp	.-394    	; 0x117e <chMtxLockS+0x28>
    1308:	44 cf       	rjmp	.-376    	; 0x1192 <chMtxLockS+0x3c>
    130a:	9d 01       	movw	r18, r26
    130c:	8c cf       	rjmp	.-232    	; 0x1226 <chMtxLockS+0xd0>
    130e:	9d 01       	movw	r18, r26
    1310:	de cf       	rjmp	.-68     	; 0x12ce <chMtxLockS+0x178>

00001312 <chMtxLock>:
    1312:	f8 94       	cli
    1314:	20 df       	rcall	.-448    	; 0x1156 <chMtxLockS>
    1316:	78 94       	sei
    1318:	08 95       	ret

0000131a <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
    131a:	cf 93       	push	r28
    131c:	df 93       	push	r29
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
    131e:	c0 91 a9 06 	lds	r28, 0x06A9	; 0x8006a9 <ch0+0x5>
    1322:	d0 91 aa 06 	lds	r29, 0x06AA	; 0x8006aa <ch0+0x6>
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1326:	f8 94       	cli
    chDbgAssert(currtp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
    1328:	dc 01       	movw	r26, r24
    132a:	16 96       	adiw	r26, 0x06	; 6
    132c:	ed 91       	ld	r30, X+
    132e:	fc 91       	ld	r31, X
    1330:	17 97       	sbiw	r26, 0x07	; 7
    1332:	fc 8f       	std	Y+28, r31	; 0x1c
    1334:	eb 8f       	std	Y+27, r30	; 0x1b

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
    1336:	2d 91       	ld	r18, X+
    1338:	3c 91       	ld	r19, X
    133a:	28 17       	cp	r18, r24
    133c:	39 07       	cpc	r19, r25
    133e:	81 f1       	breq	.+96     	; 0x13a0 <chMtxUnlock+0x86>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
    1340:	3d 8d       	ldd	r19, Y+29	; 0x1d
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    1342:	30 97       	sbiw	r30, 0x00	; 0
    1344:	79 f0       	breq	.+30     	; 0x1364 <chMtxUnlock+0x4a>
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    1346:	a0 81       	ld	r26, Z
    1348:	b1 81       	ldd	r27, Z+1	; 0x01
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    134a:	ea 17       	cp	r30, r26
    134c:	fb 07       	cpc	r31, r27
    134e:	29 f0       	breq	.+10     	; 0x135a <chMtxUnlock+0x40>
    1350:	14 96       	adiw	r26, 0x04	; 4
    1352:	2c 91       	ld	r18, X
    1354:	32 17       	cp	r19, r18
    1356:	08 f4       	brcc	.+2      	; 0x135a <chMtxUnlock+0x40>
    1358:	32 2f       	mov	r19, r18
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
        }
        lmp = lmp->next;
    135a:	06 80       	ldd	r0, Z+6	; 0x06
    135c:	f7 81       	ldd	r31, Z+7	; 0x07
    135e:	e0 2d       	mov	r30, r0

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    1360:	30 97       	sbiw	r30, 0x00	; 0
    1362:	89 f7       	brne	.-30     	; 0x1346 <chMtxUnlock+0x2c>
    1364:	fc 01       	movw	r30, r24
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
    1366:	3c 83       	std	Y+4, r19	; 0x04
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;
    1368:	a0 81       	ld	r26, Z
    136a:	b1 81       	ldd	r27, Z+1	; 0x01

  qp->next       = p->next;
    136c:	cd 91       	ld	r28, X+
    136e:	dc 91       	ld	r29, X
    1370:	11 97       	sbiw	r26, 0x01	; 1
    1372:	d1 83       	std	Z+1, r29	; 0x01
    1374:	c0 83       	st	Z, r28
  qp->next->prev = qp;
    1376:	9b 83       	std	Y+3, r25	; 0x03
    1378:	8a 83       	std	Y+2, r24	; 0x02
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
    137a:	b5 83       	std	Z+5, r27	; 0x05
    137c:	a4 83       	std	Z+4, r26	; 0x04
      mp->next = tp->mtxlist;
    137e:	5b 96       	adiw	r26, 0x1b	; 27
    1380:	8d 91       	ld	r24, X+
    1382:	9c 91       	ld	r25, X
    1384:	5c 97       	sbiw	r26, 0x1c	; 28
    1386:	97 83       	std	Z+7, r25	; 0x07
    1388:	86 83       	std	Z+6, r24	; 0x06
      tp->mtxlist = mp;
    138a:	5c 96       	adiw	r26, 0x1c	; 28
    138c:	fc 93       	st	X, r31
    138e:	ee 93       	st	-X, r30
    1390:	5b 97       	sbiw	r26, 0x1b	; 27

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
    1392:	cd 01       	movw	r24, r26
    1394:	f1 db       	rcall	.-2078   	; 0xb78 <chSchReadyI>
      chSchRescheduleS();
    1396:	03 dd       	rcall	.-1530   	; 0xd9e <chSchRescheduleS>
    1398:	78 94       	sei
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    139a:	df 91       	pop	r29
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
    139c:	cf 91       	pop	r28
    139e:	08 95       	ret
    13a0:	f9 01       	movw	r30, r18
         just changed priority.*/
      (void) chSchReadyI(tp);
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
    13a2:	15 82       	std	Z+5, r1	; 0x05
    13a4:	14 82       	std	Z+4, r1	; 0x04
    13a6:	78 94       	sei
    13a8:	df 91       	pop	r29
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
    13aa:	cf 91       	pop	r28
    13ac:	08 95       	ret

000013ae <chMtxUnlockS>:
    13ae:	cf 93       	push	r28
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
    13b0:	df 93       	push	r29
    13b2:	ec 01       	movw	r28, r24
    13b4:	20 91 a9 06 	lds	r18, 0x06A9	; 0x8006a9 <ch0+0x5>
    13b8:	30 91 aa 06 	lds	r19, 0x06AA	; 0x8006aa <ch0+0x6>
    chDbgAssert(currtp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
    13bc:	ee 81       	ldd	r30, Y+6	; 0x06
    13be:	ff 81       	ldd	r31, Y+7	; 0x07
    13c0:	d9 01       	movw	r26, r18
    13c2:	5c 96       	adiw	r26, 0x1c	; 28
    13c4:	fc 93       	st	X, r31
    13c6:	ee 93       	st	-X, r30
    13c8:	5b 97       	sbiw	r26, 0x1b	; 27

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
    13ca:	a8 81       	ld	r26, Y
    13cc:	b9 81       	ldd	r27, Y+1	; 0x01
    13ce:	a8 17       	cp	r26, r24
    13d0:	b9 07       	cpc	r27, r25
    13d2:	61 f1       	breq	.+88     	; 0x142c <chMtxUnlockS+0x7e>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
    13d4:	d9 01       	movw	r26, r18
    13d6:	5d 96       	adiw	r26, 0x1d	; 29
    13d8:	9c 91       	ld	r25, X
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    13da:	30 97       	sbiw	r30, 0x00	; 0
    13dc:	79 f0       	breq	.+30     	; 0x13fc <chMtxUnlockS+0x4e>
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    13de:	a0 81       	ld	r26, Z
    13e0:	b1 81       	ldd	r27, Z+1	; 0x01
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    13e2:	ea 17       	cp	r30, r26
    13e4:	fb 07       	cpc	r31, r27
    13e6:	29 f0       	breq	.+10     	; 0x13f2 <chMtxUnlockS+0x44>
    13e8:	14 96       	adiw	r26, 0x04	; 4
    13ea:	8c 91       	ld	r24, X
    13ec:	98 17       	cp	r25, r24
    13ee:	08 f4       	brcc	.+2      	; 0x13f2 <chMtxUnlockS+0x44>
    13f0:	98 2f       	mov	r25, r24
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
          newprio = threadref(lmp->queue.next)->hdr.pqueue.prio;
        }
        lmp = lmp->next;
    13f2:	06 80       	ldd	r0, Z+6	; 0x06
    13f4:	f7 81       	ldd	r31, Z+7	; 0x07
    13f6:	e0 2d       	mov	r30, r0

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    13f8:	30 97       	sbiw	r30, 0x00	; 0
    13fa:	89 f7       	brne	.-30     	; 0x13de <chMtxUnlockS+0x30>
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
    13fc:	f9 01       	movw	r30, r18
    13fe:	94 83       	std	Z+4, r25	; 0x04
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;
    1400:	e8 81       	ld	r30, Y
    1402:	f9 81       	ldd	r31, Y+1	; 0x01

  qp->next       = p->next;
    1404:	a0 81       	ld	r26, Z
    1406:	b1 81       	ldd	r27, Z+1	; 0x01
    1408:	b9 83       	std	Y+1, r27	; 0x01
    140a:	a8 83       	st	Y, r26
  qp->next->prev = qp;
    140c:	13 96       	adiw	r26, 0x03	; 3
    140e:	dc 93       	st	X, r29
    1410:	ce 93       	st	-X, r28
    1412:	12 97       	sbiw	r26, 0x02	; 2
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
    1414:	fd 83       	std	Y+5, r31	; 0x05
    1416:	ec 83       	std	Y+4, r30	; 0x04
      mp->next = tp->mtxlist;
    1418:	83 8d       	ldd	r24, Z+27	; 0x1b
    141a:	94 8d       	ldd	r25, Z+28	; 0x1c
    141c:	9f 83       	std	Y+7, r25	; 0x07
    141e:	8e 83       	std	Y+6, r24	; 0x06
      tp->mtxlist = mp;
    1420:	d4 8f       	std	Z+28, r29	; 0x1c
    1422:	c3 8f       	std	Z+27, r28	; 0x1b
      (void) chSchReadyI(tp);
    1424:	cf 01       	movw	r24, r30
      mp->owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
    1426:	df 91       	pop	r29
    1428:	cf 91       	pop	r28
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
      (void) chSchReadyI(tp);
    142a:	a6 cb       	rjmp	.-2228   	; 0xb78 <chSchReadyI>
    }
    else {
      mp->owner = NULL;
    142c:	15 96       	adiw	r26, 0x05	; 5
    142e:	1c 92       	st	X, r1
    1430:	1e 92       	st	-X, r1
    1432:	14 97       	sbiw	r26, 0x04	; 4
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
    1434:	df 91       	pop	r29
    1436:	cf 91       	pop	r28
    1438:	08 95       	ret

0000143a <chCondObjectInit>:
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (ch_queue_notempty(&cp->queue)) {
    chSchReadyI(threadref(ch_queue_fifo_remove(&cp->queue)))->u.rdymsg = MSG_RESET;
  }
}
    143a:	fc 01       	movw	r30, r24
    143c:	91 83       	std	Z+1, r25	; 0x01
    143e:	80 83       	st	Z, r24
    1440:	93 83       	std	Z+3, r25	; 0x03
    1442:	82 83       	std	Z+2, r24	; 0x02
    1444:	08 95       	ret

00001446 <chCondSignal>:
    1446:	cf 93       	push	r28
    1448:	df 93       	push	r29
    144a:	fc 01       	movw	r30, r24
    144c:	f8 94       	cli
    144e:	80 81       	ld	r24, Z
    1450:	91 81       	ldd	r25, Z+1	; 0x01
    1452:	e8 17       	cp	r30, r24
    1454:	f9 07       	cpc	r31, r25
    1456:	61 f0       	breq	.+24     	; 0x1470 <chCondSignal+0x2a>
    1458:	ec 01       	movw	r28, r24
    145a:	a8 81       	ld	r26, Y
    145c:	b9 81       	ldd	r27, Y+1	; 0x01
    145e:	b1 83       	std	Z+1, r27	; 0x01
    1460:	a0 83       	st	Z, r26
    1462:	13 96       	adiw	r26, 0x03	; 3
    1464:	fc 93       	st	X, r31
    1466:	ee 93       	st	-X, r30
    1468:	12 97       	sbiw	r26, 0x02	; 2
    146a:	70 e0       	ldi	r23, 0x00	; 0
    146c:	60 e0       	ldi	r22, 0x00	; 0
    146e:	fa db       	rcall	.-2060   	; 0xc64 <chSchWakeupS>
    1470:	78 94       	sei
    1472:	df 91       	pop	r29
    1474:	cf 91       	pop	r28
    1476:	08 95       	ret

00001478 <chCondWaitS>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
    1478:	ef 92       	push	r14
    147a:	ff 92       	push	r15
    147c:	0f 93       	push	r16
    147e:	1f 93       	push	r17
    1480:	cf 93       	push	r28
    1482:	df 93       	push	r29
    1484:	8c 01       	movw	r16, r24
    1486:	c0 91 a9 06 	lds	r28, 0x06A9	; 0x8006a9 <ch0+0x5>
    148a:	d0 91 aa 06 	lds	r29, 0x06AA	; 0x8006aa <ch0+0x6>
 *
 * @xclass
 */
static inline mutex_t *chMtxGetNextMutexX(void) {

  return chThdGetSelfX()->mtxlist;
    148e:	eb 8c       	ldd	r14, Y+27	; 0x1b
    1490:	fc 8c       	ldd	r15, Y+28	; 0x1c
  chDbgCheckClassS();
  chDbgCheck(cp != NULL);
  chDbgAssert(mp != NULL, "not owning a mutex");

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
    1492:	c7 01       	movw	r24, r14
    1494:	8c df       	rcall	.-232    	; 0x13ae <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currtp->u.wtobjp = cp;
    1496:	1b 8b       	std	Y+19, r17	; 0x13
    1498:	0a 8b       	std	Y+18, r16	; 0x12
  ch_sch_prio_insert(&cp->queue, &currtp->hdr.queue);
    149a:	d8 01       	movw	r26, r16
    149c:	f8 01       	movw	r30, r16
    149e:	04 c0       	rjmp	.+8      	; 0x14a8 <chCondWaitS+0x30>
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
  } while ((cp != qp) &&
    14a0:	94 81       	ldd	r25, Z+4	; 0x04
    14a2:	8c 81       	ldd	r24, Y+4	; 0x04
    14a4:	98 17       	cp	r25, r24
    14a6:	18 f1       	brcs	.+70     	; 0x14ee <chCondWaitS+0x76>
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
    14a8:	01 90       	ld	r0, Z+
    14aa:	f0 81       	ld	r31, Z
    14ac:	e0 2d       	mov	r30, r0
  } while ((cp != qp) &&
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
    14ae:	0e 17       	cp	r16, r30
    14b0:	1f 07       	cpc	r17, r31
    14b2:	b1 f7       	brne	.-20     	; 0x14a0 <chCondWaitS+0x28>
  tp->next       = cp;
    14b4:	b9 83       	std	Y+1, r27	; 0x01
    14b6:	a8 83       	st	Y, r26
  tp->prev       = cp->prev;
    14b8:	12 96       	adiw	r26, 0x02	; 2
    14ba:	ed 91       	ld	r30, X+
    14bc:	fc 91       	ld	r31, X
    14be:	13 97       	sbiw	r26, 0x03	; 3
    14c0:	fb 83       	std	Y+3, r31	; 0x03
    14c2:	ea 83       	std	Y+2, r30	; 0x02
  tp->prev->next = tp;
    14c4:	d1 83       	std	Z+1, r29	; 0x01
    14c6:	c0 83       	st	Z, r28
  cp->prev       = tp;
    14c8:	13 96       	adiw	r26, 0x03	; 3
    14ca:	dc 93       	st	X, r29
    14cc:	ce 93       	st	-X, r28
    14ce:	12 97       	sbiw	r26, 0x02	; 2
  chSchGoSleepS(CH_STATE_WTCOND);
    14d0:	87 e0       	ldi	r24, 0x07	; 7
    14d2:	76 db       	rcall	.-2324   	; 0xbc0 <chSchGoSleepS>
  msg = currtp->u.rdymsg;
    14d4:	0a 88       	ldd	r0, Y+18	; 0x12
    14d6:	db 89       	ldd	r29, Y+19	; 0x13
  chMtxLockS(mp);
    14d8:	c0 2d       	mov	r28, r0
    14da:	c7 01       	movw	r24, r14
    14dc:	3c de       	rcall	.-904    	; 0x1156 <chMtxLockS>

  return msg;
}
    14de:	ce 01       	movw	r24, r28
    14e0:	df 91       	pop	r29
    14e2:	cf 91       	pop	r28
    14e4:	1f 91       	pop	r17
    14e6:	0f 91       	pop	r16
    14e8:	ff 90       	pop	r15
    14ea:	ef 90       	pop	r14
    14ec:	08 95       	ret
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
    14ee:	df 01       	movw	r26, r30
    14f0:	e1 cf       	rjmp	.-62     	; 0x14b4 <chCondWaitS+0x3c>

000014f2 <chCondWait>:
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    14f2:	f8 94       	cli
 */
msg_t chCondWait(condition_variable_t *cp) {
  msg_t msg;

  chSysLock();
  msg = chCondWaitS(cp);
    14f4:	c1 df       	rcall	.-126    	; 0x1478 <chCondWaitS>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    14f6:	78 94       	sei
  chSysUnlock();
  return msg;
}
    14f8:	08 95       	ret

000014fa <chEvtSignalI>:

  chSysLock();
  chEvtSignalI(tp, events);
  chSchRescheduleS();
  chSysUnlock();
}
    14fa:	fc 01       	movw	r30, r24
    14fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    14fe:	68 2b       	or	r22, r24
    1500:	62 8f       	std	Z+26, r22	; 0x1a
    1502:	87 85       	ldd	r24, Z+15	; 0x0f
    1504:	8a 30       	cpi	r24, 0x0A	; 10
    1506:	59 f0       	breq	.+22     	; 0x151e <chEvtSignalI+0x24>
    1508:	8b 30       	cpi	r24, 0x0B	; 11
    150a:	09 f0       	breq	.+2      	; 0x150e <chEvtSignalI+0x14>
    150c:	08 95       	ret
    150e:	82 89       	ldd	r24, Z+18	; 0x12
    1510:	68 23       	and	r22, r24
    1512:	86 13       	cpse	r24, r22
    1514:	fb cf       	rjmp	.-10     	; 0x150c <chEvtSignalI+0x12>
    1516:	13 8a       	std	Z+19, r1	; 0x13
    1518:	12 8a       	std	Z+18, r1	; 0x12
    151a:	cf 01       	movw	r24, r30
    151c:	2d cb       	rjmp	.-2470   	; 0xb78 <chSchReadyI>
    151e:	82 89       	ldd	r24, Z+18	; 0x12
    1520:	68 23       	and	r22, r24
    1522:	c9 f7       	brne	.-14     	; 0x1516 <chEvtSignalI+0x1c>
    1524:	08 95       	ret

00001526 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
    1526:	ef 92       	push	r14
    1528:	ff 92       	push	r15
    152a:	1f 93       	push	r17
    152c:	cf 93       	push	r28
    152e:	df 93       	push	r29
    1530:	7c 01       	movw	r14, r24
    1532:	16 2f       	mov	r17, r22
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
    1534:	fc 01       	movw	r30, r24
    1536:	c0 81       	ld	r28, Z
    1538:	d1 81       	ldd	r29, Z+1	; 0x01
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    153a:	8c 17       	cp	r24, r28
    153c:	9d 07       	cpc	r25, r29
    153e:	91 f0       	breq	.+36     	; 0x1564 <chEvtBroadcastFlagsI+0x3e>
  /*lint -restore*/
    elp->flags |= flags;
    1540:	8d 81       	ldd	r24, Y+5	; 0x05
    1542:	81 2b       	or	r24, r17
    1544:	8d 83       	std	Y+5, r24	; 0x05
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    1546:	11 23       	and	r17, r17
    1548:	19 f0       	breq	.+6      	; 0x1550 <chEvtBroadcastFlagsI+0x2a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
    154a:	8e 81       	ldd	r24, Y+6	; 0x06
    154c:	81 23       	and	r24, r17
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    154e:	21 f0       	breq	.+8      	; 0x1558 <chEvtBroadcastFlagsI+0x32>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    1550:	6c 81       	ldd	r22, Y+4	; 0x04
    1552:	8a 81       	ldd	r24, Y+2	; 0x02
    1554:	9b 81       	ldd	r25, Y+3	; 0x03
    1556:	d1 df       	rcall	.-94     	; 0x14fa <chEvtSignalI>
    }
    elp = elp->next;
    1558:	09 90       	ld	r0, Y+
    155a:	d8 81       	ld	r29, Y
    155c:	c0 2d       	mov	r28, r0
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    155e:	ec 16       	cp	r14, r28
    1560:	fd 06       	cpc	r15, r29
    1562:	71 f7       	brne	.-36     	; 0x1540 <chEvtBroadcastFlagsI+0x1a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
  }
}
    1564:	df 91       	pop	r29
    1566:	cf 91       	pop	r28
    1568:	1f 91       	pop	r17
    156a:	ff 90       	pop	r15
    156c:	ef 90       	pop	r14
    156e:	08 95       	ret

00001570 <__core_init>:
  chSysLock();
  p = chCoreAllocFromBaseI(size, align, offset);
  chSysUnlock();

  return p;
}
    1570:	e7 ee       	ldi	r30, 0xE7	; 231
    1572:	f6 e0       	ldi	r31, 0x06	; 6
    1574:	89 ef       	ldi	r24, 0xF9	; 249
    1576:	91 e0       	ldi	r25, 0x01	; 1
    1578:	91 83       	std	Z+1, r25	; 0x01
    157a:	80 83       	st	Z, r24
    157c:	89 e7       	ldi	r24, 0x79	; 121
    157e:	92 e0       	ldi	r25, 0x02	; 2
    1580:	93 83       	std	Z+3, r25	; 0x03
    1582:	82 83       	std	Z+2, r24	; 0x02
    1584:	08 95       	ret

00001586 <chCoreAllocFromTop>:
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1586:	f8 94       	cli
  uint8_t *p, *prev;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
    1588:	e0 91 e9 06 	lds	r30, 0x06E9	; 0x8006e9 <ch_memcore+0x2>
    158c:	f0 91 ea 06 	lds	r31, 0x06EA	; 0x8006ea <ch_memcore+0x3>
    1590:	9f 01       	movw	r18, r30
    1592:	28 1b       	sub	r18, r24
    1594:	39 0b       	sbc	r19, r25
    1596:	c9 01       	movw	r24, r18
    1598:	71 95       	neg	r23
    159a:	61 95       	neg	r22
    159c:	71 09       	sbc	r23, r1
    159e:	86 23       	and	r24, r22
    15a0:	97 23       	and	r25, r23
  prev = p - offset;
    15a2:	9c 01       	movw	r18, r24
    15a4:	24 1b       	sub	r18, r20
    15a6:	35 0b       	sbc	r19, r21

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
    15a8:	40 91 e7 06 	lds	r20, 0x06E7	; 0x8006e7 <ch_memcore>
    15ac:	50 91 e8 06 	lds	r21, 0x06E8	; 0x8006e8 <ch_memcore+0x1>
    15b0:	24 17       	cp	r18, r20
    15b2:	35 07       	cpc	r19, r21
    15b4:	48 f0       	brcs	.+18     	; 0x15c8 <chCoreAllocFromTop+0x42>
    15b6:	e2 17       	cp	r30, r18
    15b8:	f3 07       	cpc	r31, r19
    15ba:	30 f0       	brcs	.+12     	; 0x15c8 <chCoreAllocFromTop+0x42>
    return NULL;
  }

  ch_memcore.topmem = prev;
    15bc:	30 93 ea 06 	sts	0x06EA, r19	; 0x8006ea <ch_memcore+0x3>
    15c0:	20 93 e9 06 	sts	0x06E9, r18	; 0x8006e9 <ch_memcore+0x2>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    15c4:	78 94       	sei
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
    15c6:	08 95       	ret
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
  prev = p - offset;

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
    return NULL;
    15c8:	90 e0       	ldi	r25, 0x00	; 0
    15ca:	80 e0       	ldi	r24, 0x00	; 0
    15cc:	78 94       	sei
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
    15ce:	08 95       	ret

000015d0 <__heap_init>:
 *
 * @notapi
 */
void __heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
    15d0:	e9 e7       	ldi	r30, 0x79	; 121
    15d2:	f2 e0       	ldi	r31, 0x02	; 2
    15d4:	83 ec       	ldi	r24, 0xC3	; 195
    15d6:	9a e0       	ldi	r25, 0x0A	; 10
    15d8:	91 83       	std	Z+1, r25	; 0x01
    15da:	80 83       	st	Z, r24
  H_NEXT(&default_heap.header) = NULL;
    15dc:	13 82       	std	Z+3, r1	; 0x03
    15de:	12 82       	std	Z+2, r1	; 0x02
  H_PAGES(&default_heap.header) = 0;
    15e0:	15 82       	std	Z+5, r1	; 0x05
    15e2:	14 82       	std	Z+4, r1	; 0x04
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
    15e4:	8f e7       	ldi	r24, 0x7F	; 127
    15e6:	92 e0       	ldi	r25, 0x02	; 2
    15e8:	ae cd       	rjmp	.-1188   	; 0x1146 <chMtxObjectInit>

000015ea <_port_switch>:
void _port_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;
  (void)otp;

  asm volatile ("push    r2");
    15ea:	2f 92       	push	r2
  asm volatile ("push    r3");
    15ec:	3f 92       	push	r3
  asm volatile ("push    r4");
    15ee:	4f 92       	push	r4
  asm volatile ("push    r5");
    15f0:	5f 92       	push	r5
  asm volatile ("push    r6");
    15f2:	6f 92       	push	r6
  asm volatile ("push    r7");
    15f4:	7f 92       	push	r7
  asm volatile ("push    r8");
    15f6:	8f 92       	push	r8
  asm volatile ("push    r9");
    15f8:	9f 92       	push	r9
  asm volatile ("push    r10");
    15fa:	af 92       	push	r10
  asm volatile ("push    r11");
    15fc:	bf 92       	push	r11
  asm volatile ("push    r12");
    15fe:	cf 92       	push	r12
  asm volatile ("push    r13");
    1600:	df 92       	push	r13
  asm volatile ("push    r14");
    1602:	ef 92       	push	r14
  asm volatile ("push    r15");
    1604:	ff 92       	push	r15
  asm volatile ("push    r16");
    1606:	0f 93       	push	r16
  asm volatile ("push    r17");
    1608:	1f 93       	push	r17
  asm volatile ("push    r28");
    160a:	cf 93       	push	r28
  asm volatile ("push    r29");
    160c:	df 93       	push	r29

#if defined(__CHIBIOS_RT__)
  asm volatile ("movw    r30, r22");
    160e:	fb 01       	movw	r30, r22
  asm volatile ("in      r0, 0x3d");
    1610:	0d b6       	in	r0, 0x3d	; 61
  asm volatile ("std     Z+5, r0");
    1612:	05 82       	std	Z+5, r0	; 0x05
  asm volatile ("in      r0, 0x3e");
    1614:	0e b6       	in	r0, 0x3e	; 62
  asm volatile ("std     Z+6, r0");
    1616:	06 82       	std	Z+6, r0	; 0x06

  asm volatile ("movw    r30, r24");
    1618:	fc 01       	movw	r30, r24
  asm volatile ("ldd     r0, Z+5");
    161a:	05 80       	ldd	r0, Z+5	; 0x05
  asm volatile ("out     0x3d, r0");
    161c:	0d be       	out	0x3d, r0	; 61
  asm volatile ("ldd     r0, Z+6");
    161e:	06 80       	ldd	r0, Z+6	; 0x06
  asm volatile ("out     0x3e, r0");
    1620:	0e be       	out	0x3e, r0	; 62
  asm volatile ("out     0x3d, r0");
  asm volatile ("ldd     r0, Z+1");
  asm volatile ("out     0x3e, r0");
#endif

  asm volatile ("pop     r29");
    1622:	df 91       	pop	r29
  asm volatile ("pop     r28");
    1624:	cf 91       	pop	r28
  asm volatile ("pop     r17");
    1626:	1f 91       	pop	r17
  asm volatile ("pop     r16");
    1628:	0f 91       	pop	r16
  asm volatile ("pop     r15");
    162a:	ff 90       	pop	r15
  asm volatile ("pop     r14");
    162c:	ef 90       	pop	r14
  asm volatile ("pop     r13");
    162e:	df 90       	pop	r13
  asm volatile ("pop     r12");
    1630:	cf 90       	pop	r12
  asm volatile ("pop     r11");
    1632:	bf 90       	pop	r11
  asm volatile ("pop     r10");
    1634:	af 90       	pop	r10
  asm volatile ("pop     r9");
    1636:	9f 90       	pop	r9
  asm volatile ("pop     r8");
    1638:	8f 90       	pop	r8
  asm volatile ("pop     r7");
    163a:	7f 90       	pop	r7
  asm volatile ("pop     r6");
    163c:	6f 90       	pop	r6
  asm volatile ("pop     r5");
    163e:	5f 90       	pop	r5
  asm volatile ("pop     r4");
    1640:	4f 90       	pop	r4
  asm volatile ("pop     r3");
    1642:	3f 90       	pop	r3
  asm volatile ("pop     r2");
    1644:	2f 90       	pop	r2
  asm volatile ("ret");
    1646:	08 95       	ret

00001648 <_port_thread_start>:
    1648:	78 94       	sei
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
  asm volatile ("movw    r24, r4");
    164a:	c2 01       	movw	r24, r4
  asm volatile ("movw    r30, r2");
    164c:	f1 01       	movw	r30, r2
  asm volatile ("icall");
    164e:	09 95       	icall
  asm volatile ("call    chThdExit");  /* Used for avr5 Architecture. */
    1650:	3c cd       	rjmp	.-1416   	; 0x10ca <chThdExit>
}
    1652:	08 95       	ret

00001654 <AvenidaPrincipalSinalAmarelo>:
}

int IsBufferFull()
{
  return qsize >= QUEUE_SIZE;
}
    1654:	cf 93       	push	r28
    1656:	df 93       	push	r29
    1658:	ec 01       	movw	r28, r24
    165a:	80 91 30 05 	lds	r24, 0x0530	; 0x800530 <counter>
    165e:	90 91 31 05 	lds	r25, 0x0531	; 0x800531 <counter+0x1>
    1662:	a0 91 32 05 	lds	r26, 0x0532	; 0x800532 <counter+0x2>
    1666:	b0 91 33 05 	lds	r27, 0x0533	; 0x800533 <counter+0x3>
    166a:	01 96       	adiw	r24, 0x01	; 1
    166c:	a1 1d       	adc	r26, r1
    166e:	b1 1d       	adc	r27, r1
    1670:	85 30       	cpi	r24, 0x05	; 5
    1672:	91 05       	cpc	r25, r1
    1674:	a1 05       	cpc	r26, r1
    1676:	b1 05       	cpc	r27, r1
    1678:	10 f1       	brcs	.+68     	; 0x16be <AvenidaPrincipalSinalAmarelo+0x6a>
    167a:	10 92 30 05 	sts	0x0530, r1	; 0x800530 <counter>
    167e:	10 92 31 05 	sts	0x0531, r1	; 0x800531 <counter+0x1>
    1682:	10 92 32 05 	sts	0x0532, r1	; 0x800532 <counter+0x2>
    1686:	10 92 33 05 	sts	0x0533, r1	; 0x800533 <counter+0x3>
    168a:	28 98       	cbi	0x05, 0	; 5
    168c:	5f 98       	cbi	0x0b, 7	; 11
    168e:	5e 9a       	sbi	0x0b, 6	; 11
    1690:	f8 94       	cli
    1692:	88 81       	ld	r24, Y
    1694:	99 81       	ldd	r25, Y+1	; 0x01
    1696:	89 2b       	or	r24, r25
    1698:	11 f0       	breq	.+4      	; 0x169e <AvenidaPrincipalSinalAmarelo+0x4a>
    169a:	ce 01       	movw	r24, r28
    169c:	86 d9       	rcall	.-3316   	; 0x9aa <chVTDoResetI>
    169e:	78 94       	sei
    16a0:	88 81       	ld	r24, Y
    16a2:	99 81       	ldd	r25, Y+1	; 0x01
    16a4:	89 2b       	or	r24, r25
    16a6:	11 f0       	breq	.+4      	; 0x16ac <AvenidaPrincipalSinalAmarelo+0x58>
    16a8:	ce 01       	movw	r24, r28
    16aa:	7f d9       	rcall	.-3330   	; 0x9aa <chVTDoResetI>
    16ac:	9e 01       	movw	r18, r28
    16ae:	4a e2       	ldi	r20, 0x2A	; 42
    16b0:	5b e0       	ldi	r21, 0x0B	; 11
    16b2:	68 e0       	ldi	r22, 0x08	; 8
    16b4:	7d e3       	ldi	r23, 0x3D	; 61
    16b6:	ce 01       	movw	r24, r28
    16b8:	df 91       	pop	r29
    16ba:	cf 91       	pop	r28
    16bc:	34 c9       	rjmp	.-3480   	; 0x926 <chVTDoSetI>
    16be:	80 93 30 05 	sts	0x0530, r24	; 0x800530 <counter>
    16c2:	90 93 31 05 	sts	0x0531, r25	; 0x800531 <counter+0x1>
    16c6:	a0 93 32 05 	sts	0x0532, r26	; 0x800532 <counter+0x2>
    16ca:	b0 93 33 05 	sts	0x0533, r27	; 0x800533 <counter+0x3>
    16ce:	e8 cf       	rjmp	.-48     	; 0x16a0 <AvenidaPrincipalSinalAmarelo+0x4c>

000016d0 <AvenidaPrincipalSinalVerde>:
    16d0:	cf 93       	push	r28
    16d2:	df 93       	push	r29
    16d4:	ec 01       	movw	r28, r24
    16d6:	40 91 30 05 	lds	r20, 0x0530	; 0x800530 <counter>
    16da:	50 91 31 05 	lds	r21, 0x0531	; 0x800531 <counter+0x1>
    16de:	60 91 32 05 	lds	r22, 0x0532	; 0x800532 <counter+0x2>
    16e2:	70 91 33 05 	lds	r23, 0x0533	; 0x800533 <counter+0x3>
    16e6:	4f 5f       	subi	r20, 0xFF	; 255
    16e8:	5f 4f       	sbci	r21, 0xFF	; 255
    16ea:	6f 4f       	sbci	r22, 0xFF	; 255
    16ec:	7f 4f       	sbci	r23, 0xFF	; 255
    16ee:	40 93 30 05 	sts	0x0530, r20	; 0x800530 <counter>
    16f2:	50 93 31 05 	sts	0x0531, r21	; 0x800531 <counter+0x1>
    16f6:	60 93 32 05 	sts	0x0532, r22	; 0x800532 <counter+0x2>
    16fa:	70 93 33 05 	sts	0x0533, r23	; 0x800533 <counter+0x3>
    16fe:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <EVENT>
    1702:	82 30       	cpi	r24, 0x02	; 2
    1704:	79 f4       	brne	.+30     	; 0x1724 <AvenidaPrincipalSinalVerde+0x54>
    1706:	80 e1       	ldi	r24, 0x10	; 16
    1708:	90 e0       	ldi	r25, 0x00	; 0
    170a:	e1 dc       	rcall	.-1598   	; 0x10ce <chThdSleep>
    170c:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <EVENT>
    1710:	82 30       	cpi	r24, 0x02	; 2
    1712:	c9 f3       	breq	.-14     	; 0x1706 <AvenidaPrincipalSinalVerde+0x36>
    1714:	40 91 30 05 	lds	r20, 0x0530	; 0x800530 <counter>
    1718:	50 91 31 05 	lds	r21, 0x0531	; 0x800531 <counter+0x1>
    171c:	60 91 32 05 	lds	r22, 0x0532	; 0x800532 <counter+0x2>
    1720:	70 91 33 05 	lds	r23, 0x0533	; 0x800533 <counter+0x3>
    1724:	48 32       	cpi	r20, 0x28	; 40
    1726:	51 05       	cpc	r21, r1
    1728:	61 05       	cpc	r22, r1
    172a:	71 05       	cpc	r23, r1
    172c:	98 f1       	brcs	.+102    	; 0x1794 <AvenidaPrincipalSinalVerde+0xc4>
    172e:	9d ef       	ldi	r25, 0xFD	; 253
    1730:	98 0f       	add	r25, r24
    1732:	92 30       	cpi	r25, 0x02	; 2
    1734:	88 f0       	brcs	.+34     	; 0x1758 <AvenidaPrincipalSinalVerde+0x88>
    1736:	81 30       	cpi	r24, 0x01	; 1
    1738:	b1 f1       	breq	.+108    	; 0x17a6 <AvenidaPrincipalSinalVerde+0xd6>
    173a:	88 81       	ld	r24, Y
    173c:	99 81       	ldd	r25, Y+1	; 0x01
    173e:	89 2b       	or	r24, r25
    1740:	11 f0       	breq	.+4      	; 0x1746 <AvenidaPrincipalSinalVerde+0x76>
    1742:	ce 01       	movw	r24, r28
    1744:	32 d9       	rcall	.-3484   	; 0x9aa <chVTDoResetI>
    1746:	9e 01       	movw	r18, r28
    1748:	48 e6       	ldi	r20, 0x68	; 104
    174a:	5b e0       	ldi	r21, 0x0B	; 11
    174c:	68 e0       	ldi	r22, 0x08	; 8
    174e:	7d e3       	ldi	r23, 0x3D	; 61
    1750:	ce 01       	movw	r24, r28
    1752:	df 91       	pop	r29
    1754:	cf 91       	pop	r28
    1756:	e7 c8       	rjmp	.-3634   	; 0x926 <chVTDoSetI>
    1758:	10 92 30 05 	sts	0x0530, r1	; 0x800530 <counter>
    175c:	10 92 31 05 	sts	0x0531, r1	; 0x800531 <counter+0x1>
    1760:	10 92 32 05 	sts	0x0532, r1	; 0x800532 <counter+0x2>
    1764:	10 92 33 05 	sts	0x0533, r1	; 0x800533 <counter+0x3>
    1768:	28 98       	cbi	0x05, 0	; 5
    176a:	81 e0       	ldi	r24, 0x01	; 1
    176c:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
    1770:	80 93 34 05 	sts	0x0534, r24	; 0x800534 <LED_PRINCIPAL>
    1774:	f8 94       	cli
    1776:	88 81       	ld	r24, Y
    1778:	99 81       	ldd	r25, Y+1	; 0x01
    177a:	89 2b       	or	r24, r25
    177c:	11 f0       	breq	.+4      	; 0x1782 <AvenidaPrincipalSinalVerde+0xb2>
    177e:	ce 01       	movw	r24, r28
    1780:	14 d9       	rcall	.-3544   	; 0x9aa <chVTDoResetI>
    1782:	78 94       	sei
    1784:	40 91 30 05 	lds	r20, 0x0530	; 0x800530 <counter>
    1788:	50 91 31 05 	lds	r21, 0x0531	; 0x800531 <counter+0x1>
    178c:	60 91 32 05 	lds	r22, 0x0532	; 0x800532 <counter+0x2>
    1790:	70 91 33 05 	lds	r23, 0x0533	; 0x800533 <counter+0x3>
    1794:	4a 30       	cpi	r20, 0x0A	; 10
    1796:	51 05       	cpc	r21, r1
    1798:	61 05       	cpc	r22, r1
    179a:	71 05       	cpc	r23, r1
    179c:	70 f2       	brcs	.-100    	; 0x173a <AvenidaPrincipalSinalVerde+0x6a>
    179e:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <EVENT>
    17a2:	81 30       	cpi	r24, 0x01	; 1
    17a4:	51 f6       	brne	.-108    	; 0x173a <AvenidaPrincipalSinalVerde+0x6a>
    17a6:	10 92 30 05 	sts	0x0530, r1	; 0x800530 <counter>
    17aa:	10 92 31 05 	sts	0x0531, r1	; 0x800531 <counter+0x1>
    17ae:	10 92 32 05 	sts	0x0532, r1	; 0x800532 <counter+0x2>
    17b2:	10 92 33 05 	sts	0x0533, r1	; 0x800533 <counter+0x3>
    17b6:	28 98       	cbi	0x05, 0	; 5
    17b8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
    17bc:	80 93 34 05 	sts	0x0534, r24	; 0x800534 <LED_PRINCIPAL>
    17c0:	f8 94       	cli
    17c2:	88 81       	ld	r24, Y
    17c4:	99 81       	ldd	r25, Y+1	; 0x01
    17c6:	89 2b       	or	r24, r25
    17c8:	11 f0       	breq	.+4      	; 0x17ce <AvenidaPrincipalSinalVerde+0xfe>
    17ca:	ce 01       	movw	r24, r28
    17cc:	ee d8       	rcall	.-3620   	; 0x9aa <chVTDoResetI>
    17ce:	78 94       	sei
    17d0:	b4 cf       	rjmp	.-152    	; 0x173a <AvenidaPrincipalSinalVerde+0x6a>

000017d2 <InitBuffer>:
    17d2:	8a e4       	ldi	r24, 0x4A	; 74
    17d4:	95 e0       	ldi	r25, 0x05	; 5
    17d6:	b7 dc       	rcall	.-1682   	; 0x1146 <chMtxObjectInit>
    17d8:	86 e4       	ldi	r24, 0x46	; 70
    17da:	95 e0       	ldi	r25, 0x05	; 5
    17dc:	2e de       	rcall	.-932    	; 0x143a <chCondObjectInit>
    17de:	82 e4       	ldi	r24, 0x42	; 66
    17e0:	95 e0       	ldi	r25, 0x05	; 5
    17e2:	2b de       	rcall	.-938    	; 0x143a <chCondObjectInit>
    17e4:	88 e5       	ldi	r24, 0x58	; 88
    17e6:	95 e0       	ldi	r25, 0x05	; 5
    17e8:	90 93 55 05 	sts	0x0555, r25	; 0x800555 <wrp+0x1>
    17ec:	80 93 54 05 	sts	0x0554, r24	; 0x800554 <wrp>
    17f0:	90 93 57 05 	sts	0x0557, r25	; 0x800557 <rdp+0x1>
    17f4:	80 93 56 05 	sts	0x0556, r24	; 0x800556 <rdp>
    17f8:	10 92 53 05 	sts	0x0553, r1	; 0x800553 <qsize+0x1>
    17fc:	10 92 52 05 	sts	0x0552, r1	; 0x800552 <qsize>
    1800:	08 95       	ret

00001802 <main>:
    1802:	cf 93       	push	r28
    1804:	df 93       	push	r29
    1806:	00 d0       	rcall	.+0      	; 0x1808 <main+0x6>
    1808:	1f 92       	push	r1
    180a:	cd b7       	in	r28, 0x3d	; 61
    180c:	de b7       	in	r29, 0x3e	; 62
    180e:	80 e1       	ldi	r24, 0x10	; 16
    1810:	90 e0       	ldi	r25, 0x00	; 0
    1812:	9a 83       	std	Y+2, r25	; 0x02
    1814:	89 83       	std	Y+1, r24	; 0x01
    1816:	83 e0       	ldi	r24, 0x03	; 3
    1818:	8b 83       	std	Y+3, r24	; 0x03
    181a:	db df       	rcall	.-74     	; 0x17d2 <InitBuffer>
    181c:	10 92 37 05 	sts	0x0537, r1	; 0x800537 <vt+0x1>
    1820:	10 92 36 05 	sts	0x0536, r1	; 0x800536 <vt>
    1824:	0e 94 63 00 	call	0xc6	; 0xc6 <halInit>
    1828:	68 d8       	rcall	.-3888   	; 0x8fa <chSysInit>
    182a:	be 01       	movw	r22, r28
    182c:	6f 5f       	subi	r22, 0xFF	; 255
    182e:	7f 4f       	sbci	r23, 0xFF	; 255
    1830:	88 e5       	ldi	r24, 0x58	; 88
    1832:	96 e0       	ldi	r25, 0x06	; 6
    1834:	0e 94 08 03 	call	0x610	; 0x610 <sdStart>
    1838:	43 e0       	ldi	r20, 0x03	; 3
    183a:	60 e1       	ldi	r22, 0x10	; 16
    183c:	83 e2       	ldi	r24, 0x23	; 35
    183e:	90 e0       	ldi	r25, 0x00	; 0
    1840:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1844:	43 e0       	ldi	r20, 0x03	; 3
    1846:	68 e0       	ldi	r22, 0x08	; 8
    1848:	83 e2       	ldi	r24, 0x23	; 35
    184a:	90 e0       	ldi	r25, 0x00	; 0
    184c:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1850:	43 e0       	ldi	r20, 0x03	; 3
    1852:	64 e0       	ldi	r22, 0x04	; 4
    1854:	83 e2       	ldi	r24, 0x23	; 35
    1856:	90 e0       	ldi	r25, 0x00	; 0
    1858:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    185c:	43 e0       	ldi	r20, 0x03	; 3
    185e:	62 e0       	ldi	r22, 0x02	; 2
    1860:	83 e2       	ldi	r24, 0x23	; 35
    1862:	90 e0       	ldi	r25, 0x00	; 0
    1864:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1868:	46 e0       	ldi	r20, 0x06	; 6
    186a:	61 e0       	ldi	r22, 0x01	; 1
    186c:	83 e2       	ldi	r24, 0x23	; 35
    186e:	90 e0       	ldi	r25, 0x00	; 0
    1870:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1874:	28 98       	cbi	0x05, 0	; 5
    1876:	46 e0       	ldi	r20, 0x06	; 6
    1878:	60 e8       	ldi	r22, 0x80	; 128
    187a:	89 e2       	ldi	r24, 0x29	; 41
    187c:	90 e0       	ldi	r25, 0x00	; 0
    187e:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1882:	5f 98       	cbi	0x0b, 7	; 11
    1884:	46 e0       	ldi	r20, 0x06	; 6
    1886:	60 e4       	ldi	r22, 0x40	; 64
    1888:	89 e2       	ldi	r24, 0x29	; 41
    188a:	90 e0       	ldi	r25, 0x00	; 0
    188c:	0e 94 66 03 	call	0x6cc	; 0x6cc <_pal_lld_setgroupmode>
    1890:	5e 98       	cbi	0x0b, 6	; 11
    1892:	10 e0       	ldi	r17, 0x00	; 0
    1894:	00 e0       	ldi	r16, 0x00	; 0
    1896:	20 ea       	ldi	r18, 0xA0	; 160
    1898:	3c e0       	ldi	r19, 0x0C	; 12
    189a:	40 e8       	ldi	r20, 0x80	; 128
    189c:	63 ee       	ldi	r22, 0xE3	; 227
    189e:	70 e0       	ldi	r23, 0x00	; 0
    18a0:	8d e4       	ldi	r24, 0x4D	; 77
    18a2:	94 e0       	ldi	r25, 0x04	; 4
    18a4:	97 db       	rcall	.-2258   	; 0xfd4 <chThdCreateStatic>
    18a6:	2d ef       	ldi	r18, 0xFD	; 253
    18a8:	3c e0       	ldi	r19, 0x0C	; 12
    18aa:	40 e8       	ldi	r20, 0x80	; 128
    18ac:	63 ee       	ldi	r22, 0xE3	; 227
    18ae:	70 e0       	ldi	r23, 0x00	; 0
    18b0:	8a e6       	ldi	r24, 0x6A	; 106
    18b2:	93 e0       	ldi	r25, 0x03	; 3
    18b4:	8f db       	rcall	.-2274   	; 0xfd4 <chThdCreateStatic>
    18b6:	2c e4       	ldi	r18, 0x4C	; 76
    18b8:	3d e0       	ldi	r19, 0x0D	; 13
    18ba:	40 e8       	ldi	r20, 0x80	; 128
    18bc:	63 ee       	ldi	r22, 0xE3	; 227
    18be:	70 e0       	ldi	r23, 0x00	; 0
    18c0:	87 e8       	ldi	r24, 0x87	; 135
    18c2:	92 e0       	ldi	r25, 0x02	; 2
    18c4:	87 db       	rcall	.-2290   	; 0xfd4 <chThdCreateStatic>
    18c6:	80 e1       	ldi	r24, 0x10	; 16
    18c8:	90 e0       	ldi	r25, 0x00	; 0
    18ca:	01 dc       	rcall	.-2046   	; 0x10ce <chThdSleep>
    18cc:	fc cf       	rjmp	.-8      	; 0x18c6 <main+0xc4>

000018ce <PushBUffer>:
    18ce:	cf 93       	push	r28
    18d0:	df 93       	push	r29
    18d2:	ec 01       	movw	r28, r24
    18d4:	8a e4       	ldi	r24, 0x4A	; 74
    18d6:	95 e0       	ldi	r25, 0x05	; 5
    18d8:	1c dd       	rcall	.-1480   	; 0x1312 <chMtxLock>
    18da:	80 91 52 05 	lds	r24, 0x0552	; 0x800552 <qsize>
    18de:	90 91 53 05 	lds	r25, 0x0553	; 0x800553 <qsize+0x1>
    18e2:	80 38       	cpi	r24, 0x80	; 128
    18e4:	91 05       	cpc	r25, r1
    18e6:	50 f0       	brcs	.+20     	; 0x18fc <PushBUffer+0x2e>
    18e8:	82 e4       	ldi	r24, 0x42	; 66
    18ea:	95 e0       	ldi	r25, 0x05	; 5
    18ec:	02 de       	rcall	.-1020   	; 0x14f2 <chCondWait>
    18ee:	80 91 52 05 	lds	r24, 0x0552	; 0x800552 <qsize>
    18f2:	90 91 53 05 	lds	r25, 0x0553	; 0x800553 <qsize+0x1>
    18f6:	80 38       	cpi	r24, 0x80	; 128
    18f8:	91 05       	cpc	r25, r1
    18fa:	b0 f7       	brcc	.-20     	; 0x18e8 <PushBUffer+0x1a>
    18fc:	e0 91 54 05 	lds	r30, 0x0554	; 0x800554 <wrp>
    1900:	f0 91 55 05 	lds	r31, 0x0555	; 0x800555 <wrp+0x1>
    1904:	c1 93       	st	Z+, r28
    1906:	d1 93       	st	Z+, r29
    1908:	26 e0       	ldi	r18, 0x06	; 6
    190a:	e8 35       	cpi	r30, 0x58	; 88
    190c:	f2 07       	cpc	r31, r18
    190e:	98 f0       	brcs	.+38     	; 0x1936 <PushBUffer+0x68>
    1910:	28 e5       	ldi	r18, 0x58	; 88
    1912:	35 e0       	ldi	r19, 0x05	; 5
    1914:	30 93 55 05 	sts	0x0555, r19	; 0x800555 <wrp+0x1>
    1918:	20 93 54 05 	sts	0x0554, r18	; 0x800554 <wrp>
    191c:	01 96       	adiw	r24, 0x01	; 1
    191e:	90 93 53 05 	sts	0x0553, r25	; 0x800553 <qsize+0x1>
    1922:	80 93 52 05 	sts	0x0552, r24	; 0x800552 <qsize>
    1926:	86 e4       	ldi	r24, 0x46	; 70
    1928:	95 e0       	ldi	r25, 0x05	; 5
    192a:	8d dd       	rcall	.-1254   	; 0x1446 <chCondSignal>
    192c:	8a e4       	ldi	r24, 0x4A	; 74
    192e:	95 e0       	ldi	r25, 0x05	; 5
    1930:	df 91       	pop	r29
    1932:	cf 91       	pop	r28
    1934:	f2 cc       	rjmp	.-1564   	; 0x131a <chMtxUnlock>
    1936:	f0 93 55 05 	sts	0x0555, r31	; 0x800555 <wrp+0x1>
    193a:	e0 93 54 05 	sts	0x0554, r30	; 0x800554 <wrp>
    193e:	ee cf       	rjmp	.-36     	; 0x191c <PushBUffer+0x4e>

00001940 <Write_Save_Event>:
    1940:	e0 91 a9 06 	lds	r30, 0x06A9	; 0x8006a9 <ch0+0x5>
    1944:	f0 91 aa 06 	lds	r31, 0x06AA	; 0x8006aa <ch0+0x6>
    1948:	8b e5       	ldi	r24, 0x5B	; 91
    194a:	91 e0       	ldi	r25, 0x01	; 1
    194c:	96 87       	std	Z+14, r25	; 0x0e
    194e:	85 87       	std	Z+13, r24	; 0x0d
    1950:	09 c0       	rjmp	.+18     	; 0x1964 <Write_Save_Event+0x24>
    1952:	1b 9b       	sbis	0x03, 3	; 3
    1954:	0e c0       	rjmp	.+28     	; 0x1972 <Write_Save_Event+0x32>
    1956:	1a 9b       	sbis	0x03, 2	; 3
    1958:	11 c0       	rjmp	.+34     	; 0x197c <Write_Save_Event+0x3c>
    195a:	19 9b       	sbis	0x03, 1	; 3
    195c:	14 c0       	rjmp	.+40     	; 0x1986 <Write_Save_Event+0x46>
    195e:	8b e1       	ldi	r24, 0x1B	; 27
    1960:	96 e0       	ldi	r25, 0x06	; 6
    1962:	b5 db       	rcall	.-2198   	; 0x10ce <chThdSleep>
    1964:	1c 99       	sbic	0x03, 4	; 3
    1966:	f5 cf       	rjmp	.-22     	; 0x1952 <Write_Save_Event+0x12>
    1968:	84 e0       	ldi	r24, 0x04	; 4
    196a:	90 e0       	ldi	r25, 0x00	; 0
    196c:	b0 df       	rcall	.-160    	; 0x18ce <PushBUffer>
    196e:	1b 99       	sbic	0x03, 3	; 3
    1970:	f2 cf       	rjmp	.-28     	; 0x1956 <Write_Save_Event+0x16>
    1972:	83 e0       	ldi	r24, 0x03	; 3
    1974:	90 e0       	ldi	r25, 0x00	; 0
    1976:	ab df       	rcall	.-170    	; 0x18ce <PushBUffer>
    1978:	1a 99       	sbic	0x03, 2	; 3
    197a:	ef cf       	rjmp	.-34     	; 0x195a <Write_Save_Event+0x1a>
    197c:	82 e0       	ldi	r24, 0x02	; 2
    197e:	90 e0       	ldi	r25, 0x00	; 0
    1980:	a6 df       	rcall	.-180    	; 0x18ce <PushBUffer>
    1982:	19 99       	sbic	0x03, 1	; 3
    1984:	ec cf       	rjmp	.-40     	; 0x195e <Write_Save_Event+0x1e>
    1986:	81 e0       	ldi	r24, 0x01	; 1
    1988:	90 e0       	ldi	r25, 0x00	; 0
    198a:	a1 df       	rcall	.-190    	; 0x18ce <PushBUffer>
    198c:	e8 cf       	rjmp	.-48     	; 0x195e <Write_Save_Event+0x1e>

0000198e <PopBUffer>:
    198e:	cf 93       	push	r28
    1990:	8a e4       	ldi	r24, 0x4A	; 74
    1992:	95 e0       	ldi	r25, 0x05	; 5
    1994:	be dc       	rcall	.-1668   	; 0x1312 <chMtxLock>
    1996:	80 91 52 05 	lds	r24, 0x0552	; 0x800552 <qsize>
    199a:	90 91 53 05 	lds	r25, 0x0553	; 0x800553 <qsize+0x1>
    199e:	00 97       	sbiw	r24, 0x00	; 0
    19a0:	49 f4       	brne	.+18     	; 0x19b4 <PopBUffer+0x26>
    19a2:	86 e4       	ldi	r24, 0x46	; 70
    19a4:	95 e0       	ldi	r25, 0x05	; 5
    19a6:	a5 dd       	rcall	.-1206   	; 0x14f2 <chCondWait>
    19a8:	80 91 52 05 	lds	r24, 0x0552	; 0x800552 <qsize>
    19ac:	90 91 53 05 	lds	r25, 0x0553	; 0x800553 <qsize+0x1>
    19b0:	00 97       	sbiw	r24, 0x00	; 0
    19b2:	b9 f3       	breq	.-18     	; 0x19a2 <PopBUffer+0x14>
    19b4:	e0 91 56 05 	lds	r30, 0x0556	; 0x800556 <rdp>
    19b8:	f0 91 57 05 	lds	r31, 0x0557	; 0x800557 <rdp+0x1>
    19bc:	c0 81       	ld	r28, Z
    19be:	32 96       	adiw	r30, 0x02	; 2
    19c0:	26 e0       	ldi	r18, 0x06	; 6
    19c2:	e8 35       	cpi	r30, 0x58	; 88
    19c4:	f2 07       	cpc	r31, r18
    19c6:	a0 f0       	brcs	.+40     	; 0x19f0 <PopBUffer+0x62>
    19c8:	28 e5       	ldi	r18, 0x58	; 88
    19ca:	35 e0       	ldi	r19, 0x05	; 5
    19cc:	30 93 57 05 	sts	0x0557, r19	; 0x800557 <rdp+0x1>
    19d0:	20 93 56 05 	sts	0x0556, r18	; 0x800556 <rdp>
    19d4:	01 97       	sbiw	r24, 0x01	; 1
    19d6:	90 93 53 05 	sts	0x0553, r25	; 0x800553 <qsize+0x1>
    19da:	80 93 52 05 	sts	0x0552, r24	; 0x800552 <qsize>
    19de:	82 e4       	ldi	r24, 0x42	; 66
    19e0:	95 e0       	ldi	r25, 0x05	; 5
    19e2:	31 dd       	rcall	.-1438   	; 0x1446 <chCondSignal>
    19e4:	8a e4       	ldi	r24, 0x4A	; 74
    19e6:	95 e0       	ldi	r25, 0x05	; 5
    19e8:	98 dc       	rcall	.-1744   	; 0x131a <chMtxUnlock>
    19ea:	8c 2f       	mov	r24, r28
    19ec:	cf 91       	pop	r28
    19ee:	08 95       	ret
    19f0:	f0 93 57 05 	sts	0x0557, r31	; 0x800557 <rdp+0x1>
    19f4:	e0 93 56 05 	sts	0x0556, r30	; 0x800556 <rdp>
    19f8:	ed cf       	rjmp	.-38     	; 0x19d4 <PopBUffer+0x46>

000019fa <Read_Collect_Event>:
    19fa:	e0 91 a9 06 	lds	r30, 0x06A9	; 0x8006a9 <ch0+0x5>
    19fe:	f0 91 aa 06 	lds	r31, 0x06AA	; 0x8006aa <ch0+0x6>
    1a02:	8c e6       	ldi	r24, 0x6C	; 108
    1a04:	91 e0       	ldi	r25, 0x01	; 1
    1a06:	96 87       	std	Z+14, r25	; 0x0e
    1a08:	85 87       	std	Z+13, r24	; 0x0d
    1a0a:	03 c0       	rjmp	.+6      	; 0x1a12 <Read_Collect_Event+0x18>
    1a0c:	80 e1       	ldi	r24, 0x10	; 16
    1a0e:	90 e0       	ldi	r25, 0x00	; 0
    1a10:	5e db       	rcall	.-2372   	; 0x10ce <chThdSleep>
    1a12:	80 91 52 05 	lds	r24, 0x0552	; 0x800552 <qsize>
    1a16:	90 91 53 05 	lds	r25, 0x0553	; 0x800553 <qsize+0x1>
    1a1a:	89 2b       	or	r24, r25
    1a1c:	b9 f3       	breq	.-18     	; 0x1a0c <Read_Collect_Event+0x12>
    1a1e:	b7 df       	rcall	.-146    	; 0x198e <PopBUffer>
    1a20:	80 93 35 05 	sts	0x0535, r24	; 0x800535 <EVENT>
    1a24:	f3 cf       	rjmp	.-26     	; 0x1a0c <Read_Collect_Event+0x12>

00001a26 <PrincipalTimer>:

/*====================== Avenida Principal ===============================*/
void PrincipalTimer()
{
  switch (LED_PRINCIPAL)
    1a26:	80 91 34 05 	lds	r24, 0x0534	; 0x800534 <LED_PRINCIPAL>
    1a2a:	88 23       	and	r24, r24
    1a2c:	e1 f0       	breq	.+56     	; 0x1a66 <PrincipalTimer+0x40>
    1a2e:	81 30       	cpi	r24, 0x01	; 1
    1a30:	c9 f4       	brne	.+50     	; 0x1a64 <PrincipalTimer+0x3e>
      break;
    }

    case AMARELO:
    {
      palClearPad(IOPORT2, LED_VERDE_PRINCIPAL);
    1a32:	28 98       	cbi	0x05, 0	; 5
      palClearPad(IOPORT4, LED_VERMELHO_PRINCIPAL);
    1a34:	5e 98       	cbi	0x0b, 6	; 11
      palSetPad(IOPORT4, LED_AMARELO_PRINCIPAL);
    1a36:	5f 9a       	sbi	0x0b, 7	; 11
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1a38:	f8 94       	cli
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
    1a3a:	80 91 36 05 	lds	r24, 0x0536	; 0x800536 <vt>
    1a3e:	90 91 37 05 	lds	r25, 0x0537	; 0x800537 <vt+0x1>
    1a42:	89 2b       	or	r24, r25
    1a44:	21 f0       	breq	.+8      	; 0x1a4e <PrincipalTimer+0x28>
    chVTDoResetI(vtp);
    1a46:	86 e3       	ldi	r24, 0x36	; 54
    1a48:	95 e0       	ldi	r25, 0x05	; 5
    1a4a:	0e 94 d5 04 	call	0x9aa	; 0x9aa <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
    1a4e:	26 e3       	ldi	r18, 0x36	; 54
    1a50:	35 e0       	ldi	r19, 0x05	; 5
    1a52:	4a e2       	ldi	r20, 0x2A	; 42
    1a54:	5b e0       	ldi	r21, 0x0B	; 11
    1a56:	68 e0       	ldi	r22, 0x08	; 8
    1a58:	7d e3       	ldi	r23, 0x3D	; 61
    1a5a:	c9 01       	movw	r24, r18
    1a5c:	0e 94 93 04 	call	0x926	; 0x926 <chVTDoSetI>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    1a60:	78 94       	sei
      chVTSet(&vt, TIME_MS2I(1000), AvenidaPrincipalSinalAmarelo, (void*)&vt);
      break;
    }
  }  
}
    1a62:	08 95       	ret
    1a64:	08 95       	ret
{
  switch (LED_PRINCIPAL)
  {
    case VERDE:
    {
      palSetPad(IOPORT2, LED_VERDE_PRINCIPAL);
    1a66:	28 9a       	sbi	0x05, 0	; 5
      palClearPad(IOPORT4, LED_AMARELO_PRINCIPAL);
    1a68:	5f 98       	cbi	0x0b, 7	; 11
      palClearPad(IOPORT4, LED_VERMELHO_PRINCIPAL);
    1a6a:	5e 98       	cbi	0x0b, 6	; 11
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1a6c:	f8 94       	cli
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
    1a6e:	80 91 36 05 	lds	r24, 0x0536	; 0x800536 <vt>
    1a72:	90 91 37 05 	lds	r25, 0x0537	; 0x800537 <vt+0x1>
    1a76:	89 2b       	or	r24, r25
    1a78:	21 f0       	breq	.+8      	; 0x1a82 <PrincipalTimer+0x5c>
    chVTDoResetI(vtp);
    1a7a:	86 e3       	ldi	r24, 0x36	; 54
    1a7c:	95 e0       	ldi	r25, 0x05	; 5
    1a7e:	0e 94 d5 04 	call	0x9aa	; 0x9aa <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
    1a82:	26 e3       	ldi	r18, 0x36	; 54
    1a84:	35 e0       	ldi	r19, 0x05	; 5
    1a86:	48 e6       	ldi	r20, 0x68	; 104
    1a88:	5b e0       	ldi	r21, 0x0B	; 11
    1a8a:	68 e0       	ldi	r22, 0x08	; 8
    1a8c:	7d e3       	ldi	r23, 0x3D	; 61
    1a8e:	c9 01       	movw	r24, r18
    1a90:	0e 94 93 04 	call	0x926	; 0x926 <chVTDoSetI>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    1a94:	78 94       	sei
    1a96:	08 95       	ret

00001a98 <ProcessEvent>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
    1a98:	e0 91 a9 06 	lds	r30, 0x06A9	; 0x8006a9 <ch0+0x5>
    1a9c:	f0 91 aa 06 	lds	r31, 0x06AA	; 0x8006aa <ch0+0x6>
    1aa0:	8f e7       	ldi	r24, 0x7F	; 127
    1aa2:	91 e0       	ldi	r25, 0x01	; 1
    1aa4:	96 87       	std	Z+14, r25	; 0x0e
    1aa6:	85 87       	std	Z+13, r24	; 0x0d
    1aa8:	03 c0       	rjmp	.+6      	; 0x1ab0 <ProcessEvent+0x18>
        state_funcion[PRINCIPAL - 1]();
        STATE = IDLE_ST;
        break;
    }

    chThdSleepMilliseconds(1);
    1aaa:	80 e1       	ldi	r24, 0x10	; 16
    1aac:	90 e0       	ldi	r25, 0x00	; 0
    1aae:	0f db       	rcall	.-2530   	; 0x10ce <chThdSleep>
  state_funcion_t state_funcion[1] = {PrincipalTimer};

  chRegSetThreadName("Process Event");
  while (1)
  {
    switch (STATE)
    1ab0:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
    1ab4:	81 30       	cpi	r24, 0x01	; 1
    {
      case IDLE_ST:
        break;
    
      case PRINCIPAL:
        state_funcion[PRINCIPAL - 1]();
    1ab6:	c9 f7       	brne	.-14     	; 0x1aaa <ProcessEvent+0x12>
    1ab8:	b6 df       	rcall	.-148    	; 0x1a26 <PrincipalTimer>
        STATE = IDLE_ST;
    1aba:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__DATA_REGION_ORIGIN__>
        break;
    1abe:	f5 cf       	rjmp	.-22     	; 0x1aaa <ProcessEvent+0x12>

00001ac0 <vfprintf>:
    1ac0:	ab e0       	ldi	r26, 0x0B	; 11
    1ac2:	b0 e0       	ldi	r27, 0x00	; 0
    1ac4:	e5 e6       	ldi	r30, 0x65	; 101
    1ac6:	fd e0       	ldi	r31, 0x0D	; 13
    1ac8:	c4 c2       	rjmp	.+1416   	; 0x2052 <__prologue_saves__+0x8>
    1aca:	6c 01       	movw	r12, r24
    1acc:	7b 01       	movw	r14, r22
    1ace:	3a 01       	movw	r6, r20
    1ad0:	fc 01       	movw	r30, r24
    1ad2:	17 82       	std	Z+7, r1	; 0x07
    1ad4:	16 82       	std	Z+6, r1	; 0x06
    1ad6:	83 81       	ldd	r24, Z+3	; 0x03
    1ad8:	81 ff       	sbrs	r24, 1
    1ada:	ff c0       	rjmp	.+510    	; 0x1cda <vfprintf+0x21a>
    1adc:	ce 01       	movw	r24, r28
    1ade:	01 96       	adiw	r24, 0x01	; 1
    1ae0:	4c 01       	movw	r8, r24
    1ae2:	f6 01       	movw	r30, r12
    1ae4:	b3 80       	ldd	r11, Z+3	; 0x03
    1ae6:	f7 01       	movw	r30, r14
    1ae8:	b3 fc       	sbrc	r11, 3
    1aea:	05 91       	lpm	r16, Z+
    1aec:	b3 fe       	sbrs	r11, 3
    1aee:	01 91       	ld	r16, Z+
    1af0:	7f 01       	movw	r14, r30
    1af2:	00 23       	and	r16, r16
    1af4:	41 f1       	breq	.+80     	; 0x1b46 <vfprintf+0x86>
    1af6:	05 32       	cpi	r16, 0x25	; 37
    1af8:	39 f4       	brne	.+14     	; 0x1b08 <vfprintf+0x48>
    1afa:	b3 fc       	sbrc	r11, 3
    1afc:	05 91       	lpm	r16, Z+
    1afe:	b3 fe       	sbrs	r11, 3
    1b00:	01 91       	ld	r16, Z+
    1b02:	7f 01       	movw	r14, r30
    1b04:	05 32       	cpi	r16, 0x25	; 37
    1b06:	39 f5       	brne	.+78     	; 0x1b56 <vfprintf+0x96>
    1b08:	b6 01       	movw	r22, r12
    1b0a:	80 2f       	mov	r24, r16
    1b0c:	90 e0       	ldi	r25, 0x00	; 0
    1b0e:	2c d3       	rcall	.+1624   	; 0x2168 <fputc>
    1b10:	53 01       	movw	r10, r6
    1b12:	35 01       	movw	r6, r10
    1b14:	e6 cf       	rjmp	.-52     	; 0x1ae2 <vfprintf+0x22>
    1b16:	10 68       	ori	r17, 0x80	; 128
    1b18:	f7 01       	movw	r30, r14
    1b1a:	b3 fc       	sbrc	r11, 3
    1b1c:	05 91       	lpm	r16, Z+
    1b1e:	b3 fe       	sbrs	r11, 3
    1b20:	01 91       	ld	r16, Z+
    1b22:	7f 01       	movw	r14, r30
    1b24:	17 fd       	sbrc	r17, 7
    1b26:	0d c0       	rjmp	.+26     	; 0x1b42 <vfprintf+0x82>
    1b28:	00 23       	and	r16, r16
    1b2a:	69 f0       	breq	.+26     	; 0x1b46 <vfprintf+0x86>
    1b2c:	60 2f       	mov	r22, r16
    1b2e:	70 e0       	ldi	r23, 0x00	; 0
    1b30:	8f e6       	ldi	r24, 0x6F	; 111
    1b32:	90 e0       	ldi	r25, 0x00	; 0
    1b34:	c9 d2       	rcall	.+1426   	; 0x20c8 <strchr_P>
    1b36:	89 2b       	or	r24, r25
    1b38:	79 f7       	brne	.-34     	; 0x1b18 <vfprintf+0x58>
    1b3a:	03 32       	cpi	r16, 0x23	; 35
    1b3c:	51 f0       	breq	.+20     	; 0x1b52 <vfprintf+0x92>
    1b3e:	0c 36       	cpi	r16, 0x6C	; 108
    1b40:	51 f3       	breq	.-44     	; 0x1b16 <vfprintf+0x56>
    1b42:	01 11       	cpse	r16, r1
    1b44:	0a c0       	rjmp	.+20     	; 0x1b5a <vfprintf+0x9a>
    1b46:	f6 01       	movw	r30, r12
    1b48:	86 81       	ldd	r24, Z+6	; 0x06
    1b4a:	97 81       	ldd	r25, Z+7	; 0x07
    1b4c:	2b 96       	adiw	r28, 0x0b	; 11
    1b4e:	ee e0       	ldi	r30, 0x0E	; 14
    1b50:	9c c2       	rjmp	.+1336   	; 0x208a <__epilogue_restores__+0x8>
    1b52:	10 e1       	ldi	r17, 0x10	; 16
    1b54:	e1 cf       	rjmp	.-62     	; 0x1b18 <vfprintf+0x58>
    1b56:	10 e0       	ldi	r17, 0x00	; 0
    1b58:	e5 cf       	rjmp	.-54     	; 0x1b24 <vfprintf+0x64>
    1b5a:	60 2f       	mov	r22, r16
    1b5c:	70 e0       	ldi	r23, 0x00	; 0
    1b5e:	88 e6       	ldi	r24, 0x68	; 104
    1b60:	90 e0       	ldi	r25, 0x00	; 0
    1b62:	b2 d2       	rcall	.+1380   	; 0x20c8 <strchr_P>
    1b64:	89 2b       	or	r24, r25
    1b66:	49 f0       	breq	.+18     	; 0x1b7a <vfprintf+0xba>
    1b68:	53 01       	movw	r10, r6
    1b6a:	f4 e0       	ldi	r31, 0x04	; 4
    1b6c:	af 0e       	add	r10, r31
    1b6e:	b1 1c       	adc	r11, r1
    1b70:	b6 01       	movw	r22, r12
    1b72:	8f e3       	ldi	r24, 0x3F	; 63
    1b74:	90 e0       	ldi	r25, 0x00	; 0
    1b76:	f8 d2       	rcall	.+1520   	; 0x2168 <fputc>
    1b78:	cc cf       	rjmp	.-104    	; 0x1b12 <vfprintf+0x52>
    1b7a:	03 36       	cpi	r16, 0x63	; 99
    1b7c:	09 f4       	brne	.+2      	; 0x1b80 <vfprintf+0xc0>
    1b7e:	52 c0       	rjmp	.+164    	; 0x1c24 <vfprintf+0x164>
    1b80:	03 37       	cpi	r16, 0x73	; 115
    1b82:	09 f4       	brne	.+2      	; 0x1b86 <vfprintf+0xc6>
    1b84:	59 c0       	rjmp	.+178    	; 0x1c38 <vfprintf+0x178>
    1b86:	03 35       	cpi	r16, 0x53	; 83
    1b88:	09 f4       	brne	.+2      	; 0x1b8c <vfprintf+0xcc>
    1b8a:	55 c0       	rjmp	.+170    	; 0x1c36 <vfprintf+0x176>
    1b8c:	04 36       	cpi	r16, 0x64	; 100
    1b8e:	19 f0       	breq	.+6      	; 0x1b96 <vfprintf+0xd6>
    1b90:	09 36       	cpi	r16, 0x69	; 105
    1b92:	09 f0       	breq	.+2      	; 0x1b96 <vfprintf+0xd6>
    1b94:	70 c0       	rjmp	.+224    	; 0x1c76 <vfprintf+0x1b6>
    1b96:	53 01       	movw	r10, r6
    1b98:	17 ff       	sbrs	r17, 7
    1b9a:	62 c0       	rjmp	.+196    	; 0x1c60 <vfprintf+0x1a0>
    1b9c:	f4 e0       	ldi	r31, 0x04	; 4
    1b9e:	af 0e       	add	r10, r31
    1ba0:	b1 1c       	adc	r11, r1
    1ba2:	f3 01       	movw	r30, r6
    1ba4:	60 81       	ld	r22, Z
    1ba6:	71 81       	ldd	r23, Z+1	; 0x01
    1ba8:	82 81       	ldd	r24, Z+2	; 0x02
    1baa:	93 81       	ldd	r25, Z+3	; 0x03
    1bac:	1f 7e       	andi	r17, 0xEF	; 239
    1bae:	97 ff       	sbrs	r25, 7
    1bb0:	08 c0       	rjmp	.+16     	; 0x1bc2 <vfprintf+0x102>
    1bb2:	90 95       	com	r25
    1bb4:	80 95       	com	r24
    1bb6:	70 95       	com	r23
    1bb8:	61 95       	neg	r22
    1bba:	7f 4f       	sbci	r23, 0xFF	; 255
    1bbc:	8f 4f       	sbci	r24, 0xFF	; 255
    1bbe:	9f 4f       	sbci	r25, 0xFF	; 255
    1bc0:	10 64       	ori	r17, 0x40	; 64
    1bc2:	2a e0       	ldi	r18, 0x0A	; 10
    1bc4:	30 e0       	ldi	r19, 0x00	; 0
    1bc6:	a4 01       	movw	r20, r8
    1bc8:	17 d3       	rcall	.+1582   	; 0x21f8 <__ultoa_invert>
    1bca:	08 2f       	mov	r16, r24
    1bcc:	08 19       	sub	r16, r8
    1bce:	16 ff       	sbrs	r17, 6
    1bd0:	04 c0       	rjmp	.+8      	; 0x1bda <vfprintf+0x11a>
    1bd2:	b6 01       	movw	r22, r12
    1bd4:	8d e2       	ldi	r24, 0x2D	; 45
    1bd6:	90 e0       	ldi	r25, 0x00	; 0
    1bd8:	c7 d2       	rcall	.+1422   	; 0x2168 <fputc>
    1bda:	14 ff       	sbrs	r17, 4
    1bdc:	13 c0       	rjmp	.+38     	; 0x1c04 <vfprintf+0x144>
    1bde:	fe 01       	movw	r30, r28
    1be0:	e0 0f       	add	r30, r16
    1be2:	f1 1d       	adc	r31, r1
    1be4:	80 81       	ld	r24, Z
    1be6:	80 33       	cpi	r24, 0x30	; 48
    1be8:	69 f0       	breq	.+26     	; 0x1c04 <vfprintf+0x144>
    1bea:	b6 01       	movw	r22, r12
    1bec:	80 e3       	ldi	r24, 0x30	; 48
    1bee:	90 e0       	ldi	r25, 0x00	; 0
    1bf0:	bb d2       	rcall	.+1398   	; 0x2168 <fputc>
    1bf2:	12 ff       	sbrs	r17, 2
    1bf4:	07 c0       	rjmp	.+14     	; 0x1c04 <vfprintf+0x144>
    1bf6:	10 72       	andi	r17, 0x20	; 32
    1bf8:	81 2f       	mov	r24, r17
    1bfa:	90 e0       	ldi	r25, 0x00	; 0
    1bfc:	b6 01       	movw	r22, r12
    1bfe:	88 5a       	subi	r24, 0xA8	; 168
    1c00:	9f 4f       	sbci	r25, 0xFF	; 255
    1c02:	b2 d2       	rcall	.+1380   	; 0x2168 <fputc>
    1c04:	01 50       	subi	r16, 0x01	; 1
    1c06:	10 e0       	ldi	r17, 0x00	; 0
    1c08:	0f 5f       	subi	r16, 0xFF	; 255
    1c0a:	1f 4f       	sbci	r17, 0xFF	; 255
    1c0c:	08 0d       	add	r16, r8
    1c0e:	19 1d       	adc	r17, r9
    1c10:	f8 01       	movw	r30, r16
    1c12:	82 91       	ld	r24, -Z
    1c14:	8f 01       	movw	r16, r30
    1c16:	b6 01       	movw	r22, r12
    1c18:	90 e0       	ldi	r25, 0x00	; 0
    1c1a:	a6 d2       	rcall	.+1356   	; 0x2168 <fputc>
    1c1c:	08 15       	cp	r16, r8
    1c1e:	19 05       	cpc	r17, r9
    1c20:	b9 f7       	brne	.-18     	; 0x1c10 <vfprintf+0x150>
    1c22:	77 cf       	rjmp	.-274    	; 0x1b12 <vfprintf+0x52>
    1c24:	53 01       	movw	r10, r6
    1c26:	82 e0       	ldi	r24, 0x02	; 2
    1c28:	a8 0e       	add	r10, r24
    1c2a:	b1 1c       	adc	r11, r1
    1c2c:	b6 01       	movw	r22, r12
    1c2e:	f3 01       	movw	r30, r6
    1c30:	80 81       	ld	r24, Z
    1c32:	91 81       	ldd	r25, Z+1	; 0x01
    1c34:	a0 cf       	rjmp	.-192    	; 0x1b76 <vfprintf+0xb6>
    1c36:	11 60       	ori	r17, 0x01	; 1
    1c38:	53 01       	movw	r10, r6
    1c3a:	f2 e0       	ldi	r31, 0x02	; 2
    1c3c:	af 0e       	add	r10, r31
    1c3e:	b1 1c       	adc	r11, r1
    1c40:	f3 01       	movw	r30, r6
    1c42:	60 80       	ld	r6, Z
    1c44:	71 80       	ldd	r7, Z+1	; 0x01
    1c46:	f3 01       	movw	r30, r6
    1c48:	10 fd       	sbrc	r17, 0
    1c4a:	85 91       	lpm	r24, Z+
    1c4c:	10 ff       	sbrs	r17, 0
    1c4e:	81 91       	ld	r24, Z+
    1c50:	3f 01       	movw	r6, r30
    1c52:	88 23       	and	r24, r24
    1c54:	09 f4       	brne	.+2      	; 0x1c58 <vfprintf+0x198>
    1c56:	5d cf       	rjmp	.-326    	; 0x1b12 <vfprintf+0x52>
    1c58:	b6 01       	movw	r22, r12
    1c5a:	90 e0       	ldi	r25, 0x00	; 0
    1c5c:	85 d2       	rcall	.+1290   	; 0x2168 <fputc>
    1c5e:	f3 cf       	rjmp	.-26     	; 0x1c46 <vfprintf+0x186>
    1c60:	f2 e0       	ldi	r31, 0x02	; 2
    1c62:	af 0e       	add	r10, r31
    1c64:	b1 1c       	adc	r11, r1
    1c66:	f3 01       	movw	r30, r6
    1c68:	60 81       	ld	r22, Z
    1c6a:	71 81       	ldd	r23, Z+1	; 0x01
    1c6c:	07 2e       	mov	r0, r23
    1c6e:	00 0c       	add	r0, r0
    1c70:	88 0b       	sbc	r24, r24
    1c72:	99 0b       	sbc	r25, r25
    1c74:	9b cf       	rjmp	.-202    	; 0x1bac <vfprintf+0xec>
    1c76:	00 37       	cpi	r16, 0x70	; 112
    1c78:	09 f1       	breq	.+66     	; 0x1cbc <vfprintf+0x1fc>
    1c7a:	40 f4       	brcc	.+16     	; 0x1c8c <vfprintf+0x1cc>
    1c7c:	08 35       	cpi	r16, 0x58	; 88
    1c7e:	01 f1       	breq	.+64     	; 0x1cc0 <vfprintf+0x200>
    1c80:	0f 36       	cpi	r16, 0x6F	; 111
    1c82:	09 f0       	breq	.+2      	; 0x1c86 <vfprintf+0x1c6>
    1c84:	60 cf       	rjmp	.-320    	; 0x1b46 <vfprintf+0x86>
    1c86:	28 e0       	ldi	r18, 0x08	; 8
    1c88:	30 e0       	ldi	r19, 0x00	; 0
    1c8a:	0c c0       	rjmp	.+24     	; 0x1ca4 <vfprintf+0x1e4>
    1c8c:	05 37       	cpi	r16, 0x75	; 117
    1c8e:	39 f0       	breq	.+14     	; 0x1c9e <vfprintf+0x1de>
    1c90:	08 37       	cpi	r16, 0x78	; 120
    1c92:	09 f0       	breq	.+2      	; 0x1c96 <vfprintf+0x1d6>
    1c94:	58 cf       	rjmp	.-336    	; 0x1b46 <vfprintf+0x86>
    1c96:	14 62       	ori	r17, 0x24	; 36
    1c98:	20 e1       	ldi	r18, 0x10	; 16
    1c9a:	30 e0       	ldi	r19, 0x00	; 0
    1c9c:	03 c0       	rjmp	.+6      	; 0x1ca4 <vfprintf+0x1e4>
    1c9e:	1f 7e       	andi	r17, 0xEF	; 239
    1ca0:	2a e0       	ldi	r18, 0x0A	; 10
    1ca2:	30 e0       	ldi	r19, 0x00	; 0
    1ca4:	53 01       	movw	r10, r6
    1ca6:	17 ff       	sbrs	r17, 7
    1ca8:	0f c0       	rjmp	.+30     	; 0x1cc8 <vfprintf+0x208>
    1caa:	f4 e0       	ldi	r31, 0x04	; 4
    1cac:	af 0e       	add	r10, r31
    1cae:	b1 1c       	adc	r11, r1
    1cb0:	f3 01       	movw	r30, r6
    1cb2:	60 81       	ld	r22, Z
    1cb4:	71 81       	ldd	r23, Z+1	; 0x01
    1cb6:	82 81       	ldd	r24, Z+2	; 0x02
    1cb8:	93 81       	ldd	r25, Z+3	; 0x03
    1cba:	85 cf       	rjmp	.-246    	; 0x1bc6 <vfprintf+0x106>
    1cbc:	10 61       	ori	r17, 0x10	; 16
    1cbe:	eb cf       	rjmp	.-42     	; 0x1c96 <vfprintf+0x1d6>
    1cc0:	14 60       	ori	r17, 0x04	; 4
    1cc2:	20 e1       	ldi	r18, 0x10	; 16
    1cc4:	32 e0       	ldi	r19, 0x02	; 2
    1cc6:	ee cf       	rjmp	.-36     	; 0x1ca4 <vfprintf+0x1e4>
    1cc8:	f2 e0       	ldi	r31, 0x02	; 2
    1cca:	af 0e       	add	r10, r31
    1ccc:	b1 1c       	adc	r11, r1
    1cce:	f3 01       	movw	r30, r6
    1cd0:	60 81       	ld	r22, Z
    1cd2:	71 81       	ldd	r23, Z+1	; 0x01
    1cd4:	90 e0       	ldi	r25, 0x00	; 0
    1cd6:	80 e0       	ldi	r24, 0x00	; 0
    1cd8:	76 cf       	rjmp	.-276    	; 0x1bc6 <vfprintf+0x106>
    1cda:	8f ef       	ldi	r24, 0xFF	; 255
    1cdc:	9f ef       	ldi	r25, 0xFF	; 255
    1cde:	36 cf       	rjmp	.-404    	; 0x1b4c <vfprintf+0x8c>

00001ce0 <putval>:
    1ce0:	20 fd       	sbrc	r18, 0
    1ce2:	09 c0       	rjmp	.+18     	; 0x1cf6 <putval+0x16>
    1ce4:	fc 01       	movw	r30, r24
    1ce6:	23 fd       	sbrc	r18, 3
    1ce8:	05 c0       	rjmp	.+10     	; 0x1cf4 <putval+0x14>
    1cea:	22 ff       	sbrs	r18, 2
    1cec:	02 c0       	rjmp	.+4      	; 0x1cf2 <putval+0x12>
    1cee:	73 83       	std	Z+3, r23	; 0x03
    1cf0:	62 83       	std	Z+2, r22	; 0x02
    1cf2:	51 83       	std	Z+1, r21	; 0x01
    1cf4:	40 83       	st	Z, r20
    1cf6:	08 95       	ret

00001cf8 <mulacc>:
    1cf8:	44 fd       	sbrc	r20, 4
    1cfa:	17 c0       	rjmp	.+46     	; 0x1d2a <mulacc+0x32>
    1cfc:	46 fd       	sbrc	r20, 6
    1cfe:	1d c0       	rjmp	.+58     	; 0x1d3a <mulacc+0x42>
    1d00:	db 01       	movw	r26, r22
    1d02:	fc 01       	movw	r30, r24
    1d04:	aa 0f       	add	r26, r26
    1d06:	bb 1f       	adc	r27, r27
    1d08:	ee 1f       	adc	r30, r30
    1d0a:	ff 1f       	adc	r31, r31
    1d0c:	10 94       	com	r1
    1d0e:	d1 f7       	brne	.-12     	; 0x1d04 <mulacc+0xc>
    1d10:	6a 0f       	add	r22, r26
    1d12:	7b 1f       	adc	r23, r27
    1d14:	8e 1f       	adc	r24, r30
    1d16:	9f 1f       	adc	r25, r31
    1d18:	66 0f       	add	r22, r22
    1d1a:	77 1f       	adc	r23, r23
    1d1c:	88 1f       	adc	r24, r24
    1d1e:	99 1f       	adc	r25, r25
    1d20:	62 0f       	add	r22, r18
    1d22:	71 1d       	adc	r23, r1
    1d24:	81 1d       	adc	r24, r1
    1d26:	91 1d       	adc	r25, r1
    1d28:	08 95       	ret
    1d2a:	33 e0       	ldi	r19, 0x03	; 3
    1d2c:	66 0f       	add	r22, r22
    1d2e:	77 1f       	adc	r23, r23
    1d30:	88 1f       	adc	r24, r24
    1d32:	99 1f       	adc	r25, r25
    1d34:	31 50       	subi	r19, 0x01	; 1
    1d36:	d1 f7       	brne	.-12     	; 0x1d2c <mulacc+0x34>
    1d38:	f3 cf       	rjmp	.-26     	; 0x1d20 <mulacc+0x28>
    1d3a:	34 e0       	ldi	r19, 0x04	; 4
    1d3c:	f7 cf       	rjmp	.-18     	; 0x1d2c <mulacc+0x34>

00001d3e <skip_spaces>:
    1d3e:	0f 93       	push	r16
    1d40:	1f 93       	push	r17
    1d42:	cf 93       	push	r28
    1d44:	df 93       	push	r29
    1d46:	8c 01       	movw	r16, r24
    1d48:	c8 01       	movw	r24, r16
    1d4a:	d2 d1       	rcall	.+932    	; 0x20f0 <fgetc>
    1d4c:	ec 01       	movw	r28, r24
    1d4e:	97 fd       	sbrc	r25, 7
    1d50:	06 c0       	rjmp	.+12     	; 0x1d5e <skip_spaces+0x20>
    1d52:	b2 d1       	rcall	.+868    	; 0x20b8 <isspace>
    1d54:	89 2b       	or	r24, r25
    1d56:	c1 f7       	brne	.-16     	; 0x1d48 <skip_spaces+0xa>
    1d58:	b8 01       	movw	r22, r16
    1d5a:	ce 01       	movw	r24, r28
    1d5c:	35 d2       	rcall	.+1130   	; 0x21c8 <ungetc>
    1d5e:	ce 01       	movw	r24, r28
    1d60:	df 91       	pop	r29
    1d62:	cf 91       	pop	r28
    1d64:	1f 91       	pop	r17
    1d66:	0f 91       	pop	r16
    1d68:	08 95       	ret

00001d6a <conv_int>:
    1d6a:	8f 92       	push	r8
    1d6c:	9f 92       	push	r9
    1d6e:	af 92       	push	r10
    1d70:	bf 92       	push	r11
    1d72:	ef 92       	push	r14
    1d74:	ff 92       	push	r15
    1d76:	0f 93       	push	r16
    1d78:	1f 93       	push	r17
    1d7a:	cf 93       	push	r28
    1d7c:	df 93       	push	r29
    1d7e:	8c 01       	movw	r16, r24
    1d80:	d6 2f       	mov	r29, r22
    1d82:	7a 01       	movw	r14, r20
    1d84:	b2 2e       	mov	r11, r18
    1d86:	b4 d1       	rcall	.+872    	; 0x20f0 <fgetc>
    1d88:	9c 01       	movw	r18, r24
    1d8a:	33 27       	eor	r19, r19
    1d8c:	2b 32       	cpi	r18, 0x2B	; 43
    1d8e:	31 05       	cpc	r19, r1
    1d90:	29 f0       	breq	.+10     	; 0x1d9c <conv_int+0x32>
    1d92:	2d 32       	cpi	r18, 0x2D	; 45
    1d94:	31 05       	cpc	r19, r1
    1d96:	a1 f4       	brne	.+40     	; 0x1dc0 <conv_int+0x56>
    1d98:	68 94       	set
    1d9a:	b7 f8       	bld	r11, 7
    1d9c:	d1 50       	subi	r29, 0x01	; 1
    1d9e:	61 f4       	brne	.+24     	; 0x1db8 <conv_int+0x4e>
    1da0:	80 e0       	ldi	r24, 0x00	; 0
    1da2:	df 91       	pop	r29
    1da4:	cf 91       	pop	r28
    1da6:	1f 91       	pop	r17
    1da8:	0f 91       	pop	r16
    1daa:	ff 90       	pop	r15
    1dac:	ef 90       	pop	r14
    1dae:	bf 90       	pop	r11
    1db0:	af 90       	pop	r10
    1db2:	9f 90       	pop	r9
    1db4:	8f 90       	pop	r8
    1db6:	08 95       	ret
    1db8:	c8 01       	movw	r24, r16
    1dba:	9a d1       	rcall	.+820    	; 0x20f0 <fgetc>
    1dbc:	97 fd       	sbrc	r25, 7
    1dbe:	f0 cf       	rjmp	.-32     	; 0x1da0 <conv_int+0x36>
    1dc0:	cb 2d       	mov	r28, r11
    1dc2:	cd 7f       	andi	r28, 0xFD	; 253
    1dc4:	2b 2d       	mov	r18, r11
    1dc6:	20 73       	andi	r18, 0x30	; 48
    1dc8:	e9 f4       	brne	.+58     	; 0x1e04 <conv_int+0x9a>
    1dca:	80 33       	cpi	r24, 0x30	; 48
    1dcc:	d9 f4       	brne	.+54     	; 0x1e04 <conv_int+0x9a>
    1dce:	aa 24       	eor	r10, r10
    1dd0:	aa 94       	dec	r10
    1dd2:	ad 0e       	add	r10, r29
    1dd4:	79 f0       	breq	.+30     	; 0x1df4 <conv_int+0x8a>
    1dd6:	c8 01       	movw	r24, r16
    1dd8:	8b d1       	rcall	.+790    	; 0x20f0 <fgetc>
    1dda:	97 fd       	sbrc	r25, 7
    1ddc:	0b c0       	rjmp	.+22     	; 0x1df4 <conv_int+0x8a>
    1dde:	28 2f       	mov	r18, r24
    1de0:	2f 7d       	andi	r18, 0xDF	; 223
    1de2:	28 35       	cpi	r18, 0x58	; 88
    1de4:	59 f4       	brne	.+22     	; 0x1dfc <conv_int+0x92>
    1de6:	c2 64       	ori	r28, 0x42	; 66
    1de8:	d2 50       	subi	r29, 0x02	; 2
    1dea:	21 f0       	breq	.+8      	; 0x1df4 <conv_int+0x8a>
    1dec:	c8 01       	movw	r24, r16
    1dee:	80 d1       	rcall	.+768    	; 0x20f0 <fgetc>
    1df0:	97 ff       	sbrs	r25, 7
    1df2:	08 c0       	rjmp	.+16     	; 0x1e04 <conv_int+0x9a>
    1df4:	81 2c       	mov	r8, r1
    1df6:	91 2c       	mov	r9, r1
    1df8:	54 01       	movw	r10, r8
    1dfa:	1a c0       	rjmp	.+52     	; 0x1e30 <conv_int+0xc6>
    1dfc:	b6 fe       	sbrs	r11, 6
    1dfe:	29 c0       	rjmp	.+82     	; 0x1e52 <conv_int+0xe8>
    1e00:	c2 60       	ori	r28, 0x02	; 2
    1e02:	da 2d       	mov	r29, r10
    1e04:	81 2c       	mov	r8, r1
    1e06:	91 2c       	mov	r9, r1
    1e08:	54 01       	movw	r10, r8
    1e0a:	20 ed       	ldi	r18, 0xD0	; 208
    1e0c:	28 0f       	add	r18, r24
    1e0e:	28 30       	cpi	r18, 0x08	; 8
    1e10:	18 f1       	brcs	.+70     	; 0x1e58 <conv_int+0xee>
    1e12:	c4 fd       	sbrc	r28, 4
    1e14:	09 c0       	rjmp	.+18     	; 0x1e28 <conv_int+0xbe>
    1e16:	2a 30       	cpi	r18, 0x0A	; 10
    1e18:	f8 f0       	brcs	.+62     	; 0x1e58 <conv_int+0xee>
    1e1a:	c6 ff       	sbrs	r28, 6
    1e1c:	05 c0       	rjmp	.+10     	; 0x1e28 <conv_int+0xbe>
    1e1e:	2f 7d       	andi	r18, 0xDF	; 223
    1e20:	3f ee       	ldi	r19, 0xEF	; 239
    1e22:	32 0f       	add	r19, r18
    1e24:	36 30       	cpi	r19, 0x06	; 6
    1e26:	b8 f0       	brcs	.+46     	; 0x1e56 <conv_int+0xec>
    1e28:	b8 01       	movw	r22, r16
    1e2a:	ce d1       	rcall	.+924    	; 0x21c8 <ungetc>
    1e2c:	c1 ff       	sbrs	r28, 1
    1e2e:	b8 cf       	rjmp	.-144    	; 0x1da0 <conv_int+0x36>
    1e30:	c7 ff       	sbrs	r28, 7
    1e32:	08 c0       	rjmp	.+16     	; 0x1e44 <conv_int+0xda>
    1e34:	b0 94       	com	r11
    1e36:	a0 94       	com	r10
    1e38:	90 94       	com	r9
    1e3a:	80 94       	com	r8
    1e3c:	81 1c       	adc	r8, r1
    1e3e:	91 1c       	adc	r9, r1
    1e40:	a1 1c       	adc	r10, r1
    1e42:	b1 1c       	adc	r11, r1
    1e44:	2c 2f       	mov	r18, r28
    1e46:	b5 01       	movw	r22, r10
    1e48:	a4 01       	movw	r20, r8
    1e4a:	c7 01       	movw	r24, r14
    1e4c:	49 df       	rcall	.-366    	; 0x1ce0 <putval>
    1e4e:	81 e0       	ldi	r24, 0x01	; 1
    1e50:	a8 cf       	rjmp	.-176    	; 0x1da2 <conv_int+0x38>
    1e52:	c2 61       	ori	r28, 0x12	; 18
    1e54:	d6 cf       	rjmp	.-84     	; 0x1e02 <conv_int+0x98>
    1e56:	27 50       	subi	r18, 0x07	; 7
    1e58:	4c 2f       	mov	r20, r28
    1e5a:	c5 01       	movw	r24, r10
    1e5c:	b4 01       	movw	r22, r8
    1e5e:	4c df       	rcall	.-360    	; 0x1cf8 <mulacc>
    1e60:	4b 01       	movw	r8, r22
    1e62:	5c 01       	movw	r10, r24
    1e64:	c2 60       	ori	r28, 0x02	; 2
    1e66:	d1 50       	subi	r29, 0x01	; 1
    1e68:	19 f3       	breq	.-58     	; 0x1e30 <conv_int+0xc6>
    1e6a:	c8 01       	movw	r24, r16
    1e6c:	41 d1       	rcall	.+642    	; 0x20f0 <fgetc>
    1e6e:	97 ff       	sbrs	r25, 7
    1e70:	cc cf       	rjmp	.-104    	; 0x1e0a <conv_int+0xa0>
    1e72:	dc cf       	rjmp	.-72     	; 0x1e2c <conv_int+0xc2>

00001e74 <vfscanf>:
    1e74:	b0 e0       	ldi	r27, 0x00	; 0
    1e76:	a0 e0       	ldi	r26, 0x00	; 0
    1e78:	ef e3       	ldi	r30, 0x3F	; 63
    1e7a:	ff e0       	ldi	r31, 0x0F	; 15
    1e7c:	e9 c0       	rjmp	.+466    	; 0x2050 <__prologue_saves__+0x6>
    1e7e:	6c 01       	movw	r12, r24
    1e80:	eb 01       	movw	r28, r22
    1e82:	5a 01       	movw	r10, r20
    1e84:	fc 01       	movw	r30, r24
    1e86:	17 82       	std	Z+7, r1	; 0x07
    1e88:	16 82       	std	Z+6, r1	; 0x06
    1e8a:	51 2c       	mov	r5, r1
    1e8c:	f6 01       	movw	r30, r12
    1e8e:	f3 80       	ldd	r15, Z+3	; 0x03
    1e90:	fe 01       	movw	r30, r28
    1e92:	f3 fc       	sbrc	r15, 3
    1e94:	85 91       	lpm	r24, Z+
    1e96:	f3 fe       	sbrs	r15, 3
    1e98:	81 91       	ld	r24, Z+
    1e9a:	18 2f       	mov	r17, r24
    1e9c:	ef 01       	movw	r28, r30
    1e9e:	88 23       	and	r24, r24
    1ea0:	c9 f0       	breq	.+50     	; 0x1ed4 <vfscanf+0x60>
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	09 d1       	rcall	.+530    	; 0x20b8 <isspace>
    1ea6:	89 2b       	or	r24, r25
    1ea8:	19 f0       	breq	.+6      	; 0x1eb0 <vfscanf+0x3c>
    1eaa:	c6 01       	movw	r24, r12
    1eac:	48 df       	rcall	.-368    	; 0x1d3e <skip_spaces>
    1eae:	ee cf       	rjmp	.-36     	; 0x1e8c <vfscanf+0x18>
    1eb0:	15 32       	cpi	r17, 0x25	; 37
    1eb2:	41 f4       	brne	.+16     	; 0x1ec4 <vfscanf+0x50>
    1eb4:	fe 01       	movw	r30, r28
    1eb6:	f3 fc       	sbrc	r15, 3
    1eb8:	15 91       	lpm	r17, Z+
    1eba:	f3 fe       	sbrs	r15, 3
    1ebc:	11 91       	ld	r17, Z+
    1ebe:	ef 01       	movw	r28, r30
    1ec0:	15 32       	cpi	r17, 0x25	; 37
    1ec2:	59 f4       	brne	.+22     	; 0x1eda <vfscanf+0x66>
    1ec4:	c6 01       	movw	r24, r12
    1ec6:	14 d1       	rcall	.+552    	; 0x20f0 <fgetc>
    1ec8:	97 fd       	sbrc	r25, 7
    1eca:	98 c0       	rjmp	.+304    	; 0x1ffc <vfscanf+0x188>
    1ecc:	18 17       	cp	r17, r24
    1ece:	f1 f2       	breq	.-68     	; 0x1e8c <vfscanf+0x18>
    1ed0:	b6 01       	movw	r22, r12
    1ed2:	7a d1       	rcall	.+756    	; 0x21c8 <ungetc>
    1ed4:	85 2d       	mov	r24, r5
    1ed6:	90 e0       	ldi	r25, 0x00	; 0
    1ed8:	95 c0       	rjmp	.+298    	; 0x2004 <vfscanf+0x190>
    1eda:	00 e0       	ldi	r16, 0x00	; 0
    1edc:	1a 32       	cpi	r17, 0x2A	; 42
    1ede:	31 f4       	brne	.+12     	; 0x1eec <vfscanf+0x78>
    1ee0:	f3 fc       	sbrc	r15, 3
    1ee2:	15 91       	lpm	r17, Z+
    1ee4:	f3 fe       	sbrs	r15, 3
    1ee6:	11 91       	ld	r17, Z+
    1ee8:	ef 01       	movw	r28, r30
    1eea:	01 e0       	ldi	r16, 0x01	; 1
    1eec:	e1 2c       	mov	r14, r1
    1eee:	20 ed       	ldi	r18, 0xD0	; 208
    1ef0:	21 0f       	add	r18, r17
    1ef2:	2a 30       	cpi	r18, 0x0A	; 10
    1ef4:	38 f1       	brcs	.+78     	; 0x1f44 <vfscanf+0xd0>
    1ef6:	01 ff       	sbrs	r16, 1
    1ef8:	34 c0       	rjmp	.+104    	; 0x1f62 <vfscanf+0xee>
    1efa:	ee 20       	and	r14, r14
    1efc:	59 f3       	breq	.-42     	; 0x1ed4 <vfscanf+0x60>
    1efe:	18 36       	cpi	r17, 0x68	; 104
    1f00:	99 f1       	breq	.+102    	; 0x1f68 <vfscanf+0xf4>
    1f02:	1c 36       	cpi	r17, 0x6C	; 108
    1f04:	09 f4       	brne	.+2      	; 0x1f08 <vfscanf+0x94>
    1f06:	3a c0       	rjmp	.+116    	; 0x1f7c <vfscanf+0x108>
    1f08:	11 23       	and	r17, r17
    1f0a:	21 f3       	breq	.-56     	; 0x1ed4 <vfscanf+0x60>
    1f0c:	61 2f       	mov	r22, r17
    1f0e:	70 e0       	ldi	r23, 0x00	; 0
    1f10:	8f e7       	ldi	r24, 0x7F	; 127
    1f12:	90 e0       	ldi	r25, 0x00	; 0
    1f14:	d9 d0       	rcall	.+434    	; 0x20c8 <strchr_P>
    1f16:	89 2b       	or	r24, r25
    1f18:	e9 f2       	breq	.-70     	; 0x1ed4 <vfscanf+0x60>
    1f1a:	91 2c       	mov	r9, r1
    1f1c:	81 2c       	mov	r8, r1
    1f1e:	00 fd       	sbrc	r16, 0
    1f20:	06 c0       	rjmp	.+12     	; 0x1f2e <vfscanf+0xba>
    1f22:	f5 01       	movw	r30, r10
    1f24:	80 80       	ld	r8, Z
    1f26:	91 80       	ldd	r9, Z+1	; 0x01
    1f28:	c5 01       	movw	r24, r10
    1f2a:	02 96       	adiw	r24, 0x02	; 2
    1f2c:	5c 01       	movw	r10, r24
    1f2e:	1e 36       	cpi	r17, 0x6E	; 110
    1f30:	69 f5       	brne	.+90     	; 0x1f8c <vfscanf+0x118>
    1f32:	f6 01       	movw	r30, r12
    1f34:	46 81       	ldd	r20, Z+6	; 0x06
    1f36:	57 81       	ldd	r21, Z+7	; 0x07
    1f38:	70 e0       	ldi	r23, 0x00	; 0
    1f3a:	60 e0       	ldi	r22, 0x00	; 0
    1f3c:	20 2f       	mov	r18, r16
    1f3e:	c4 01       	movw	r24, r8
    1f40:	cf de       	rcall	.-610    	; 0x1ce0 <putval>
    1f42:	a4 cf       	rjmp	.-184    	; 0x1e8c <vfscanf+0x18>
    1f44:	02 60       	ori	r16, 0x02	; 2
    1f46:	6e 2d       	mov	r22, r14
    1f48:	70 e0       	ldi	r23, 0x00	; 0
    1f4a:	90 e0       	ldi	r25, 0x00	; 0
    1f4c:	80 e0       	ldi	r24, 0x00	; 0
    1f4e:	40 e2       	ldi	r20, 0x20	; 32
    1f50:	d3 de       	rcall	.-602    	; 0x1cf8 <mulacc>
    1f52:	e6 2e       	mov	r14, r22
    1f54:	fe 01       	movw	r30, r28
    1f56:	f3 fc       	sbrc	r15, 3
    1f58:	15 91       	lpm	r17, Z+
    1f5a:	f3 fe       	sbrs	r15, 3
    1f5c:	11 91       	ld	r17, Z+
    1f5e:	ef 01       	movw	r28, r30
    1f60:	c6 cf       	rjmp	.-116    	; 0x1eee <vfscanf+0x7a>
    1f62:	ee 24       	eor	r14, r14
    1f64:	ea 94       	dec	r14
    1f66:	cb cf       	rjmp	.-106    	; 0x1efe <vfscanf+0x8a>
    1f68:	fe 01       	movw	r30, r28
    1f6a:	f3 fc       	sbrc	r15, 3
    1f6c:	15 91       	lpm	r17, Z+
    1f6e:	f3 fe       	sbrs	r15, 3
    1f70:	11 91       	ld	r17, Z+
    1f72:	ef 01       	movw	r28, r30
    1f74:	18 36       	cpi	r17, 0x68	; 104
    1f76:	09 f0       	breq	.+2      	; 0x1f7a <vfscanf+0x106>
    1f78:	c7 cf       	rjmp	.-114    	; 0x1f08 <vfscanf+0x94>
    1f7a:	08 60       	ori	r16, 0x08	; 8
    1f7c:	04 60       	ori	r16, 0x04	; 4
    1f7e:	fe 01       	movw	r30, r28
    1f80:	f3 fc       	sbrc	r15, 3
    1f82:	15 91       	lpm	r17, Z+
    1f84:	f3 fe       	sbrs	r15, 3
    1f86:	11 91       	ld	r17, Z+
    1f88:	ef 01       	movw	r28, r30
    1f8a:	be cf       	rjmp	.-132    	; 0x1f08 <vfscanf+0x94>
    1f8c:	13 36       	cpi	r17, 0x63	; 99
    1f8e:	b9 f4       	brne	.+46     	; 0x1fbe <vfscanf+0x14a>
    1f90:	01 fd       	sbrc	r16, 1
    1f92:	02 c0       	rjmp	.+4      	; 0x1f98 <vfscanf+0x124>
    1f94:	ee 24       	eor	r14, r14
    1f96:	e3 94       	inc	r14
    1f98:	c6 01       	movw	r24, r12
    1f9a:	aa d0       	rcall	.+340    	; 0x20f0 <fgetc>
    1f9c:	97 fd       	sbrc	r25, 7
    1f9e:	2e c0       	rjmp	.+92     	; 0x1ffc <vfscanf+0x188>
    1fa0:	81 14       	cp	r8, r1
    1fa2:	91 04       	cpc	r9, r1
    1fa4:	29 f0       	breq	.+10     	; 0x1fb0 <vfscanf+0x13c>
    1fa6:	f4 01       	movw	r30, r8
    1fa8:	80 83       	st	Z, r24
    1faa:	c4 01       	movw	r24, r8
    1fac:	01 96       	adiw	r24, 0x01	; 1
    1fae:	4c 01       	movw	r8, r24
    1fb0:	ea 94       	dec	r14
    1fb2:	e1 10       	cpse	r14, r1
    1fb4:	f1 cf       	rjmp	.-30     	; 0x1f98 <vfscanf+0x124>
    1fb6:	00 fd       	sbrc	r16, 0
    1fb8:	69 cf       	rjmp	.-302    	; 0x1e8c <vfscanf+0x18>
    1fba:	53 94       	inc	r5
    1fbc:	67 cf       	rjmp	.-306    	; 0x1e8c <vfscanf+0x18>
    1fbe:	c6 01       	movw	r24, r12
    1fc0:	be de       	rcall	.-644    	; 0x1d3e <skip_spaces>
    1fc2:	97 fd       	sbrc	r25, 7
    1fc4:	1b c0       	rjmp	.+54     	; 0x1ffc <vfscanf+0x188>
    1fc6:	1f 36       	cpi	r17, 0x6F	; 111
    1fc8:	09 f4       	brne	.+2      	; 0x1fcc <vfscanf+0x158>
    1fca:	3d c0       	rjmp	.+122    	; 0x2046 <vfscanf+0x1d2>
    1fcc:	30 f4       	brcc	.+12     	; 0x1fda <vfscanf+0x166>
    1fce:	14 36       	cpi	r17, 0x64	; 100
    1fd0:	41 f0       	breq	.+16     	; 0x1fe2 <vfscanf+0x16e>
    1fd2:	19 36       	cpi	r17, 0x69	; 105
    1fd4:	39 f0       	breq	.+14     	; 0x1fe4 <vfscanf+0x170>
    1fd6:	00 64       	ori	r16, 0x40	; 64
    1fd8:	05 c0       	rjmp	.+10     	; 0x1fe4 <vfscanf+0x170>
    1fda:	13 37       	cpi	r17, 0x73	; 115
    1fdc:	11 f1       	breq	.+68     	; 0x2022 <vfscanf+0x1ae>
    1fde:	15 37       	cpi	r17, 0x75	; 117
    1fe0:	d1 f7       	brne	.-12     	; 0x1fd6 <vfscanf+0x162>
    1fe2:	00 62       	ori	r16, 0x20	; 32
    1fe4:	20 2f       	mov	r18, r16
    1fe6:	a4 01       	movw	r20, r8
    1fe8:	6e 2d       	mov	r22, r14
    1fea:	c6 01       	movw	r24, r12
    1fec:	be de       	rcall	.-644    	; 0x1d6a <conv_int>
    1fee:	81 11       	cpse	r24, r1
    1ff0:	e2 cf       	rjmp	.-60     	; 0x1fb6 <vfscanf+0x142>
    1ff2:	f6 01       	movw	r30, r12
    1ff4:	83 81       	ldd	r24, Z+3	; 0x03
    1ff6:	80 73       	andi	r24, 0x30	; 48
    1ff8:	09 f4       	brne	.+2      	; 0x1ffc <vfscanf+0x188>
    1ffa:	6c cf       	rjmp	.-296    	; 0x1ed4 <vfscanf+0x60>
    1ffc:	8f ef       	ldi	r24, 0xFF	; 255
    1ffe:	9f ef       	ldi	r25, 0xFF	; 255
    2000:	51 10       	cpse	r5, r1
    2002:	68 cf       	rjmp	.-304    	; 0x1ed4 <vfscanf+0x60>
    2004:	cd b7       	in	r28, 0x3d	; 61
    2006:	de b7       	in	r29, 0x3e	; 62
    2008:	ef e0       	ldi	r30, 0x0F	; 15
    200a:	3e c0       	rjmp	.+124    	; 0x2088 <__epilogue_restores__+0x6>
    200c:	81 14       	cp	r8, r1
    200e:	91 04       	cpc	r9, r1
    2010:	29 f0       	breq	.+10     	; 0x201c <vfscanf+0x1a8>
    2012:	f4 01       	movw	r30, r8
    2014:	60 82       	st	Z, r6
    2016:	c4 01       	movw	r24, r8
    2018:	01 96       	adiw	r24, 0x01	; 1
    201a:	4c 01       	movw	r8, r24
    201c:	ea 94       	dec	r14
    201e:	ee 20       	and	r14, r14
    2020:	59 f0       	breq	.+22     	; 0x2038 <vfscanf+0x1c4>
    2022:	c6 01       	movw	r24, r12
    2024:	65 d0       	rcall	.+202    	; 0x20f0 <fgetc>
    2026:	3c 01       	movw	r6, r24
    2028:	97 fd       	sbrc	r25, 7
    202a:	06 c0       	rjmp	.+12     	; 0x2038 <vfscanf+0x1c4>
    202c:	45 d0       	rcall	.+138    	; 0x20b8 <isspace>
    202e:	89 2b       	or	r24, r25
    2030:	69 f3       	breq	.-38     	; 0x200c <vfscanf+0x198>
    2032:	b6 01       	movw	r22, r12
    2034:	c3 01       	movw	r24, r6
    2036:	c8 d0       	rcall	.+400    	; 0x21c8 <ungetc>
    2038:	81 14       	cp	r8, r1
    203a:	91 04       	cpc	r9, r1
    203c:	09 f4       	brne	.+2      	; 0x2040 <vfscanf+0x1cc>
    203e:	bb cf       	rjmp	.-138    	; 0x1fb6 <vfscanf+0x142>
    2040:	f4 01       	movw	r30, r8
    2042:	10 82       	st	Z, r1
    2044:	b8 cf       	rjmp	.-144    	; 0x1fb6 <vfscanf+0x142>
    2046:	00 61       	ori	r16, 0x10	; 16
    2048:	cd cf       	rjmp	.-102    	; 0x1fe4 <vfscanf+0x170>

0000204a <__prologue_saves__>:
    204a:	2f 92       	push	r2
    204c:	3f 92       	push	r3
    204e:	4f 92       	push	r4
    2050:	5f 92       	push	r5
    2052:	6f 92       	push	r6
    2054:	7f 92       	push	r7
    2056:	8f 92       	push	r8
    2058:	9f 92       	push	r9
    205a:	af 92       	push	r10
    205c:	bf 92       	push	r11
    205e:	cf 92       	push	r12
    2060:	df 92       	push	r13
    2062:	ef 92       	push	r14
    2064:	ff 92       	push	r15
    2066:	0f 93       	push	r16
    2068:	1f 93       	push	r17
    206a:	cf 93       	push	r28
    206c:	df 93       	push	r29
    206e:	cd b7       	in	r28, 0x3d	; 61
    2070:	de b7       	in	r29, 0x3e	; 62
    2072:	ca 1b       	sub	r28, r26
    2074:	db 0b       	sbc	r29, r27
    2076:	0f b6       	in	r0, 0x3f	; 63
    2078:	f8 94       	cli
    207a:	de bf       	out	0x3e, r29	; 62
    207c:	0f be       	out	0x3f, r0	; 63
    207e:	cd bf       	out	0x3d, r28	; 61
    2080:	09 94       	ijmp

00002082 <__epilogue_restores__>:
    2082:	2a 88       	ldd	r2, Y+18	; 0x12
    2084:	39 88       	ldd	r3, Y+17	; 0x11
    2086:	48 88       	ldd	r4, Y+16	; 0x10
    2088:	5f 84       	ldd	r5, Y+15	; 0x0f
    208a:	6e 84       	ldd	r6, Y+14	; 0x0e
    208c:	7d 84       	ldd	r7, Y+13	; 0x0d
    208e:	8c 84       	ldd	r8, Y+12	; 0x0c
    2090:	9b 84       	ldd	r9, Y+11	; 0x0b
    2092:	aa 84       	ldd	r10, Y+10	; 0x0a
    2094:	b9 84       	ldd	r11, Y+9	; 0x09
    2096:	c8 84       	ldd	r12, Y+8	; 0x08
    2098:	df 80       	ldd	r13, Y+7	; 0x07
    209a:	ee 80       	ldd	r14, Y+6	; 0x06
    209c:	fd 80       	ldd	r15, Y+5	; 0x05
    209e:	0c 81       	ldd	r16, Y+4	; 0x04
    20a0:	1b 81       	ldd	r17, Y+3	; 0x03
    20a2:	aa 81       	ldd	r26, Y+2	; 0x02
    20a4:	b9 81       	ldd	r27, Y+1	; 0x01
    20a6:	ce 0f       	add	r28, r30
    20a8:	d1 1d       	adc	r29, r1
    20aa:	0f b6       	in	r0, 0x3f	; 63
    20ac:	f8 94       	cli
    20ae:	de bf       	out	0x3e, r29	; 62
    20b0:	0f be       	out	0x3f, r0	; 63
    20b2:	cd bf       	out	0x3d, r28	; 61
    20b4:	ed 01       	movw	r28, r26
    20b6:	08 95       	ret

000020b8 <isspace>:
    20b8:	91 11       	cpse	r25, r1
    20ba:	fc c0       	rjmp	.+504    	; 0x22b4 <__ctype_isfalse>
    20bc:	80 32       	cpi	r24, 0x20	; 32
    20be:	19 f0       	breq	.+6      	; 0x20c6 <isspace+0xe>
    20c0:	89 50       	subi	r24, 0x09	; 9
    20c2:	85 50       	subi	r24, 0x05	; 5
    20c4:	d0 f7       	brcc	.-12     	; 0x20ba <isspace+0x2>
    20c6:	08 95       	ret

000020c8 <strchr_P>:
    20c8:	fc 01       	movw	r30, r24
    20ca:	05 90       	lpm	r0, Z+
    20cc:	06 16       	cp	r0, r22
    20ce:	21 f0       	breq	.+8      	; 0x20d8 <strchr_P+0x10>
    20d0:	00 20       	and	r0, r0
    20d2:	d9 f7       	brne	.-10     	; 0x20ca <strchr_P+0x2>
    20d4:	c0 01       	movw	r24, r0
    20d6:	08 95       	ret
    20d8:	31 97       	sbiw	r30, 0x01	; 1
    20da:	cf 01       	movw	r24, r30
    20dc:	08 95       	ret

000020de <memcpy>:
    20de:	fb 01       	movw	r30, r22
    20e0:	dc 01       	movw	r26, r24
    20e2:	02 c0       	rjmp	.+4      	; 0x20e8 <memcpy+0xa>
    20e4:	01 90       	ld	r0, Z+
    20e6:	0d 92       	st	X+, r0
    20e8:	41 50       	subi	r20, 0x01	; 1
    20ea:	50 40       	sbci	r21, 0x00	; 0
    20ec:	d8 f7       	brcc	.-10     	; 0x20e4 <memcpy+0x6>
    20ee:	08 95       	ret

000020f0 <fgetc>:
    20f0:	cf 93       	push	r28
    20f2:	df 93       	push	r29
    20f4:	ec 01       	movw	r28, r24
    20f6:	2b 81       	ldd	r18, Y+3	; 0x03
    20f8:	20 ff       	sbrs	r18, 0
    20fa:	1a c0       	rjmp	.+52     	; 0x2130 <fgetc+0x40>
    20fc:	26 ff       	sbrs	r18, 6
    20fe:	0c c0       	rjmp	.+24     	; 0x2118 <fgetc+0x28>
    2100:	2f 7b       	andi	r18, 0xBF	; 191
    2102:	2b 83       	std	Y+3, r18	; 0x03
    2104:	8e 81       	ldd	r24, Y+6	; 0x06
    2106:	9f 81       	ldd	r25, Y+7	; 0x07
    2108:	01 96       	adiw	r24, 0x01	; 1
    210a:	9f 83       	std	Y+7, r25	; 0x07
    210c:	8e 83       	std	Y+6, r24	; 0x06
    210e:	8a 81       	ldd	r24, Y+2	; 0x02
    2110:	90 e0       	ldi	r25, 0x00	; 0
    2112:	df 91       	pop	r29
    2114:	cf 91       	pop	r28
    2116:	08 95       	ret
    2118:	22 ff       	sbrs	r18, 2
    211a:	18 c0       	rjmp	.+48     	; 0x214c <fgetc+0x5c>
    211c:	e8 81       	ld	r30, Y
    211e:	f9 81       	ldd	r31, Y+1	; 0x01
    2120:	80 81       	ld	r24, Z
    2122:	08 2e       	mov	r0, r24
    2124:	00 0c       	add	r0, r0
    2126:	99 0b       	sbc	r25, r25
    2128:	00 97       	sbiw	r24, 0x00	; 0
    212a:	29 f4       	brne	.+10     	; 0x2136 <fgetc+0x46>
    212c:	20 62       	ori	r18, 0x20	; 32
    212e:	2b 83       	std	Y+3, r18	; 0x03
    2130:	8f ef       	ldi	r24, 0xFF	; 255
    2132:	9f ef       	ldi	r25, 0xFF	; 255
    2134:	ee cf       	rjmp	.-36     	; 0x2112 <fgetc+0x22>
    2136:	31 96       	adiw	r30, 0x01	; 1
    2138:	f9 83       	std	Y+1, r31	; 0x01
    213a:	e8 83       	st	Y, r30
    213c:	2e 81       	ldd	r18, Y+6	; 0x06
    213e:	3f 81       	ldd	r19, Y+7	; 0x07
    2140:	2f 5f       	subi	r18, 0xFF	; 255
    2142:	3f 4f       	sbci	r19, 0xFF	; 255
    2144:	3f 83       	std	Y+7, r19	; 0x07
    2146:	2e 83       	std	Y+6, r18	; 0x06
    2148:	99 27       	eor	r25, r25
    214a:	e3 cf       	rjmp	.-58     	; 0x2112 <fgetc+0x22>
    214c:	ea 85       	ldd	r30, Y+10	; 0x0a
    214e:	fb 85       	ldd	r31, Y+11	; 0x0b
    2150:	09 95       	icall
    2152:	97 ff       	sbrs	r25, 7
    2154:	f3 cf       	rjmp	.-26     	; 0x213c <fgetc+0x4c>
    2156:	2b 81       	ldd	r18, Y+3	; 0x03
    2158:	01 96       	adiw	r24, 0x01	; 1
    215a:	21 f0       	breq	.+8      	; 0x2164 <fgetc+0x74>
    215c:	80 e2       	ldi	r24, 0x20	; 32
    215e:	82 2b       	or	r24, r18
    2160:	8b 83       	std	Y+3, r24	; 0x03
    2162:	e6 cf       	rjmp	.-52     	; 0x2130 <fgetc+0x40>
    2164:	80 e1       	ldi	r24, 0x10	; 16
    2166:	fb cf       	rjmp	.-10     	; 0x215e <fgetc+0x6e>

00002168 <fputc>:
    2168:	0f 93       	push	r16
    216a:	1f 93       	push	r17
    216c:	cf 93       	push	r28
    216e:	df 93       	push	r29
    2170:	18 2f       	mov	r17, r24
    2172:	09 2f       	mov	r16, r25
    2174:	eb 01       	movw	r28, r22
    2176:	8b 81       	ldd	r24, Y+3	; 0x03
    2178:	81 fd       	sbrc	r24, 1
    217a:	09 c0       	rjmp	.+18     	; 0x218e <fputc+0x26>
    217c:	1f ef       	ldi	r17, 0xFF	; 255
    217e:	0f ef       	ldi	r16, 0xFF	; 255
    2180:	81 2f       	mov	r24, r17
    2182:	90 2f       	mov	r25, r16
    2184:	df 91       	pop	r29
    2186:	cf 91       	pop	r28
    2188:	1f 91       	pop	r17
    218a:	0f 91       	pop	r16
    218c:	08 95       	ret
    218e:	82 ff       	sbrs	r24, 2
    2190:	14 c0       	rjmp	.+40     	; 0x21ba <fputc+0x52>
    2192:	2e 81       	ldd	r18, Y+6	; 0x06
    2194:	3f 81       	ldd	r19, Y+7	; 0x07
    2196:	8c 81       	ldd	r24, Y+4	; 0x04
    2198:	9d 81       	ldd	r25, Y+5	; 0x05
    219a:	28 17       	cp	r18, r24
    219c:	39 07       	cpc	r19, r25
    219e:	3c f4       	brge	.+14     	; 0x21ae <fputc+0x46>
    21a0:	e8 81       	ld	r30, Y
    21a2:	f9 81       	ldd	r31, Y+1	; 0x01
    21a4:	cf 01       	movw	r24, r30
    21a6:	01 96       	adiw	r24, 0x01	; 1
    21a8:	99 83       	std	Y+1, r25	; 0x01
    21aa:	88 83       	st	Y, r24
    21ac:	10 83       	st	Z, r17
    21ae:	8e 81       	ldd	r24, Y+6	; 0x06
    21b0:	9f 81       	ldd	r25, Y+7	; 0x07
    21b2:	01 96       	adiw	r24, 0x01	; 1
    21b4:	9f 83       	std	Y+7, r25	; 0x07
    21b6:	8e 83       	std	Y+6, r24	; 0x06
    21b8:	e3 cf       	rjmp	.-58     	; 0x2180 <fputc+0x18>
    21ba:	e8 85       	ldd	r30, Y+8	; 0x08
    21bc:	f9 85       	ldd	r31, Y+9	; 0x09
    21be:	81 2f       	mov	r24, r17
    21c0:	09 95       	icall
    21c2:	89 2b       	or	r24, r25
    21c4:	a1 f3       	breq	.-24     	; 0x21ae <fputc+0x46>
    21c6:	da cf       	rjmp	.-76     	; 0x217c <fputc+0x14>

000021c8 <ungetc>:
    21c8:	fb 01       	movw	r30, r22
    21ca:	23 81       	ldd	r18, Z+3	; 0x03
    21cc:	20 ff       	sbrs	r18, 0
    21ce:	11 c0       	rjmp	.+34     	; 0x21f2 <ungetc+0x2a>
    21d0:	26 fd       	sbrc	r18, 6
    21d2:	0f c0       	rjmp	.+30     	; 0x21f2 <ungetc+0x2a>
    21d4:	8f 3f       	cpi	r24, 0xFF	; 255
    21d6:	98 07       	cpc	r25, r24
    21d8:	71 f0       	breq	.+28     	; 0x21f6 <ungetc+0x2e>
    21da:	82 83       	std	Z+2, r24	; 0x02
    21dc:	2f 7d       	andi	r18, 0xDF	; 223
    21de:	20 64       	ori	r18, 0x40	; 64
    21e0:	23 83       	std	Z+3, r18	; 0x03
    21e2:	26 81       	ldd	r18, Z+6	; 0x06
    21e4:	37 81       	ldd	r19, Z+7	; 0x07
    21e6:	21 50       	subi	r18, 0x01	; 1
    21e8:	31 09       	sbc	r19, r1
    21ea:	37 83       	std	Z+7, r19	; 0x07
    21ec:	26 83       	std	Z+6, r18	; 0x06
    21ee:	99 27       	eor	r25, r25
    21f0:	08 95       	ret
    21f2:	8f ef       	ldi	r24, 0xFF	; 255
    21f4:	9f ef       	ldi	r25, 0xFF	; 255
    21f6:	08 95       	ret

000021f8 <__ultoa_invert>:
    21f8:	fa 01       	movw	r30, r20
    21fa:	aa 27       	eor	r26, r26
    21fc:	28 30       	cpi	r18, 0x08	; 8
    21fe:	51 f1       	breq	.+84     	; 0x2254 <__ultoa_invert+0x5c>
    2200:	20 31       	cpi	r18, 0x10	; 16
    2202:	81 f1       	breq	.+96     	; 0x2264 <__ultoa_invert+0x6c>
    2204:	e8 94       	clt
    2206:	6f 93       	push	r22
    2208:	6e 7f       	andi	r22, 0xFE	; 254
    220a:	6e 5f       	subi	r22, 0xFE	; 254
    220c:	7f 4f       	sbci	r23, 0xFF	; 255
    220e:	8f 4f       	sbci	r24, 0xFF	; 255
    2210:	9f 4f       	sbci	r25, 0xFF	; 255
    2212:	af 4f       	sbci	r26, 0xFF	; 255
    2214:	b1 e0       	ldi	r27, 0x01	; 1
    2216:	3e d0       	rcall	.+124    	; 0x2294 <__ultoa_invert+0x9c>
    2218:	b4 e0       	ldi	r27, 0x04	; 4
    221a:	3c d0       	rcall	.+120    	; 0x2294 <__ultoa_invert+0x9c>
    221c:	67 0f       	add	r22, r23
    221e:	78 1f       	adc	r23, r24
    2220:	89 1f       	adc	r24, r25
    2222:	9a 1f       	adc	r25, r26
    2224:	a1 1d       	adc	r26, r1
    2226:	68 0f       	add	r22, r24
    2228:	79 1f       	adc	r23, r25
    222a:	8a 1f       	adc	r24, r26
    222c:	91 1d       	adc	r25, r1
    222e:	a1 1d       	adc	r26, r1
    2230:	6a 0f       	add	r22, r26
    2232:	71 1d       	adc	r23, r1
    2234:	81 1d       	adc	r24, r1
    2236:	91 1d       	adc	r25, r1
    2238:	a1 1d       	adc	r26, r1
    223a:	20 d0       	rcall	.+64     	; 0x227c <__ultoa_invert+0x84>
    223c:	09 f4       	brne	.+2      	; 0x2240 <__ultoa_invert+0x48>
    223e:	68 94       	set
    2240:	3f 91       	pop	r19
    2242:	2a e0       	ldi	r18, 0x0A	; 10
    2244:	26 9f       	mul	r18, r22
    2246:	11 24       	eor	r1, r1
    2248:	30 19       	sub	r19, r0
    224a:	30 5d       	subi	r19, 0xD0	; 208
    224c:	31 93       	st	Z+, r19
    224e:	de f6       	brtc	.-74     	; 0x2206 <__ultoa_invert+0xe>
    2250:	cf 01       	movw	r24, r30
    2252:	08 95       	ret
    2254:	46 2f       	mov	r20, r22
    2256:	47 70       	andi	r20, 0x07	; 7
    2258:	40 5d       	subi	r20, 0xD0	; 208
    225a:	41 93       	st	Z+, r20
    225c:	b3 e0       	ldi	r27, 0x03	; 3
    225e:	0f d0       	rcall	.+30     	; 0x227e <__ultoa_invert+0x86>
    2260:	c9 f7       	brne	.-14     	; 0x2254 <__ultoa_invert+0x5c>
    2262:	f6 cf       	rjmp	.-20     	; 0x2250 <__ultoa_invert+0x58>
    2264:	46 2f       	mov	r20, r22
    2266:	4f 70       	andi	r20, 0x0F	; 15
    2268:	40 5d       	subi	r20, 0xD0	; 208
    226a:	4a 33       	cpi	r20, 0x3A	; 58
    226c:	18 f0       	brcs	.+6      	; 0x2274 <__ultoa_invert+0x7c>
    226e:	49 5d       	subi	r20, 0xD9	; 217
    2270:	31 fd       	sbrc	r19, 1
    2272:	40 52       	subi	r20, 0x20	; 32
    2274:	41 93       	st	Z+, r20
    2276:	02 d0       	rcall	.+4      	; 0x227c <__ultoa_invert+0x84>
    2278:	a9 f7       	brne	.-22     	; 0x2264 <__ultoa_invert+0x6c>
    227a:	ea cf       	rjmp	.-44     	; 0x2250 <__ultoa_invert+0x58>
    227c:	b4 e0       	ldi	r27, 0x04	; 4
    227e:	a6 95       	lsr	r26
    2280:	97 95       	ror	r25
    2282:	87 95       	ror	r24
    2284:	77 95       	ror	r23
    2286:	67 95       	ror	r22
    2288:	ba 95       	dec	r27
    228a:	c9 f7       	brne	.-14     	; 0x227e <__ultoa_invert+0x86>
    228c:	00 97       	sbiw	r24, 0x00	; 0
    228e:	61 05       	cpc	r22, r1
    2290:	71 05       	cpc	r23, r1
    2292:	08 95       	ret
    2294:	9b 01       	movw	r18, r22
    2296:	ac 01       	movw	r20, r24
    2298:	0a 2e       	mov	r0, r26
    229a:	06 94       	lsr	r0
    229c:	57 95       	ror	r21
    229e:	47 95       	ror	r20
    22a0:	37 95       	ror	r19
    22a2:	27 95       	ror	r18
    22a4:	ba 95       	dec	r27
    22a6:	c9 f7       	brne	.-14     	; 0x229a <__ultoa_invert+0xa2>
    22a8:	62 0f       	add	r22, r18
    22aa:	73 1f       	adc	r23, r19
    22ac:	84 1f       	adc	r24, r20
    22ae:	95 1f       	adc	r25, r21
    22b0:	a0 1d       	adc	r26, r0
    22b2:	08 95       	ret

000022b4 <__ctype_isfalse>:
    22b4:	99 27       	eor	r25, r25
    22b6:	88 27       	eor	r24, r24

000022b8 <__ctype_istrue>:
    22b8:	08 95       	ret

000022ba <_exit>:
    22ba:	f8 94       	cli

000022bc <__stop_program>:
    22bc:	ff cf       	rjmp	.-2      	; 0x22bc <__stop_program>
